[id="message-filtering"]
= Message Filtering

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]

By default, {prodname} delivers every data change event that it receives to the Kafka broker.
However, in many cases, you might be interested in only a subset of the events emitted by the producer. 
To enable you to process only the records that are relevant to you, {prodname} provides the `Filter` simple message transform (SMT).

Configure this transformation in the {prodname} connector's Kafka Connect configuration.
By configuring the `Filter` SMT, you can specify the events that you are interested in by defining filter conditions based on business rules.
As the `Filter` SMT processes the event stream, it evaluates each event against the configured filter conditions.
Only events that meet the criteria of the filter conditions are passed to the broker.

Although Kafka Connect provides its own link:https://cwiki.apache.org/confluence/display/KAFKA/KIP-66%3A+Single+Message+Transforms+for+Kafka+Connect[Simple Message Transforms] (SMT) to encode filtering logic,
it has the following drawbacks:

* It is necessary to compile the transformation upfront and deploy it to Kafka Connect.
* Every change needs code recompilation and redeployment, leading to inflexible operations.

The `Filter` SMT supports scripting languages that integrate with https://jcp.org/en/jsr/detail?id=223[JSR 223] (Scripting for the Java(TM) Platform).

// Type: concept
// ModuleID: example-of-configuring-filter-conditions
// Title: Example of configuring filter conditions 
== Example

To filter change event records, configure the `Filter` transformation in the Kafka Connect configuration for the {prodname} connector.
Configuration of the `Filter` SMT requires you to specify a regular expression that defines the filtering criteria. 

For example, you might add the following configuration in a `.properties` file:name: value

[source]
----
...
transforms=filter
transforms.filter.type=io.debezium.transforms.Filter
transforms.filter.language=jsr223.groovy
transforms.filter.condition=value.op == 'u' && value.before.id == 2
...
----

The preceding example specifies the use of the `Groovy` expression language.
The regular expression `value.op == 'u' && value.before.id == 2` filters out all update records for which the `id` field is equal to `2`.

[IMPORTANT]
====
{prodname} does not come with the language implementations in its installation packages.
It is the user's responsibility to provide an implementation, such as link:https://groovy-lang.org/[Groovy 3] or link:https://github.com/graalvm/graaljs[GraalVM JavaScript], on the classpath.
Bootstrapping is done exclusively via the JSR 223 API currently, so the engine's support for this API must be provided as well.
====

{prodname} binds four variables into the evaluation context:

* `key` - a key of the message
* `value` - a value of the message
* `keySchema` - the schema of the message key
* `valueSchema` - the schema of the message value
* `topic` - the name of the target topic
* `headers` - the map of message headers keyed with header name and value composed of `schema` and `value` variables

The `key` and `value` are of type `org.apache.kafka.connect.data.Struct` and `keySchema` and `valueSchema` are variables of type `org.apache.kafka.connect.data.Schema`.
The expression can invoke arbitrary methods on the variables and should evaluate into a Boolean value that decides whether the message is removed `true` or kept.
Expressions should not result in any side-effects. That is, they should not modify any variables that they pass.

// Type: reference
// ModuleID: filter-condition-configuration-for-other-scripting-languages
// Title: Filter condition configuration for other scripting languages 
== Language specifics

The way that you specify filtering conditions depends on the scripting language that you use.

For example, as shown in {link-prefix}:{link-filtering}#example-of-configuring-filter-conditions[], when you use `Groovy` as the expression language, 
to remove update records for which the `id` value is set to `2`, you would use the following expression:

[source,groovy]
----
value.op == 'u' && value.before.id == 2
----

[TIP]
====
The {prodname} MongoDB connector emits the `after` and `patch` fields not as structures but as serialized JSON documents.
When you use the `Filter` SMT with the MongoDB connector, you should first unwind the field by applying the {link-prefix}:{link-mongodb-event-flattening}[`ExtractNewDocumentState`] SMT.

As an alternative, you can use a JSON parser in the expression.
To use a JSON parser when Groovy is the expression language, add the `groovy-json` artifact to the classpath, and add an expression such as `(new groovy.json.JsonSlurper()).parseText(value.after).last_name == 'Kretchmar'`.
====

.Javascript
When you use JavaScript as the expression language, you can call the `Struct#get()` method to specify the filtering condition, as in the following example:

[source,javascript]
----
value.get('op') == 'u' && value.get('before').get('id') == 2
----

.Javascript with Graal.js
When you create filtering conditions by using JavaScript with Graal.js, you use an approach that is similar to the one use with Groovy.
For example:

[source,javascript]
----
value.op == 'u' && value.before.id == 2
----

// Type: reference
// ModuleID: options-for-configuring-filter-transformation
// Title: Options for configuring `Filter` transformation
[[filter-configuration-options]]
== Configuration options

The following table lists the configuration options for the `Filter` SMT.

.'Filter' configuration options
[cols="30%a,25%a,45%a"]
|===
|Property
|Default
|Description

|[[filter-topic-regex]]<<filter-topic-regex, `topic.regex`>>
|
|An optional regular expression that determines whether the filter logic is applied to an event based on name of the Kafka topic where the event is routed. 
If the destination topic matches the value in `topic.regex`, the transformation applies the filter logic before it passes the event to the topic.
If the destination topic does not match the value in `topic.regex`, the SMT passes the event to the topic unmodified.

|[[filter-language]]<<filter-language, `language`>>
|
|The language in which the expression is written. Must begin with `jsr223.`, e.g. `jsr223.groovy`, or `jsr223.graal.js`. Currently, only bootstrapping via the https://jcp.org/en/jsr/detail?id=223[JSR 223 API] ("Scripting for the Java (TM) Platform") is supported.

|[[filter-condition]]<<filter-condition, `condition`>>
|
|The expression to be evaluated for every message. Must evaluate to a Boolean value where a result of `true` keeps the message, and a result of `false` removes it.

|[[filter-null-handling-mode]]<<filter-null-handling-mode, `null.handling.mode`>>
|`keep`
|Prescribes how the transformation handles `null` (tombstone) messages. The options are: `keep` (the default) to pass the message through, `drop` to remove the messages completely or `evaluate` to run the message through the condition expression.

|===
