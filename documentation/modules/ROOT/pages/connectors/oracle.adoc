// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-oracle"]
= {prodname} Connector for Oracle

:context: oracle
:data-collection: table
:mbean-name: {context}
ifdef::community[]
:toc:
:toc-placement: macro
:linkattrs:
:icons: font

toc::[]

[[oracle-overview]]
== Overview
endif::community[]

{prodname}'s Oracle connector captures and records row-level changes that occur in databases on an Oracle server,
including tables that are added while the connector is running.
You can configure the connector to emit change events for specific subsets of schemas and tables, or to ignore, mask, or truncate values in specific columns.

{prodname} ingests change events from Oracle by using the native LogMiner database package
ifdef::community[]
 or the https://docs.oracle.com/database/121/XSTRM/xstrm_intro.htm#XSTRM72647[XStream API].
While the connector might work with a variety of Oracle versions and editions, only Oracle EE 12 and 19 have been tested.
endif::community[]
ifdef::product[]
.

[IMPORTANT]
====
The {prodname} Oracle connector is a Developer Preview feature.
Developer Preview features provides early access to upcoming product innovations, enabling you to test functionality and provide feedback during the development process.
A Developer Preview feature is not supported with Red Hat production service-level agreements (SLAs) and it might not be functionally complete; therefore, Red Hat does not recommend implementing any Developer Preview features in production environments.
If you need assistance with this feature, you can engage with the https://debezium.io/community/[{prodname} community].
====

Information and procedures for using a {prodname} Oracle connector are organized as follows:

  * xref:how-debezium-oracle-connectors-work[]
  * xref:descriptions-of-debezium-oracle-connector-data-change-events[]
  * xref:how-debezium-oracle-connectors-map-data-types[]
  * xref:setting-up-oracle-to-work-with-debezium[]
  * xref:deployment-of-debezium-oracle-connectors[]
  * xref:monitoring-debezium-oracle-connector-performance[]
// * surrogate-schema-evolution
// * xstreams-support
  * xref:how-debezium-oracle-connectors-handle-faults-and-problems[]
endif::product[]

// Type: assembly
// ModuleID: how-debezium-oracle-connectors-work
// Title: How {prodname} Oracle connectors work
[[how-the-oracle-connector-works]]
== How the Oracle connector works

To optimally configure and run a {prodname} Oracle connector, it is helpful to understand how the connector performs snapshots, streams change events, determines Kafka topic names, and uses metadata.

ifdef::product[]
Details are in the following topics:

* xref:how-debezium-oracle-connectors-perform-database-snapshots[]
* xref:default-names-of-kafka-topics-that-receive-debezium-oracle-change-event-records[]
* xref:how-debezium-oracle-connectors-expose-database-schema-changes[]
* xref:debezium-oracle-connector-generated-events-that-represent-transaction-boundaries[]

endif::product[]

// Type: concept
// Title: How {prodname} Oracle connectors perform database snapshots
// ModuleID: how-debezium-oracle-connectors-perform-database-snapshots
[[oracle-snapshots]]
=== Snapshots

Typically, the redo logs on an Oracle server are configured to not retain the complete history of the database.
As a result, the {prodname} Oracle connector cannot retrieve the entire history of the database from the logs.
To enable the connector to establish a baseline for the current state of the database, the first time that the connector starts, it performs an initial _consistent snapshot_ of the database.

You can customize the way that the connector creates snapshots by setting the value of the xref:oracle-connector-snapshot-mode-configuration-property[`snapshot.mode`] connector configuration property.
By default, the connector's snapshot mode is set to `initial`.

[[default-workflow-for-performing-an-initial-snapshot]]
.Default connector workflow for creating an initial snapshot
When the snapshot mode is set to the default, the connector completes the following tasks to create a snapshot:

1. Determines the tables to be captured
2. Obtains a `ROW SHARE MODE` lock on each of the monitored tables to prevent structural changes from occurring during creation of the snapshot. {prodname} holds the locks for only a short time.
3. Reads the current system change number (SCN) position from the server's redo log.
4. Captures the structure of all relevant tables.
5. Releases the locks obtained in Step 2.
6. Scans all of the relevant database tables and schemas as valid at the SCN position that was read in Step 3 (`SELECT * FROM ... AS OF SCN 123`), generates a `READ` event for each row, and then writes the event records to the table-specific Kafka topic.
7. Records the successful completion of the snapshot in the connector offsets.

After the snapshot process begins, if the process is interrupted due to connector failure, rebalancing, or other reasons, the process restarts after the connector restarts.
After the connector completes the initial snapshot, it continues streaming from the position that it read in Step 3 so that it does not miss any updates.
If the connector stops again for any reason, after it restarts, it resumes streaming changes from where it previously left off.

[id="oracle-connector-snapshot-mode-configuration-property"]
.Settings for `snapshot.mode` connector configuration property
[cols="30%a,70%a",options="header"]
|===
|Setting |Description

|`initial`
|The connector performs a database snapshot as described in the xref:default-workflow-for-performing-an-initial-snapshot[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`schema_only`
|The connector captures the structure of all relevant tables, performing all of the steps described in the xref:default-workflow-for-performing-an-initial-snapshot[default snapshot workflow], except that it does not create `READ` events to represent the data set at the point of the connector's start-up (Step 6).

|`schema_only_recovery`
|Set this option to restore a database history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune the database history topic that experience unexpected growth.
Note this mode is only safe to be used when it is guaranteed that no schema changes happened since the point in time the connector was shut down before and the point in time the snapshot is taken.

|===

// Type: concept
// ModuleID: debezium-oracle-ad-hoc-snapshots
[id="oracle-ad-hoc-snapshots"]
==== Ad hoc snapshots
include::{partialsdir}/modules/all-connectors/con-connector-ad-hoc-snapshots.adoc[leveloffset=+3]

// Type: concept
[id="oracle-incremental-snapshots"]
==== Incremental snapshots
include::{partialsdir}/modules/all-connectors/con-connector-incremental-snapshot.adoc[leveloffset=+3]

[WARNING]
====
The {prodname} connector for Oracle does not support schema changes while an incremental snapshot is running.
====

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-debezium-oracle-change-event-records
// Title: Default names of Kafka topics that receive {prodname} Oracle change event records
[[oracle-topic-names]]
=== Topic names

By default, the Oracle connector writes change events for all `INSERT`, `UPDATE`, and `DELETE` operations that occur in a table to a single Apache Kafka topic that is specific to that table.
The connector uses the following convention to name change event topics:

_serverName.schemaName.tableName_

The following list provides definitions for the components of the default name:

_serverName_:: The logical name of the server as specified by the xref:oracle-property-database-server-name[`database.server.name`] connector configuration property.

_schemaName_:: The name of the schema in which the operation occurred.

_tableName_:: The name of the table in which the operation occurred.

For example, if `fulfillment` is the server name, `inventory` is the schema name, and the database contains tables with the names `orders`, `customers`, and `products`,
the {prodname} Oracle connector emits events to the following Kafka topics, one for each table in the database:

----
fulfillment.inventory.orders
fulfillment.inventory.customers
fulfillment.inventory.products
----

The connector applies similar naming conventions to label its internal database history topics, xref:oracle-schema-change-topic[schema change topics], and xref:oracle-transaction-metadata[transaction metadata topics].

If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see {link-prefix}:{link-topic-routing}#topic-routing[Topic routing].

// Type: concept
// ModuleID: how-debezium-oracle-connectors-expose-database-schema-changes
// Title: How {prodname} Oracle connectors expose database schema changes
[[oracle-schema-change-topic]]
=== Schema change topic

You can configure a {prodname} Oracle connector to produce schema change events that describe schema changes that are applied to captured tables in the database.
The connector writes schema change events to a Kafka topic named `_<serverName>_`, where `_serverName_` is the logical server name that is specified in the xref:oracle-property-database-server-name[`database.server.name`] configuration property.

{prodname} emits a new message to this topic whenever it streams data from a new table.

Messages that the connector sends to the schema change topic contain a payload, and, optionally, also contain the schema of the change event message.
The payload of a schema change event message includes the following elements:

`ddl`:: Provides the SQL `CREATE`, `ALTER`, or `DROP` statement that results in the schema change.
`databaseName`:: The name of the database to which the statements are applied.
The value of `databaseName` serves as the message key.
`tableChanges`::  A structured representation of the entire table schema after the schema change.
The `tableChanges` field contains an array that includes entries for each column of the table.
Because the structured representation presents data in JSON or Avro format, consumers can easily read messages without first processing them through a DDL parser.

[IMPORTANT]
====
When the connector is configured to capture a table, it stores the history of the table's schema changes not only in the schema change topic, but also in an internal database history topic.
The internal database history topic is for connector use only and it is not intended for direct use by consuming applications.
Ensure that applications that require notifications about schema changes consume that information only from the schema change topic.
====

[IMPORTANT]
====
Never partition the database history topic.
For the database history topic to function correctly, it must maintain a consistent, global order of the event records that the connector emits to it.

To ensure that the topic is not split among partitions, set the partition count for the topic by using one of the following methods:

* If you create the database history topic manually, specify a partition count of `1`.
* If you use the Apache Kafka broker to create the database history topic automatically, the topic is created, set the value of the link:{link-kafka-docs}/#brokerconfigs_num.partitions[Kafka `num.partitions`] configuration option to `1`.
====

ifdef::community[]
[WARNING]
====
The schema change topic message format is in an incubating state and might change without notice.
====
endif::community[]

ifdef::community[]
{prodname} emits a new message to this topic whenever it streams data from a new table, or when the structure of the table is altered.

[NOTE]
====
Following a change in table structure, you must follow (the {link-prefix}:{link-oracle-connector}#oracle-schema-evolution[schema evolution procedure].
====
endif::community[]

.Example: Message emitted to the Oracle connector schema change topic
The following example shows a typical schema change message in JSON format.
The message contains a logical representation of the table schema.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
  ...
  },
  "payload": {
    "source": {
      "version": "{debezium-version}",
      "connector": "oracle",
      "name": "server1",
      "ts_ms": 1588252618953,
      "snapshot": "true",
      "db": "ORCLPDB1",
      "schema": "DEBEZIUM",
      "table": "CUSTOMERS",
      "txId" : null,
      "scn" : "1513734",
      "commit_scn": "1513734",
      "lcr_position" : null
    },
    "databaseName": "ORCLPDB1", // <1>
    "schemaName": "DEBEZIUM", //
    "ddl": "CREATE TABLE \"DEBEZIUM\".\"CUSTOMERS\" \n   (    \"ID\" NUMBER(9,0) NOT NULL ENABLE, \n    \"FIRST_NAME\" VARCHAR2(255), \n    \"LAST_NAME" VARCHAR2(255), \n    \"EMAIL\" VARCHAR2(255), \n     PRIMARY KEY (\"ID\") ENABLE, \n     SUPPLEMENTAL LOG DATA (ALL) COLUMNS\n   ) SEGMENT CREATION IMMEDIATE \n  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 \n NOCOMPRESS LOGGING\n  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645\n  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1\n  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)\n  TABLESPACE \"USERS\" ", // <2>
    "tableChanges": [ // <3>
      {
        "type": "CREATE", // <4>
        "id": "\"ORCLPDB1\".\"DEBEZIUM\".\"CUSTOMERS\"", // <5>
        "table": { // <6>
          "defaultCharsetName": null,
          "primaryKeyColumnNames": [ // <7>
            "ID"
          ],
          "columns": [ // <8>
            {
              "name": "ID",
              "jdbcType": 2,
              "nativeType": null,
              "typeName": "NUMBER",
              "typeExpression": "NUMBER",
              "charsetName": null,
              "length": 9,
              "scale": 0,
              "position": 1,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "FIRST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "VARCHAR2",
              "typeExpression": "VARCHAR2",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 2,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "LAST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "VARCHAR2",
              "typeExpression": "VARCHAR2",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 3,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "EMAIL",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "VARCHAR2",
              "typeExpression": "VARCHAR2",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 4,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            }
          ]
        }
      }
    ]
  }
}
----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,4,5",options="header"]
|===
|Item |Field name |Description

|1
|`databaseName` +
`schemaName`
|Identifies the database and the schema that contains the change.

|2
|`ddl`
|This field contains the DDL that is responsible for the schema change.

|3
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|4
|`type`
a|Describes the kind of change. The value is one of the following:

`CREATE`:: Table created.
`ALTER`:: Table modified.
`DROP`:: Table deleted.

|5
|`id`
|Full identifier of the table that was created, altered, or dropped.
In the case of a table rename, this identifier is a concatenation of `_<old>_,_<new>_` table names.

|6
|`table`
|Represents table metadata after the applied change.

|7
|`primaryKeyColumnNames`
|List of columns that compose the table's primary key.

|8
|`columns`
|Metadata for each column in the changed table.

|===

In messages that the connector sends to the schema change topic, the message key is the name of the database that contains the schema change.
In the following example, the `payload` field contains the key:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.oracle.SchemaChangeKey"
  },
  "payload": {
    "databaseName": "ORCLPDB1"
  }
}
----

// Type: assembly
// ModuleID: debezium-oracle-connector-generated-events-that-represent-transaction-boundaries
// Title: {prodname} Oracle connector-generated events that represent transaction boundaries
[[oracle-transaction-metadata]]
=== Transaction Metadata

{prodname} can generate events that represent transaction metadata boundaries and that enrich data change event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

Database transactions are represented by a statement block that is enclosed between the `BEGIN` and `END` keywords.
{prodname} generates transaction boundary events for the `BEGIN` and `END` delimiters in every transaction.
Transaction boundary events contain the following fields:

`status`:: `BEGIN` or `END`
`id`:: String representation of unique transaction identifier.
`event_count` (for `END` events):: Total number of events emmitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` elements that indicates number of events that the connector emits for changes that originate from a data collection.

The following example shows a typical transaction boundary message:

.Example: Oracle connector transaction boundary event

[source,json,indent=0,subs="attributes"]
----
{
  "status": "BEGIN",
  "id": "5.6.641",
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "5.6.641",
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "ORCLPDB1.DEBEZIUM.CUSTOMER",
      "event_count": 1
    },
    {
      "data_collection": "ORCLPDB1.DEBEZIUM.ORDER",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:oracle-property-transaction-topic[`transaction.topic`] option,
the connector emits transaction events to the xref:oracle-property-database-server-name[`_<database.server.name>_`]`.transaction` topic.

//Type: concept
//ModuleID: debezium-oracle-connector-change-data-event-enrichment
==== Change data event enrichment

When transaction metadata is enabled, the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier.
`total_order`:: The absolute position of the event among all events generated by the transaction.
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction.

The following example shows a typical transaction event message:

[source,json,indent=0,subs="attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "transaction": {
    "id": "5.6.641",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

[[oracle-event-buffering]]
=== Event buffering

Oracle writes all changes to the redo logs in the order in which they occur, including changes that are later discarded by a rollback.
As a result, concurrent changes from separate transactions are intertwined.
When the connector first reads the stream of changes, because it cannot immediately determine which changes are committed or rolled back, it temporarily stores the change events in an internal buffer.
After a change is committed, the connector writes the change event from the buffer to Kafka.
The connector drops change events that are discarded by a rollback.

You can configure the buffering mechanism that the connector uses by setting the property xref:oracle-property-log-mining-buffer-type[`log.mining.buffer.type`].

==== Heap
The default buffer type is configured using `memory`.
Under the default `memory` setting, the connector uses the heap memory of the JVM process to allocate and manage buffered event records.
If you use the `memory` buffer setting, be sure that the amount of memory that you allocate to the Java process can accommodate long-running and large transactions in your environment.

ifdef::community[]
[[oracle-event-buffering-infinispan]]
==== Infinispan
The {prodname} Oracle connector can also be configured to use Infinispan as its cache provider, supporting cache stores both locally with embedded mode or remotely on a server cluster.
In order to use Infinispan, the xref:oracle-property-log-mining-buffer-type[`log.mining.buffer.type`] must be configured using either `infinispan_embedded` or `infinispan_remote`.

In order to allow flexibility with Infinispan cache configurations, the connector expects a series of cache configuration properties to be supplied when using Infinispan to buffer event data.
See the xref:oracle-connector-properties[configuration properties] in the `log.mining.buffer.infinispan.cache` namespace.
The contents of these configuration properties depend on whether the connector is to integrate with a remote Infinispan cluster or to use the embedded engine.

For example, the following illustrates what an embedded configuration would look like for the transaction cache property when using Infinispan in embedded mode:

[source,xml]
----
<local-cache name="transactions">
  <persistence passivation="false">
    <file-store fetch-state="true" read-only="false" preload="true" shared="false" segmented="false" path="./data" />
  </persistence>
</local-cache>
----

Looking at the configuration in-depth, the cache is configured to be persistent.
All caches should be configured this way to avoid loss of transaction events across connector restarts if a transaction is in-progress.
Additionally, the location where the cache is kept is defined by the `path` attribute and this should be a shared location accessible all possible runtime environments.

[NOTE]
====
When supplying XML configuration as a JSON connector property value, line breaks must be omitted or replaced with a `\n` character.
====

Another example, the following illustrates the same cache configured with an Infinispan cluster:

[source,xml]
----
<distributed-cache name="transactions" statistics="true">
  <encoding media-type="application/x-protostream" />
  <persistence passivation="false">
    <file-store fetch-state="true" read-only="false" preload="true" shared="false" segmented="false" />
  </persistence>
</distributed-cache>
----

Just like the embedded local-cache configuration from the previous example, this configuration is also defined to be persistent.
All caches should be configured this way to avoid loss of transaction events across connector restarts if a transaction is in-progress.

However, there are a few differences with noting.
First, the cache is defined as a distributed cache rather than a local-cache.
Secondly, the cache is defined to use the `application/x-protostream` encoding, which is required for all Debezium caches.
And lastly, no `path` attribute is necessary on the file store definition since the Infinispan cluster will handle this automatically.

[IMPORTANT]
====
The Infinispan buffer type is considered incubating; the cache formats may change between versions and may require a re-snapshot.
The migration notes will indicate whether this is needed.

Additionally, when removing a {prodname} Oracle connector that uses the Infinispan buffer, the persisted cache files are not removed from disk automatically.
If the same buffer location will be used by a new connector deployment, the files should be removed manually before deploying the new connector.
====

===== Infinispan Hotrod client integration

The {prodname} Oracle connector utilizes the Hotrod client to communicate with the Infinispan cluster.
Any connector property that is prefixed with `log.mining.buffer.infinispan.client.` will be passed directly to the Hotrod client using the `infinispan.client.` namespace, allowing for complete customization of how the client is to interact with the cluster.

There is at least one required configuration property that must be supplied when using this Infinspan mode:

`log.mining.buffer.infinispan.client.hotrod.server_list`::
Specifies the list of Infinispan server hostname and port combinations, using `<hostname>:<port>` format.
endif::community[]

// Type: concept
// ModuleID: debezium-oracle-connector-scn-gap-detection
// Title: Gaps between Oracle SCN values
[[scn-jumps]]
=== SCN gap detection

When the {prodname} Oracle connector is configured to use LogMiner, it collects change events from Oracle by using a start and end range that is based on system change numbers (SCNs).
The connector manages this range automatically, increasing or decreasing the range depending on whether the connector is able to stream changes in near real-time, or must process a backlog because of large or bulk transactions in the database.

Under certain circumstances, the Oracle database advances the system change number by an unusually high amount, rather than increasing it at a constant rate.
Such a jump in the SCN value can occur because of the way that a particular integration interacts with the database, or as a result of events such as hot backups.

The {prodname} Oracle connector relies on the following configuration properties to detect the SCN gap and adjust the mining range.

`log.mining.scn.gap.detection.gap.size.min`:: Specifies the minimum gap size.
`log.mining.scn.gap.detection.time.interval.max.ms`:: Specifies the maximum time interval.

The connector first compares the difference in the number of changes between the current SCN and the highest SCN in the current mining range.
If this difference is greater than the minimum gap size, then the connector has potentially detected a SCN gap.
To confirm whether a gap exists, the connector next compares the timestamps of the current SCN and the SCN at the end of the previous mining range.
If the difference between the timestamps is less than the maximum time interval, then the existence of an SCN gap is confirmed.

When an SCN gap occurs, the {prodname} connector automatically uses the current SCN as the end point for the range of the current mining session.
This allows the connector to quickly catch up to the real-time events without mining smaller ranges in between that return no changes because the SCN value was increased by an unexpectedly large number.
Additionally, the connector will ignore the mining maximum batch size for this iteration only when this occurs.

[WARNING]
====
SCN gap detection is available only if the large SCN increment occurs while the connector is running and processing near real-time events.
====

// Type: assembly
// ModuleID: descriptions-of-debezium-oracle-connector-data-change-events
// Title: Descriptions of {prodname} Oracle connector data change events
[[oracle-events]]
== Data change events

Every data change event that the Oracle connector emits has a key and a value.
The structures of the key and value depend on the table from which the change events originate.
For information about how {prodname} constructs topic names, see {link-prefix}:{link-oracle-connector}#oracle-topic-names[Topic names]).

[WARNING]
====
The {prodname} Oracle connector ensures that all Kafka Connect _schema names_ are http://avro.apache.org/docs/current/spec.html#names[valid Avro schema names].
This means that the logical server name must start with alphabetic characters or an underscore ([a-z,A-Z,\_]),
and the remaining characters in the logical server name and all characters in the schema and table names must be alphanumeric characters or an underscore ([a-z,A-Z,0-9,\_]).
The connector automatically replaces invalid characters with an underscore character.

Unexpected naming conflicts can result when the only distinguishing characters between multiple logical server names, schema names, or table names are not valid characters, and those characters are replaced with underscores.
====

{prodname} and Kafka Connect are designed around _continuous streams of event messages_.
However, the structure of these events might change over time, which can be difficult for topic consumers to handle.
To facilitate the processing of mutable event structures, each event in Kafka Connect is self-contained.
Every message key and value has two parts: a _schema_ and _payload_.
The schema describes the structure of the payload, while the payload contains the actual data.

[WARNING]
====
Changes that are performed by the `SYS` or `SYSTEM` user accounts are not captured by the connector.
====
ifdef::product[]
The following topics contain more details about data change events:

* xref:about-keys-in-debezium-oracle-connector-change-events[]
* xref:about-values-in-debezium-oracle-connector-change-events[]
endif::product[]

// Type: concept
// ModuleID: about-keys-in-debezium-oracle-connector-change-events
// Title: About keys in {prodname} Oracle connector change events
[[oracle-change-event-keys]]
=== Change event keys

For each changed table, the change event key is structured such that a field exists for each column in the primary key (or unique key constraint) of the table at the time when the event is created.

For example, a `customers` table that is defined in the `inventory` database schema, might have the following change event key:

[source,sql,indent=0]
----
CREATE TABLE customers (
  id NUMBER(9) GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH 1001) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(255) NOT NULL,
  last_name VARCHAR2(255) NOT NULL,
  email VARCHAR2(255) NOT NULL UNIQUE
);
----

If the value of the xref:oracle-property-database-server-name[`_<database.server.name>_`]`.transaction` configuration property is set to `server1`,
the JSON representation for every change event that occurs in the `customers` table in the database features the following key structure:

[source,json,indent=0,sub="attributes"]
----
{
    "schema": {
        "type": "struct",
        "fields": [
            {
                "type": "int32",
                "optional": false,
                "field": "ID"
            }
        ],
        "optional": false,
        "name": "server1.INVENTORY.CUSTOMERS.Key"
    },
    "payload": {
        "ID": 1004
    }
}
----

The `schema` portion of the key contains a Kafka Connect schema that describes the content of the key portion.
In the preceding example, the `payload` value is not optional, the structure is defined by a schema named `server1.DEBEZIUM.CUSTOMERS.Key`, and there is one required field named `id` of type `int32`.
The value of the key's `payload` field indicates that it is indeed a structure (which in JSON is just an object) with a single `id` field, whose value is `1004`.

Therefore, you can interpret this key as describing the row in the `inventory.customers` table (output from the connector named `server1`) whose `id` primary key column had a value of `1004`.

////
[NOTE]
====
Although the `column.exclude.list` configuration property allows you to remove columns from the event values, all columns in a primary or unique key are always included in the event's key.
====

[WARNING]
====
If the table does not have a primary or unique key, then the change event's key is null. This makes sense since the rows in a table without a primary or unique key constraint cannot be uniquely identified.
====
////

// Type: concept
// ModuleID: about-values-in-debezium-oracle-connector-change-events
// Title: About values in {prodname} Oracle connector change events
[[oracle-change-event-values]]
=== Change event values

Like the message key, the value of a change event message has a _schema_ section and _payload_ section.
The payload section of every change event value produced by the Oracle connector has an _envelope_ structure with the following fields:

`op`:: A mandatory field that contains a string value describing the type of operation. Values for the Oracle connector are `c` for create (or insert), `u` for update, `d` for delete, and `r` for read (in the case of a snapshot).
`before`:: An optional field that, if present, contains the state of the row _before_ the event occurred. The structure is described by the `server1.INVENTORY.CUSTOMERS.Value` Kafka Connect schema, which the `server1` connector uses for all rows in the `inventory.customers` table.

// [WARNING]
// ====
// Whether or not this field and its elements are available is highly dependent on the https://docs.oracle.com/database/121/SUTIL/GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3.htm#SUTIL1583[Supplemental Logging] configuration applying to the table.
// ====

`after`:: An optional field that if present contains the state of the row _after_ the event occurred. The structure is described by the same `server1.INVENTORY.CUSTOMERS.Value` Kafka Connect schema used in `before`.
`source`:: A mandatory field that contains a structure describing the source metadata for the event, which in the case of Oracle contains these fields: the {prodname} version, the connector name, whether the event is part of an ongoing snapshot or not, the transaction id (not while snapshotting), the SCN of the change, and a timestamp representing the point in time when the record was changed in the source database (during snapshotting, this is the point in time of snapshotting).

[TIP]
====
The `commit_scn` field is optional and describes the SCN of the transaction commit that the change event participates within.
This field is only present when using the LogMiner connection adapter.
====

`ts_ms`:: An optional field that, if present, contains the time (using the system clock in the JVM running the Kafka Connect task) at which the connector processed the event.

And of course, the _schema_ portion of the event message's value contains a schema that describes this envelope structure and the nested fields within it.

// Type: continue
[[oracle-create-events]]
=== _create_ events

Let's look at what a _create_ event value might look like for our `customers` table:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": {
        "type": "struct",
        "fields": [
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "int32",
                        "optional": false,
                        "field": "ID"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "FIRST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "LAST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "EMAIL"
                    }
                ],
                "optional": true,
                "name": "server1.DEBEZIUM.CUSTOMERS.Value",
                "field": "before"
            },
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "int32",
                        "optional": false,
                        "field": "ID"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "FIRST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "LAST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "EMAIL"
                    }
                ],
                "optional": true,
                "name": "server1.DEBEZIUM.CUSTOMERS.Value",
                "field": "after"
            },
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "string",
                        "optional": true,
                        "field": "version"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "name"
                    },
                    {
                        "type": "int64",
                        "optional": true,
                        "field": "ts_ms"
                    },
                    {
                        "type": "string",
                        "optional": true,
                        "field": "txId"
                    },
                    {
                        "type": "string",
                        "optional": true,
                        "field": "scn"
                    },
                    {
                        "type": "string",
                        "optional": true,
                        "field": "commit_scn"
                    },
                    {
                        "type": "boolean",
                        "optional": true,
                        "field": "snapshot"
                    }
                ],
                "optional": false,
                "name": "io.debezium.connector.oracle.Source",
                "field": "source"
            },
            {
                "type": "string",
                "optional": false,
                "field": "op"
            },
            {
                "type": "int64",
                "optional": true,
                "field": "ts_ms"
            }
        ],
        "optional": false,
        "name": "server1.DEBEZIUM.CUSTOMERS.Envelope"
    },
    "payload": {
        "before": null,
        "after": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "annek@noanswer.org"
        },
        "source": {
            "version": "{debezium-version}",
            "name": "server1",
            "ts_ms": 1520085154000,
            "txId": "6.28.807",
            "scn": "2122185",
            "commit_scn": "2122185",
            "snapshot": false
        },
        "op": "c",
        "ts_ms": 1532592105975
    }
}
----

Examining the `schema` portion of the preceding event's _value_, we can see how the following schema are defined:

* The _envelope_
* The `source` structure (which is specific to the Oracle connector and reused across all events).
* The table-specific schemas for the `before` and `after` fields.

[TIP]
====
The names of the schemas for the `before` and `after` fields are of the form `_<logicalName>_._<schemaName>_._<tableName>_.Value`, and thus are entirely independent from the schemas for all other tables.
This means that when using the link:/docs/faq/#avro-converter[Avro Converter], the resulting Avro schems for _each table_ in each _logical source_ have their own evolution and history.
====

The `payload` portion of this event's _value_, provides information about the event.
It describes that a row was created (`op=c`), and shows that the `after` field value contains the values that were inserted into the `ID`, `FIRST_NAME`, `LAST_NAME`, and `EMAIL` columns of the row.

[TIP]
====
By default, the JSON representations of events are much larger than the rows they describe.
This is true, because the JSON representation must include the _schema_ and the _payload_ portions of the message.
You can use the link:/docs/faq/#avro-converter[Avro Converter] to significantly decrease the size of the messages that the connector writes to Kafka topics.
====

// Type: continue
[[oracle-update-events]]
=== _update_ events
The value of an _update_ change event on this table has the same _schema_ as the _create_ event. The payload uses the same structure, but it holds different values.
Here's an example:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "annek@noanswer.org"
        },
        "after": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "anne@example.com"
        },
        "source": {
            "version": "{debezium-version}",
            "name": "server1",
            "ts_ms": 1520085811000,
            "txId": "6.9.809",
            "scn": "2125544",
            "commit_scn": "2125544",
            "snapshot": false
        },
        "op": "u",
        "ts_ms": 1532592713485
    }
}
----

Comparing the value of the _update_ event to the _create_ (insert) event, notice the following differences in the `payload` section:

* The `op` field value is now `u`, signifying that this row changed because of an update
* The `before` field now has the state of the row with the values before the database commit
* The `after` field now has the updated state of the row, and here was can see that the `EMAIL` value is now `anne@example.com`.
* The `source` field structure has the same fields as before, but the values are different since this event is from a different position in the redo log.
* The `ts_ms` shows the timestamp that {prodname} processed this event.

The `payload` section reveals several other useful pieces of information.
For example, by comparing the `before` and `after` structures, we can determine how a row changed as the result of a commit.
The `source` structure provides information about Oracle's record of this change, providing traceability.
It also gives us insight into when this event occurred in relation to other events in this topic and in other topics.
Did it occur before, after, or as part of the same commit as another event?

[NOTE]
====
When the columns for a row's primary/unique key are updated, the value of the row's key changes.
As a result, {prodname} emits _three_ events after such an update:

* A `DELETE` event.
* A {link-prefix}:{link-oracle-connector}#oracle-tombstone-events[tombstone event] with the old key for the row.
* An `INSERT` event that provides the new key for the row.
====

// Type: continue
[[oracle-delete-events]]
=== _delete_ events

So far we've seen samples of _create_ and _update_ events.
Now, let's look at the value of a _delete_ event for the same table. As is the case with _create_ and _update_ events, for a `_delete_` event, the `schema` portion of the value is exactly the same:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "anne@example.com"
        },
        "after": null,
        "source": {
            "version": "{debezium-version}",
            "name": "server1",
            "ts_ms": 1520085153000,
            "txId": "6.28.807",
            "scn": "2122184",
            "commit_scn": "2122184",
            "snapshot": false
        },
        "op": "d",
        "ts_ms": 1532592105960
    }
}
----

If we look at the `payload` portion, we see a number of differences compared with the _create_ or _update_ event payloads:

* The `op` field value is now `d`, signifying that this row was deleted
* The `before` field now has the state of the row that was deleted with the database commit.
* The `after` field is null, signifying that the row no longer exists
* The `source` field structure has many of the same values as before, except the `ts_ms`, `scn` and `txId` fields have changed
* The `ts_ms` shows the timestamp that {prodname} processed this event.

This event gives a consumer all kinds of information that it can use to process the removal of this row.

The Oracle connector's events are designed to work with https://cwiki.apache.org/confluence/display/KAFKA/Log+Compaction[Kafka log compaction],
which allows for the removal of some older messages as long as at least the most recent message for every key is kept.
This allows Kafka to reclaim storage space while ensuring the topic contains a complete dataset and can be used for reloading key-based state.

[[oracle-tombstone-events]]
When a row is deleted, the _delete_ event value listed above still works with log compaction, since Kafka can still remove all earlier messages with that same key.
The message value must be set to `null` to instruct Kafka to remove _all messages_ that share the same key.
To make this possible, by default, {prodname}'s Oracle connector always follows a _delete_ event with a special _tombstone_ event that has the same key but `null` value.
You can change the default behavior by setting the connector property xref:oracle-property-tombstones-on-delete[`tombstones.on.delete`].

// Type: continue
[[oracle-truncate-events]]
=== _truncate_ events

A  _truncate_ change event signals that a table has been truncated.
The message key is `null` in this case, the message value looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": null,
        "after": null,
        "source": { // <1>
            "version": "{debezium-version}",
            "connector": "oracle",
            "name": "oracle_server",
            "ts_ms": 1638974535000,
            "snapshot": "false",
            "db": "ORCLPDB1",
            "sequence": null,
            "schema": "DEBEZIUM",
            "table": "TEST_TABLE",
            "txId": "02000a0037030000",
            "scn": "13234397",
            "commit_scn": "13271102",
            "lcr_position": null
        },
        "op": "t", // <2>
        "ts_ms": 1638974558961, // <3>
        "transaction": null
    }
}
----

.Descriptions of _truncate_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`source`
a|Mandatory field that describes the source metadata for the event. In a _truncate_ event value, the `source` field structure is the same as for _create_, _update_, and _delete_ events for the same table, provides this metadata:

* {prodname} version
* Connector type and name
* Database and table that contains the new row
* Schema name
* If the event was part of a snapshot (always `false` for _truncate_ events)
* ID of the transaction in which the operation was performed
* SCN of the operation
* Timestamp for when the change was made in the database

|2
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `t`, signifying that this table was truncated.

|3
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.  +
+
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

Note that since _truncate_ events represent a change made to an entire table and don't have a message key,
unless you're working with topics with a single partition,
there are no ordering guarantees for the change events pertaining to a table (_create_, _update_, etc.) and _truncate_ events for that table.
For instance a consumer may receive an _update_ event only after a _truncate_ event for that table,
when those events are read from different partitions.

If _truncate_ events are not desired, they can be filtered out with the xref:oracle-property-skipped-operations[`skipped.operations`] option.

// Type: reference
// ModuleID: how-debezium-oracle-connectors-map-data-types
// Title: How {prodname} Oracle connectors map data types
[[oracle-data-type-mappings]]
== Data type mappings

To represent changes that occur in a table rows, the {prodname} Oracle connector emits change events that are structured like the table in which the rows exists.
The event contains a field for each column value.
Column values are represented according to the Oracle data type of the column.
The following sections describe how the connector maps oracle data types to a _literal type_ and a _semantic type_ in event fields.

_literal type_:: Describes how the value is literally represented using Kafka Connect schema types: `INT8`, `INT16`, `INT32`, `INT64`, `FLOAT32`, `FLOAT64`, `BOOLEAN`, `STRING`, `BYTES`, `ARRAY`, `MAP`, and `STRUCT`.

_semantic type_:: Describes how the Kafka Connect schema captures the _meaning_ of the field using the name of the Kafka Connect schema for the field.

ifdef::product[]
Details are in the following sections:

* xref:oracle-character-types[]
* xref:oracle-numeric-types[]
* xref:oracle-decimal-types[]
* xref:oracle-temporal-types[]

endif::product[]

ifdef::community[]
Support for further data types is planned for subsequent releases.
Please file a {jira-url}/browse/DBZ[JIRA issue] for any specific types that might be missing.
endif::community[]

[id="oracle-character-types"]
=== Character types

The following table describes how the connector maps basic character types.

.Mappings for Oracle basic character types
[cols="20%a,15%a,55%a",options="header"]
|===
|Oracle Data Type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`CHAR[(M)]`
|`STRING`
|n/a

|`NCHAR[(M)]`
|`STRING`
|n/a

|`NVARCHAR2[(M)]`
|`STRING`
|n/a

|`VARCHAR[(M)]`
|`STRING`
|n/a

|`VARCHAR2[(M)]`
|`STRING`
|n/a

|===

[id="oracle-binary-character-lob-types"]
=== Binary and Character LOB types
ifdef::community[]
[NOTE]
====
Support for these data types is currently in incubating state, that is, the exact semantics, configuration options and so forth might change in future revisions, based on feedback we receive.
Please let us know if you encounter any problems while using these data types.
====
endif::community[]
The following table describes how the connector maps binary and character large object (LOB) data types.

.Mappings for Oracle binary and character LOB types
[cols="20%a,15%a,55%a",options="header"]
|===
|Oracle Data Type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`BLOB`
|`BYTES`
|Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the xref:#oracle-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`CLOB`
|`STRING`
|n/a

|`LONG`
|n/a
|_This data type is not supported._

|`LONG RAW`
|n/a
|_This data type is not supported._

|`NCLOB`
|`STRING`
|n/a

|`RAW`
|n/a
|_This data type is not supported._

|===

[NOTE]
====
Oracle only supplies column values for `CLOB`, `NCLOB`, and `BLOB` data types if they're explicitly set or changed in a SQL statement.
This means that change events will never contain the value of an unchanged `CLOB`, `NCLOB`, or `BLOB` column,
but a placeholder as defined by the connector property, `unavailable.value.placeholder`.

If the value of a `CLOB`, `NCLOB`, or `BLOB` column gets updated, the new value will be contained in the `after` part of the corresponding update change events whereas the unavailable value placeholder will be used in the `before` part.
====

[id="oracle-numeric-types"]
=== Numeric types

The following table describes how the connector maps numeric types.

.Mappings for Oracle numeric data types
[cols="20%a,15%a,55%a",options="header"]
|===
|Oracle Data Type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`BINARY_FLOAT`
|`FLOAT32`
|n/a

|`BINARY_DOUBLE`
|`FLOAT64`
|n/a

|`DECIMAL[(P, S)]`
|`BYTES` / `INT8` / `INT16` / `INT32` / `INT64`
|`org.apache.kafka.connect.data.Decimal` if using `BYTES` +
 +
Handled equivalently to `NUMBER` (note that S defaults to 0 for `DECIMAL`).

|`DOUBLE PRECISION`
|`STRUCT`
|`io.debezium.data.VariableScaleDecimal` +
 +
Contains a structure with two fields: `scale` of type `INT32` that contains the scale of the transferred value and `value` of type `BYTES` containing the original value in an unscaled form.

|`FLOAT[(P)]`
|`STRUCT`
|`io.debezium.data.VariableScaleDecimal` +
 +
Contains a structure with two fields: `scale` of type `INT32` that contains the scale of the transferred value and `value` of type `BYTES` containing the original value in an unscaled form.

|`INTEGER`, `INT`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal` +
 +
`INTEGER` is mapped in Oracle to NUMBER(38,0) and hence can hold values larger than any of the `INT` types could store

|`NUMBER[(P[, *])]`
|`STRUCT`
|`io.debezium.data.VariableScaleDecimal` +
 +
Contains a structure with two fields: `scale` of type `INT32` that contains the scale of the transferred value and `value` of type `BYTES` containing the original value in an unscaled form.

|`NUMBER(P, S \<= 0)`
|`INT8` / `INT16` / `INT32` / `INT64`
|`NUMBER` columns with a scale of 0 represent integer numbers.
A negative scale indicates rounding in Oracle, for example, a scale of -2 causes rounding to hundreds. +
 +
Depending on the precision and scale, one of the following matching Kafka Connect integer type is chosen: +

 * P - S < 3, `INT8` +
 * P - S < 5, `INT16` +
 * P - S < 10, `INT32` +
 * P - S < 19, `INT64` +
 * P - S >= 19, `BYTES` (`org.apache.kafka.connect.data.Decimal`).

|`NUMBER(P, S > 0)`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`

|`NUMERIC[(P, S)]`
|`BYTES` / `INT8` / `INT16` / `INT32` / `INT64`
|`org.apache.kafka.connect.data.Decimal` if using `BYTES` +
 +
Handled equivalently to `NUMBER` (note that S defaults to 0 for `NUMERIC`).

|`SMALLINT`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal` +
 +
`SMALLINT` is mapped in Oracle to NUMBER(38,0) and hence can hold values larger than any of the `INT` types could store

|`REAL`
|`STRUCT`
|`io.debezium.data.VariableScaleDecimal` +
 +
Contains a structure with two fields: `scale` of type `INT32` that contains the scale of the transferred value and `value` of type `BYTES` containing the original value in an unscaled form.

|===

[id="oracle-boolean-types"]
=== Boolean types

Oracle does not natively have support for a `BOOLEAN` data type; however,
it is common practice to use other data types with certain semantics to simulate the concept of a logical `BOOLEAN` data type.

The operator can configure the out-of-the-box `NumberOneToBooleanConverter` custom converter that would either map all `NUMBER(1)` columns to a `BOOLEAN` or if the `selector` parameter is set,
then a subset of columns could be enumerated using a comma-separated list of regular expressions.

Following is an example configuration:

[source]
----
converters=boolean
boolean.type=io.debezium.connector.oracle.converters.NumberOneToBooleanConverter
boolean.selector=.*MYTABLE.FLAG,.*.IS_ARCHIVED
----

[id="oracle-decimal-types"]
=== Decimal types
The setting of the Oracle connector configuration property, `decimal.handling.mode` determines how the connector maps decimal types.

When the `decimal.handling.mode` property is set to `precise`, the connector uses Kafka Connect `org.apache.kafka.connect.data.Decimal` logical type for all `DECIMAL` and `NUMERIC` columns.
This is the default mode.

However, when the `decimal.handling.mode` property is set to `double`, the connector represents the values as Java double values with schema type `FLOAT64`.

You can also set the `decimal.handling.mode` configuration property to use the `string` option.
When the property is set to `string`, the connector represents `DECIMAL` and `NUMERIC` values as their formatted string representation with schema type `STRING`.

[id="oracle-temporal-types"]
=== Temporal types

Other than Oracle's `INTERVAL`, `TIMESTAMP WITH TIME ZONE` and `TIMESTAMP WITH LOCAL TIME ZONE` data types, the other temporal types depend on the value of the `time.precision.mode` configuration property.

When the `time.precision.mode` configuration property is set to `adaptive` (the default), then the connector determines the literal and semantic type for the temporal types based on the column's data type definition so that events _exactly_ represent the values in the database:

[cols="25%a,20%a,55%a",options="header"]
|===
|Oracle data type |Literal type (schema type) |Semantic type (schema name) and Notes

|`DATE`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds past epoch, and does not include timezone information.

|`INTERVAL DAY[(M)] TO SECOND`
|`FLOAT64`
|`io.debezium.time.MicroDuration` +
 +
The number of micro seconds for a time interval using the `365.25 / 12.0` formula for days per month average. +
 +
`io.debezium.time.Interval` (when `interval.handling.mode` is set to `string`) +
 +
The string representation of the interval value that follows the pattern `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`, for example,  `P1Y2M3DT4H5M6.78S`.

|`INTERVAL YEAR[(M)] TO MONTH`
|`FLOAT64`
|`io.debezium.time.MicroDuration` +
 +
The number of micro seconds for a time interval using the `365.25 / 12.0` formula for days per month average. +
 +
`io.debezium.time.Interval` (when `interval.handling.mode` is set to `string`) +
 +
The string representation of the interval value that follows the pattern `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`, for example,  `P1Y2M3DT4H5M6.78S`.

|`TIMESTAMP(0 - 3)`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds past epoch, and does not include timezone information.

|`TIMESTAMP, TIMESTAMP(4 - 6)`
|`INT64`
|`io.debezium.time.MicroTimestamp` +
 +
Represents the number of microseconds past epoch, and does not include timezone information.

|`TIMESTAMP(7 - 9)`
|`INT64`
|`io.debezium.time.NanoTimestamp` +
 +
Represents the number of nanoseconds past epoch, and does not include timezone information.

|`TIMESTAMP WITH TIME ZONE`
|`STRING`
|`io.debezium.time.ZonedTimestamp` +
 +
A string representation of a timestamp with timezone information.

|`TIMESTAMP WITH LOCAL TIME ZONE`
|`STRING`
|`io.debezium.time.ZonedTimestamp` +
 +
A string representation of a timestamp in UTC.

|===

When the `time.precision.mode` configuration property is set to `connect`, then the connector uses the predefined Kafka Connect logical types.
This can be useful when consumers only know about the built-in Kafka Connect logical types and are unable to handle variable-precision time values.
Because the level of precision that Oracle supports exceeds the level that the logical types in Kafka Connect support, if you set `time.precision.mode` to `connect`, *a loss of precision* results when the _fractional second precision_ value of a database column is greater than 3:

[cols="25%a,20%a,55%a",options="header"]
|===
|Oracle data type |Literal type (schema type) |Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`org.apache.kafka.connect.data.Date` +
 +
Represents the number of days since the epoch.

|`INTERVAL DAY[(M)] TO SECOND`
|`FLOAT64`
|`io.debezium.time.MicroDuration` +
 +
The number of micro seconds for a time interval using the `365.25 / 12.0` formula for days per month average. +
 +
`io.debezium.time.Interval` (when `interval.handling.mode` is set to `string`) +
 +
The string representation of the interval value that follows the pattern `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`, for example,  `P1Y2M3DT4H5M6.78S`.

|`INTERVAL YEAR[(M)] TO MONTH`
|`FLOAT64`
|`io.debezium.time.MicroDuration` +
 +
The number of micro seconds for a time interval using the `365.25 / 12.0` formula for days per month average. +
 +
`io.debezium.time.Interval` (when `interval.handling.mode` is set to `string`) +
 +
The string representation of the interval value that follows the pattern `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`, for example,  `P1Y2M3DT4H5M6.78S`.

|`TIMESTAMP(0 - 3)`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds since epoch, and does not include timezone information.

|`TIMESTAMP(4 - 6)`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds since epoch, and does not include timezone information.

|`TIMESTAMP(7 - 9)`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds since epoch, and does not include timezone information.

|`TIMESTAMP WITH TIME ZONE`
|`STRING`
|`io.debezium.time.ZonedTimestamp` +
 +
A string representation of a timestamp with timezone information.

|`TIMESTAMP WITH LOCAL TIME ZONE`
|`STRING`
|`io.debezium.time.ZonedTimestamp` +
 +
A string representation of a timestamp in UTC.

|===

[[oracle-default-values]]
=== Default Values
If a default value is specified for a column in the database schema, the Oracle connector will attempt to propagate this value to the schema of the corresponding Kafka record field. Most common data types are supported, including:

* Character types (`CHAR`, `NCHAR`, `VARCHAR`, `VARCHAR2`, `NVARCHAR`, `NVARCHAR2`)
* Numeric types (`INTEGER`, `NUMERIC`, etc.)
* Temporal types (`DATE`, `TIMESTAMP`, `INTERVAL`, etc.)

If a temporal type uses a function call such as `TO_TIMESTAMP` or `TO_DATE` to represent the default value, the connector will resolve the default value by making an additional database call to evaluate the function.
For example, if a `DATE` column is defined with the default value of `TO_DATE('2021-01-02', 'YYYY-MM-DD')`, the column's default value will be the number of days since epoch for that date or `18629` in this case.

If a temporal type uses the `SYSDATE` constant to represent the default value, the connector will resolve this based on whether the column is defined as `NOT NULL` or `NULL`.
If the column is nullable, no default value will be set; however, if the column isn't nullable then the default value will be resolved as either `0` (for `DATE` or `TIMESTAMP(n)` data types) or `1970-01-01T00:00:00Z` (for `TIMESTAMP WITH TIME ZONE` or `TIMESTAMP WITH LOCAL TIME ZONE` data types).
The default value type will be numeric except if the column is a `TIMESTAMP WITH TIME ZONE` or `TIMESTAMP WITH LOCAL TIME ZONE` in which case its emitted as a string.

// Type: assembly
// ModuleID: setting-up-oracle-to-work-with-debezium
//Title: Setting up Oracle to work with {prodname}
[[setting-up-oracle]]
== Setting up Oracle

The following steps are necessary to set up Oracle for use with the {prodname} Oracle connector.
These steps assume the use of the multi-tenancy configuration with a container database and at least one pluggable database.
If you do not intend to use a multi-tenant configuration, it might be necessary to adjust the following steps.

For information about using Vagrant to set up Oracle in a virtual machine, see the https://github.com/debezium/oracle-vagrant-box/[Debezium Vagrant Box for Oracle database] GitHub repository.

ifdef::product[]

For details about setting up Oracle for use with the {prodname} connector, see the following sections:

* xref:preparing-oracle-databases-for-use-with-debezium[]
* xref:oracle-redo-log-sizing[]
* xref:creating-an-oracle-user-for-the-debezium-oracle-connector[]

endif::product[]

// Type: procedure
// ModuleID: preparing-oracle-databases-for-use-with-debezium
// Title: Preparing Oracle databases for use with {prodname}
=== Preparing the database

.Configuration needed for Oracle LogMiner
[source,indent=0]
----
ORACLE_SID=ORACLCDB dbz_oracle sqlplus /nolog

CONNECT sys/top_secret AS SYSDBA
alter system set db_recovery_file_dest_size = 10G;
alter system set db_recovery_file_dest = '/opt/oracle/oradata/recovery_area' scope=spfile;
shutdown immediate
startup mount
alter database archivelog;
alter database open;
-- Should now "Database log mode: Archive Mode"
archive log list

exit;
----

In addition, supplemental logging must be enabled for captured tables or the database in order for data changes to capture the _before_ state of changed database rows.
The following illustrates how to configure this on a specific table, which is the ideal choice to minimize the amount of information captured in the Oracle redo logs.

[source,indent=0]
----
ALTER TABLE inventory.customers ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
----

Minimal supplemental logging must be enabled at the database level and can be configured as follows.

[source,indent=0]
----
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;
----

// Type: concept
[id="oracle-redo-log-sizing"]
=== Redo log sizing

Depending on the database configuration, the size and number of redo logs might not be sufficient to achieve acceptable performance.
Before you set up the {prodname} Oracle connector, ensure that the capacity of the redo logs is sufficient to support the database.

The capacity of the redo logs for a database must be sufficient to store its data dictionary.
In general, the size of the data dictionary increases with the number of tables and columns in the database.
If the redo log lacks sufficient capacity, both the database and the {prodname} connector might experience performance problems.

Consult with your database administrator to evaluate whether the database might require increased log capacity.

// Type: procedure
// ModuleID: creating-an-oracle-user-for-the-debezium-oracle-connector
// Title: Creating an Oracle user for the {prodname} Oracle connector
[id="creating-users-for-the-connector"]
=== Creating users for the connector

For the {prodname} Oracle connector to capture change events, it must run as an Oracle LogMiner user that has specific permissions.
The following example shows the SQL for creating an Oracle user account for the connector in a multi-tenant database model.

[WARNING]
====
The connector captures database changes that are made by its own Oracle user account.
However, it does not capture changes that are made by the `SYS` or `SYSTEM` user accounts.
====

[[oracle-create-users-logminer]]
.Creating the connector's LogMiner user
[source,sql,indent=0]
----
sqlplus sys/top_secret@//localhost:1521/ORCLCDB as sysdba
  CREATE TABLESPACE logminer_tbs DATAFILE '/opt/oracle/oradata/ORCLCDB/logminer_tbs.dbf'
    SIZE 25M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED;
  exit;

sqlplus sys/top_secret@//localhost:1521/ORCLPDB1 as sysdba
  CREATE TABLESPACE logminer_tbs DATAFILE '/opt/oracle/oradata/ORCLCDB/ORCLPDB1/logminer_tbs.dbf'
    SIZE 25M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED;
  exit;

sqlplus sys/top_secret@//localhost:1521/ORCLCDB as sysdba

  CREATE USER c##dbzuser IDENTIFIED BY dbz
    DEFAULT TABLESPACE logminer_tbs
    QUOTA UNLIMITED ON logminer_tbs
    CONTAINER=ALL;

  GRANT CREATE SESSION TO c##dbzuser CONTAINER=ALL;
  GRANT SET CONTAINER TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$DATABASE to c##dbzuser CONTAINER=ALL;
  GRANT FLASHBACK ANY TABLE TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ANY TABLE TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT_CATALOG_ROLE TO c##dbzuser CONTAINER=ALL;
  GRANT EXECUTE_CATALOG_ROLE TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ANY TRANSACTION TO c##dbzuser CONTAINER=ALL;
  GRANT LOGMINING TO c##dbzuser CONTAINER=ALL;

  GRANT CREATE TABLE TO c##dbzuser CONTAINER=ALL;
  GRANT LOCK ANY TABLE TO c##dbzuser CONTAINER=ALL;
  GRANT CREATE SEQUENCE TO c##dbzuser CONTAINER=ALL;

  GRANT EXECUTE ON DBMS_LOGMNR TO c##dbzuser CONTAINER=ALL;
  GRANT EXECUTE ON DBMS_LOGMNR_D TO c##dbzuser CONTAINER=ALL;

  GRANT SELECT ON V_$LOG TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$LOG_HISTORY TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$LOGMNR_LOGS TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$LOGMNR_CONTENTS TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$LOGMNR_PARAMETERS TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$LOGFILE TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$ARCHIVED_LOG TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$ARCHIVE_DEST_STATUS TO c##dbzuser CONTAINER=ALL;

  exit;
----
// Type: assembly
// ModuleID: deployment-of-debezium-oracle-connectors
// Title: Deployment of {prodname} Oracle connectors
[[oracle-deploying-a-connector]]
== Deployment

ifdef::community[]
To deploy a {prodname} Oracle connector, you install the {prodname} Oracle connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites
* link:https://zookeeper.apache.org/[Apache ZooKeeper], link:http://kafka.apache.org/[Apache Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* Oracle Database is installed, and is {link-prefix}:{link-oracle-connector}#setting-up-oracle[configured to work with the {prodname} connector].
* You have a copies of the Oracle JDBC driver and the XStream API JAR.
+
[IMPORTANT]
====
Due to licensing requirements, the {prodname} Oracle connector does not ship with the Oracle JDBC driver or XStream API files.
You must download these files directly from Oracle and add them to your environment.
For more information, see {link-prefix}:{link-oracle-connector}#obtaining-oracle-jdbc-driver-and-xstreams-api-files[Obtaining the Oracle JDBC driver and XStream API files].
====

.Procedure

. Download the {prodname} https://repo1.maven.org/maven2/io/debezium/debezium-connector-oracle/{debezium-version}/debezium-connector-oracle-{debezium-version}-plugin.tar.gz[Oracle connector plug-in archive].

. Extract the files into your Kafka Connect environment.

. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].

  . {link-prefix}:{link-oracle-connector}#oracle-example-configuration[Configure the connector] and {link-prefix}:{link-oracle-connector}#oracle-adding-connector-configuration[add the configuration to your Kafka Connect cluster.]
. Restart your Kafka Connect process to pick up the new JAR files.
endif::community[]

ifdef::product[]
To deploy a {prodname} Oracle connector, you add the connector files to Kafka Connect, create a custom container to run the connector, and then add connector configuration to your container.
For details about deploying the {prodname} Oracle connector, see the following topics:

* xref:obtaining-the-oracle-jdbc-driver[]
* xref:deploying-debezium-oracle-server-connectors[]
* xref:descriptions-of-debezium-oracle-connector-configuration-properties[]
endif::product[]

// Type: procedure
// Title: Obtaining the Oracle JDBC driver
// ModuleID: obtaining-the-oracle-jdbc-driver
[id="obtaining-oracle-jdbc-driver-and-xstreams-api-files"]
=== Obtaining the Oracle JDBC driver and XStream API files

The {prodname} Oracle connector requires the Oracle JDBC driver (`ojdbc8.jar`) to connect to Oracle databases.
ifdef::community[]
If the connector uses XStreams to access the database, you must also have the XStream API (`xstreams.jar`).
Licensing requirements prohibit {prodname} from including these files in the Oracle connector archive.
However, the required files are available for free download as part of the Oracle Instant Client.
The following steps describe how to download the Oracle Instant Client and extract the required files.

endif::community[]
ifdef::product[]
Due to licensing requirements, the required driver file is not included in the {prodname} Oracle connector archive.
You must download the required driver file directly from Oracle and add it to your Kafka Connect environment.
The following steps describe how to download the Oracle Instant Client and extract the driver.
endif::product[]

.Procedure

. From a browser, download the https://www.oracle.com/database/technologies/instant-client/downloads.html[Oracle Instant Client package] for your operating system.

. Extract the archive and then open the `instantclient___<version>__` directory.
+
For example:
+
[source]
----
instantclient_21_1/
├── adrci
├── BASIC_LITE_LICENSE
├── BASIC_LITE_README
├── genezi
├── libclntshcore.so -> libclntshcore.so.21.1
├── libclntshcore.so.12.1 -> libclntshcore.so.21.1

...

├── ojdbc8.jar
├── ucp.jar
├── uidrvci
└── xstreams.jar

----


ifdef::community[]
. Copy the `ojdbc8.jar` and `xstreams.jar` files, and add them to the `_<kafka_home>_/libs` directory, for example, `kafka/libs`.
+
[NOTE]
====
In environments that use the Oracle LogMiner implementation, copy only the `ojdbc8.jar` file.
The `xstreams.jar` file is only required in environments that use the Oracle XStreams implementation.
====
. If you are using the XStreams implementation, create an environment variable, `LD_LIBRARY_PATH`, and set its value to the path to the Instant Client directory, for example:
+
[source,bash,indent=0]
----
LD_LIBRARY_PATH=/path/to/instant_client/
----
+
The `LD_LIBRARY_PATH` environment variable is not required if you run the Oracle LogMiner implementation.
endif::community[]
ifdef::product[]
 Copy the `ojdbc8.jar` file to the `_<kafka_home>_/libs` directory.

// Type: procedure
// ModuleID: deploying-debezium-oracle-server-connectors
=== Deploying {prodname} Oracle connectors

To deploy a {prodname} Oracle connector, you must build a custom Kafka Connect container image that contains the {prodname} connector archive, and then push this container image to a container registry.
You then need to create the following custom resources (CRs):

* A `KafkaConnect` CR that defines your Kafka Connect instance.
  The `image` property in the CR specifies the name of the container image that you create to run your {prodname} connector.
  You apply this CR to the OpenShift instance where link:https://access.redhat.com/products/red-hat-amq#streams[Red Hat {StreamsName}] is deployed.
  {StreamsName} offers operators and images that bring Apache Kafka to OpenShift.

* A `KafkaConnector` CR that defines your {prodname} Oracle connector.
  Apply this CR to the same OpenShift instance where you apply the `KafkaConnect` CR.

  .Prerequisites

* Oracle Database is running and you completed the steps to {LinkDebeziumUserGuide}#setting-up-oracle-for-use-with-the-debezium-oracle-connector[set up Oracle to work with a {prodname} connector].

* {StreamsName} is deployed on OpenShift and is running Apache Kafka and Kafka Connect.
  For more information, see link:{LinkDeployStreamsOpenShift}[{NameDeployStreamsOpenShift}]

* Podman or Docker is installed.

* You have an account and permissions to create and manage containers in the container registry (such as `quay.io` or `docker.io`) to which you plan to add the container that will run your {prodname} connector.

* You have a copy of the Oracle JDBC driver.
Due to licensing requirements, the {prodname} Oracle connector does not include the required JDBC driver files.
+
For more information, see {link-prefix}:{link-oracle-connector}#obtaining-the-oracle-jdbc-driver[Obtaining the Oracle JDBC driver].

.Procedure

. Create the {prodname} Oracle container for Kafka Connect:
.. Download the {prodname} link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=red.hat.integration&downloadType=distributions[Oracle connector archive].

.. Extract the {prodname} Oracle connector archive to create a directory structure for the connector plug-in, for example:
+
[subs="+macros"]
----
./my-plugins/
├── debezium-connector-oracle
│   ├── ...
----

.. Create a Dockerfile that uses `{DockerKafkaConnect}` as the base image.
For example, from a terminal window, enter the following, replacing `my-plugins` with the name of your plug-ins directory:
+
[source,shell,subs="+attributes,+quotes"]
----
cat <<EOF >debezium-container-for-oracle.yaml // <1>
FROM {DockerKafkaConnect}
USER root:root
COPY ./_<my-plugins>_/ /opt/kafka/plugins/ // <2>
USER 1001
EOF
----
<1> You can specify any file name that you want.
<2> Replace `my-plugins` with the name of your plug-ins directory.
+
The command creates a Docker file with the name `debezium-container-for-oracle.yaml` in the current directory.

.. Build the container image from the `debezium-container-for-oracle.yaml` Docker file that you created in the previous step.
From the directory that contains the file, open a terminal window and enter one of the following commands:
+
[source,shell,options="nowrap"]
----
podman build -t debezium-container-for-oracle:latest .
----
+
[source,shell,options="nowrap"]
----
docker build -t debezium-container-for-oracle:latest .
----
The preceding commands build a container image with the name `debezium-container-for-oracle`.

.. Push your custom image to a container registry, such as quay.io or an internal container registry.
The container registry must be available to the OpenShift instance where you want to deploy the image.
Enter one of the following commands:
+
[source,shell,subs="+quotes"]
----
podman push _<myregistry.io>_/debezium-container-for-oracle:latest
----
+
[source,shell,subs="+quotes"]
----
docker push _<myregistry.io>_/debezium-container-for-oracle:latest
----

.. Create a new {prodname} Oracle KafkaConnect custom resource (CR).
For example, create a KafkaConnect CR with the name `dbz-connect.yaml` that specifies `annotations` and `image` properties as shown in the following example:
+
[source,yaml,subs="+attributes"]
----
apiVersion: {KafkaConnectApiVersion}
kind: KafkaConnect
metadata:
  name: my-connect-cluster
  annotations:
    strimzi.io/use-connector-resources: "true" // <1>
spec:
  #...
  image: debezium-container-for-oracle  // <2>
----
<1>  `metadata.annotations` indicates to the Cluster Operator that KafkaConnector resources are used to configure connectors in this Kafka Connect cluster.
<2>  `spec.image` specifies the name of the image that you created to run your {prodname} connector.
This property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator

.. Apply the `KafkaConnect` CR to the OpenShift Kafka Connect environment by entering the following command:
+
[source,shell,options="nowrap"]
----
oc create -f dbz-connect.yaml
----
+
The command adds a Kafka Connect instance that specifies the name of the image that you created to run your {prodname} connector.

. Create a `KafkaConnector` custom resource that configures your {prodname} Oracle connector instance.
+
You configure a {prodname} Oracle connector in a `.yaml` file that specifies the configuration properties for the connector.
The connector configuration might instruct {prodname} to produce events for a subset of the schemas and tables, or it might set properties so that {prodname} ignores, masks, or truncates values in specified columns that are sensitive, too large, or not needed.
+
The following example configures a {prodname} connector that connects to an Oracle host IP address, on port `1521`.
This host has a database named `ORCLCDB`, and `server1` is the server's logical name.
+
.Oracle `inventory-connector.yaml`
[source,yaml,subs="+attributes,+quotes",options="nowrap"]
----
apiVersion: {KafkaConnectorApiVersion}
kind: KafkaConnector
metadata:
  name: inventory-connector // <1>
  labels:
    strimzi.io/cluster: my-connect-cluster
  annotations:
    strimzi.io/use-connector-resources: 'true'
spec:
  class: io.debezium.connector.oracle.OracleConnector // <2>
  config:
    database.hostname: _<oracle_ip_address>_ // <3>
    database.port: 1521 // <4>
    database.user: c##dbzuser // <5>
    database.password: dbz // <6>
    database.dbname: ORCLCDB // <7>
    database.pdb.name : ORCLPDB1, <8>
    database.server.name: server1 // <9>
    database.history.kafka.bootstrap.servers: kafka:9092 // <10>
    database.history.kafka.topic: schema-changes.inventory // <11>
----
+
.Descriptions of connector configuration settings
[cols="1,7",options="header",subs="+attributes"]
|===
|Item |Description

|1
|The name of our connector when we register it with a Kafka Connect service.

|2
|The name of this Oracle connector class.

|3
|The address of the Oracle instance.

|4
|The port number of the Oracle instance.

|5
|The name of the Oracle user, as specified in {link-prefix}:{link-oracle-connector}#creating-users-for-the-connector[Creating users for the connector].

|6
|The password for the Oracle user, as specified in {link-prefix}:{link-oracle-connector}#creating-users-for-the-connector[Creating users for the connector].

|7
|The name of the database to capture changes from.

|8
|The name of the Oracle pluggable database that the connector captures changes from. Used in container database (CDB) installations only.

|9
|Logical name that identifies and provides a namespace for the Oracle database server from which the connector captures changes.

|10
|The list of Kafka brokers that this connector uses to write and recover DDL statements to the database history topic.

|11
|The name of the database history topic where the connector writes and recovers DDL statements. This topic is for internal use only and should not be used by consumers.

|===

. Create your connector instance with Kafka Connect.
  For example, if you saved your `KafkaConnector` resource in the `inventory-connector.yaml` file, you would run the following command:
+
[source,shell,options="nowrap"]
----
oc apply -f inventory-connector.yaml
----
+
The preceding command registers `inventory-connector` and the connector starts to run against the `server1` database as defined in the `KafkaConnector` CR.

. Verify that the connector was created and has started:
.. Display the Kafka Connect log output to verify that the connector was created and has started to capture changes in the specified database:
+
[source,shell,options="nowrap"]
----
oc logs $(oc get pods -o name -l strimzi.io/cluster=my-connect-cluster)
----

.. Review the log output to verify that {prodname} performs the initial snapshot.
The log displays output that is similar to the following messages:
+
[source,shell,options="nowrap"]
----
... INFO Starting snapshot for ...
... INFO Snapshot is using user 'c##dbzuser' ...
----
+
If the connector starts correctly without errors, it creates a topic for each table whose changes the connector is capturing.
Downstream applications can subscribe to these topics.

.. Verify that the connector created the topics by running the following command:
+
[source,shell,options="nowrap"]
----
oc get kafkatopics
----

endif::product[]

ifdef::community[]
[[oracle-example-configuration]]
=== {prodname} Oracle connector configuration

Typically, you register a {prodname} Oracle connector by submitting a JSON request that specifies the configuration properties for the connector.
The following example shows a JSON request for registering an instance of the {prodname} Oracle connector with logical name `server1` at port 1521:

You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, that are larger than a specified size, or that you do not need.

.Example: {prodname} Oracle connector configuration
[source,json,indent=0,subs="+quotes"]
----
{
    "name": "inventory-connector",  // <1>
    "config": {
        "connector.class" : "io.debezium.connector.oracle.OracleConnector",  // <2>
        "database.hostname" : "<ORACLE_IP_ADDRESS>",  // <3>
        "database.port" : "1521",  // <4>
        "database.user" : "c##dbzuser",  // <5>
        "database.password" : "dbz",   // <6>
        "database.dbname" : "ORCLCDB",  // <7>
        "database.server.name" : "server1",  // <8>
        "tasks.max" : "1",  // <9>
        "database.pdb.name" : "ORCLPDB1",  // <10>
        "database.history.kafka.bootstrap.servers" : "kafka:9092", // <11>
        "database.history.kafka.topic": "schema-changes.inventory"  // <12>
    }
}
----
<1> The name that is assigned to the connector when you register it with a Kafka Connect service.
<2> The name of this Oracle connector class.
<3> The address of the Oracle instance.
<4> The port number of the Oracle instance.
<5> The name of the Oracle user, as specified in {link-prefix}:{link-oracle-connector}#creating-users-for-the-connector[Creating users for the connector].
<6> The password for the Oracle user, as specified in {link-prefix}:{link-oracle-connector}#creating-users-for-the-connector[Creating users for the connector].
<7> The name of the database to capture changes from.
<8> Logical name that identifies and provides a namespace for the Oracle database server from which the connector captures changes.
<9> The maximum number of tasks to create for this connector.
<10> The name of the Oracle pluggable database that the connector captures changes from. Used in container database (CDB) installations only.
<11> The list of Kafka brokers that this connector uses to write and recover DDL statements to the database history topic.
<12> The name of the database history topic where the connector writes and recovers DDL statements. This topic is for internal use only and should not be used by consumers.

In the previous example, the `database.hostname` and `database.port` properties are used to define the connection to the database host.
However, in more complex Oracle deployments, or in deployments that use TNS names, you can use an alternative method in which you specify a JDBC URL.

The following JSON example shows the same configuration as in the preceding example, except that it uses a JDBC URL to connect to the database.

.Example: {prodname} Oracle connector configuration that uses a JDBC URL to connect to the database
[source,json,indent=0]
----
{
    "name": "inventory-connector",
    "config": {
        "connector.class" : "io.debezium.connector.oracle.OracleConnector",
        "tasks.max" : "1",
        "database.server.name" : "server1",
        "database.user" : "c##dbzuser",
        "database.password" : "dbz",
        "database.url": "jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS_LIST=(LOAD_BALANCE=OFF)(FAILOVER=ON)(ADDRESS=(PROTOCOL=TCP)(HOST=<oracle ip 1>)(PORT=1521))(ADDRESS=(PROTOCOL=TCP)(HOST=<oracle ip 2>)(PORT=1521)))(CONNECT_DATA=SERVICE_NAME=)(SERVER=DEDICATED)))",
        "database.dbname" : "ORCLCDB",
        "database.pdb.name" : "ORCLPDB1",
        "database.history.kafka.bootstrap.servers" : "kafka:9092",
        "database.history.kafka.topic": "schema-changes.inventory"
    }
}
----
endif::community[]

// Type: concept
// ModuleID: configuration-of-container-databases-and-non-container-databases
// Title: Configuration of container databases and non-container-databases
[[pluggable-vs-non-pluggable-databases]]
=== Pluggable vs Non-Pluggable databases
[[oracle-database-mode]]


Oracle Database supports the following deployment types:

Container database (CDB):: A database that can contain multiple pluggable databases (PDBs).
Database clients connect to each PDB as if it were a standard, non-CDB database.

Non-container database (non-CDB):: A standard Oracle database, which does not support the creation of pluggable databases.


ifdef::community[]


.Example: {prodname} connector configuration for CDB deployments
[source,json,indent=0]
----
{
  "config": {
    "connector.class" : "io.debezium.connector.oracle.OracleConnector",
    "tasks.max" : "1",
    "database.server.name" : "server1",
    "database.hostname" : "<oracle ip>",
    "database.port" : "1521",
    "database.user" : "c##dbzuser",
    "database.password" : "dbz",
    "database.dbname" : "ORCLCDB",
    "database.pdb.name" : "ORCLPDB1",
    "database.history.kafka.bootstrap.servers" : "kafka:9092",
    "database.history.kafka.topic": "schema-changes.inventory"
  }
}
----

[IMPORTANT]
====
When you configure a {prodname} Oracle connector for use with an Oracle CDB, you must specify a value for the property `database.pdb.name`, which names the PDB that you want the connector to capture changes from.
For non-CDB installation, do *not* specify the `database.pdb.name` property.
====

.Example: {prodname} Oracle connector configuration for non-CDB deployments
[source,json,indent=0]
----
{
    "config": {
        "connector.class" : "io.debezium.connector.oracle.OracleConnector",
        "tasks.max" : "1",
        "database.server.name" : "server1",
        "database.hostname" : "<oracle ip>",
        "database.port" : "1521",
        "database.user" : "c##dbzuser",
        "database.password" : "dbz",
        "database.dbname" : "ORCLCDB",
        "database.history.kafka.bootstrap.servers" : "kafka:9092",
        "database.history.kafka.topic": "schema-changes.inventory"
    }
}
----

endif::community[]

For the complete list of the configuration properties that you can set for the {prodname} Oracle connector, see {link-prefix}:{link-oracle-connector}#oracle-connector-properties[Oracle connector properties].

ifdef::community[]
You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and starts a connector task that performs the following operations:

* Connects to the Oracle database.
* Reads the redo log.
* Records change events to Kafka topics.

[[oracle-adding-connector-configuration]]
=== Adding connector configuration

To start running a {prodname} Oracle connector, create a connector configuration, and add the configuration to your Kafka Connect cluster.

.Prerequisites

* {link-prefix}:{link-oracle-connector}#setting-up-oracle[Oracle is configured for use with {prodname}].
* The {prodname} Oracle connector is installed.

.Procedure

. Create a {link-prefix}:{link-oracle-connector}#oracle-example-configuration[configuration] for the Oracle connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.
endif::community[]

.Results

When the connector starts, it {link-prefix}:{link-oracle-connector}#oracle-snapshots[performs a consistent snapshot] of the Oracle databases that the connector is configured for.
The connector then starts generating data change events for row-level operations and streaming the change event records to Kafka topics.

// Type: reference
// Title: Descriptions of {prodname} Oracle connector configuration properties
// ModuleID: descriptions-of-debezium-oracle-connector-configuration-properties
[[oracle-connector-properties]]
=== Connector properties

The {prodname} Oracle connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.
Information about the properties is organized as follows:

* xref:required-debezium-{context}-connector-configuration-properties[Required {prodname} Oracle connector configuration properties]
* xref:debezium-{context}-connector-database-history-configuration-properties[Database history connector configuration properties] that control how {prodname} processes events that it reads from the database history topic.
** xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[Pass-through database history properties]
* xref:debezium-{context}-connector-pass-through-database-driver-configuration-properties[Pass-through database driver properties] that control the behavior of the database driver.

[id="required-debezium-{context}-connector-configuration-properties"]
==== Required {prodname} Oracle connector configuration properties
The following configuration properties are _required_ unless a default value is available.

[cols="30%a,25%a,45%a"]
|===
|Property
|Default
|Description

|[[oracle-property-name]]<<oracle-property-name, `+name+`>>
|No default
|Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)

|[[oracle-property-connector-class]]<<oracle-property-connector-class, `+connector.class+`>>
|No default
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.oracle.OracleConnector` for the Oracle connector.

|[[oracle-property-tasks-max]]<<oracle-property-tasks-max, `+tasks.max+`>>
|`1`
|The maximum number of tasks that should be created for this connector. The Oracle connector always uses a single task and therefore does not use this value, so the default is always acceptable.

|[[oracle-property-database-hostname]]<<oracle-property-database-hostname, `+database.hostname+`>>
|No default
|IP address or hostname of the Oracle database server.

|[[oracle-property-database-port]]<<oracle-property-database-port, `+database.port+`>>
|No default
|Integer port number of the Oracle database server.

|[[oracle-property-database-user]]<<oracle-property-database-user, `+database.user+`>>
|No default
|Name of the Oracle user account that the connector uses to connect to the Oracle database server.

|[[oracle-property-database-password]]<<oracle-property-database-password, `+database.password+`>>
|No default
|Password to use when connecting to the Oracle database server.

|[[oracle-property-database-dbname]]<<oracle-property-database-dbname, `+database.dbname+`>>
|No default
|Name of the database to connect to. Must be the CDB name when working with the CDB + PDB model.

|[[oracle-property-database-url]]<<oracle-property-database-url, `+database.url+`>>
|No default
|Specifies the raw database JDBC URL. Use this property to provide flexibility in defining that database connection.
Valid values include raw TNS names and RAC connection strings.

|[[oracle-property-database-pdb-name]]<<oracle-property-database-pdb-name, `+database.pdb.name+`>>
|No default
|Name of the Oracle pluggable database to connect to. Use this property with container database (CDB) installations only.

|[[oracle-property-database-server-name]]<<oracle-property-database-server-name, `+database.server.name+`>>
|No default
|Logical name that identifies and provides a namespace for the Oracle database server from which the connector captures changes.
The value that you set is used as a prefix for all Kafka topic names that the connector emits.
Specify a logical name that is unique among all connectors in your {prodname} environment.
The following characters are valid: alphanumeric characters, hyphens, dots, and underscores.

|[[oracle-property-database-connection-adapter]]<<oracle-property-database-connection-adapter, `+database.connection.adapter+`>>
|`logminer`
|The adapter implementation that the connector uses when it streams database changes.
You can set the following values:

`logminer`(default):: The connector uses the native Oracle LogMiner API.
`xstream`:: The connector uses the Oracle XStreams API.

|[[oracle-property-snapshot-mode]]<<oracle-property-snapshot-mode, `+snapshot.mode+`>>
|_initial_
|Specifies the mode that the connector uses to take snapshots of a captured table.
You can set the following values:

`initial`:: The snapshot includes the structure and data of captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables.

`schema_only`:: The snapshot includes only the structure of captured tables.
Specify this value if you want the connector to capture data only for changes that occur after the snapshot.

`schema_only_recovery`:: This is a recovery setting for a connector that has already been capturing changes.
When you restart the connector, this setting enables recovery of a corrupted or lost database history topic.
You might set it periodically to "clean up" a database history topic that has been growing unexpectedly.
Database history topics require infinite retention.
Note this mode is only safe to be used when it is guaranteed that no schema changes happened since the point in time the connector was shut down before and the point in time the snapshot is taken.

After the snapshot is complete, the connector continues to read change events from the database's redo logs.

|[[oracle-property-snapshot-locking-mode]]<<oracle-property-snapshot-locking-mode, `+snapshot.locking.mode+`>>
|_shared_
a|Controls whether and for how long the connector holds a table lock. Table locks prevent certain types of changes table operations from occurring while the connector performs a snapshot.
You can set the following values:

`shared`:: Enables concurrent access to the table, but prevents any session from acquiring an exclusive table lock.
  The connector acquires a `ROW SHARE` level lock while it captures table schema.

`none`:: Prevents the connector from acquiring any table locks during the snapshot.
  Use this setting only if no schema changes might occur during the creation of the snapshot.

|[[oracle-property-snapshot-include-collection-list]]<<oracle-property-snapshot-include-collection-list, `+snapshot.include.collection.list+`>>
| All tables specified in `table.include.list`
|An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<schemaName>_._<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's `snapshot.mode` property is set to a value other than `never`. +

This property does not affect the behavior of incremental snapshots.

|[[oracle-property-snapshot-select-statement-overrides]]<<oracle-property-snapshot-select-statement-overrides, `+snapshot.select.statement.overrides+`>>
|No default
|Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.

The property contains a comma-separated list of fully-qualified table names in the form `_<schemaName>.<tableName>_`. For example, +
 +
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
 +
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
 +
`snapshot.select.statement.overrides._<schemaName>_._<tableName>_` +
 +
For example,
`snapshot.select.statement.overrides.customers.orders` +
 +
Example:

From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:

----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----

In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.

|[[oracle-property-schema-include-list]]<<oracle-property-schema-include-list, `+schema.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *want* to capture changes. Any schema name not included in `schema.include.list` is excluded from having its changes captured. By default, all non-system schemas have their changes captured. Do not also set the `schema.exclude.list` property.
In environments that use the LogMiner implementation, you must use POSIX regular expressions only.

|[[oracle-property-include-schema-comments]]<<oracle-property-include-schema-comments, `+include.schema.comments+`>>
|`false`
|Boolean value that specifies whether the connector should parse and publish table and column comments on metadata objects. Enabling this option will bring the implications on memory usage. The number and size of logical schema objects is what largely impacts how much memory is consumed by the Debezium connectors, and adding potentially large string data to each of them can potentially be quite expensive.

|[[oracle-property-schema-exclude-list]]<<oracle-property-schema-exclude-list, `+schema.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *do not* want to capture changes. Any schema whose name is not included in `schema.exclude.list` has its changes captured, with the exception of system schemas. Do not also set the `schema.include.list` property.
In environments that use the LogMiner implementation, you must use POSIX regular expressions only.

|[[oracle-property-table-include-list]]<<oracle-property-table-include-list, `+table.include.list+`>>
|No default
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be monitored.
Tables that are not included in the include list are excluded from monitoring.
Each table identifier uses the following format: +
 +
`__<schema_name>.<table_name>__` +
 +
By default, the connector monitors every non-system table in each monitored database.
Do not use this property in combination with `table.exclude.list`.
If you use the LogMiner implementation, use only POSIX regular expressions with this property.

|[[oracle-property-table-exclude-list]]<<oracle-property-table-exclude-list, `+table.exclude.list+`>>
|No default
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be excluded from monitoring.
The connector captures change events from any table that is not specified in the exclude list.
Specify the identifier for each table using the following format: +
 +
`_<schemaName>.<tableName>_`.

Do not use this property in combination with `table.include.list`.
If you use the LogMiner implementation, use only POSIX regular expressions with this property.

|[[oracle-property-column-include-list]]<<oracle-property-column-include-list, `+column.include.list+`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns that want to include in the change event message values.
Fully-qualified names for columns use the following format: `_+
 +
`<Schema_name>.<table_name>.<column_name>_` +
 +
The primary key column is always included in an event's key, even if you do not use this property to explicitly include its value.
If you include this property in the configuration, do not also set the `column.exclude.list` property.

|[[oracle-property-column-exclude-list]]<<oracle-property-column-exclude-list, `+column.exclude.list+`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns that you want to exclude from change event message values.
Fully-qualified column names use the following format: +
 +
`_<schema_name>.<table_name>.<column_name>_` +
 +
The primary key column is always included in an event's key, even if you use this property to explicitly exclude its value.
If you include this property in the configuration, do not set the `column.include.list` property.

|[[oracle-property-column-mask-hash]]<<oracle-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>;
[[oracle-property-column-mask-hash-v2]]<<oracle-property-column-mask-hash-v2, `column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form `_<schemaName>_._<tableName>_._<columnName>_`. +
 +
In the resulting change event record, the values for the specified columns are replaced with pseudonyms. +

A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
 +
In the following example, `CzQMA0cB5K` is a randomly selected salt. +

----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----

If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
 +
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked. +
 +
Hashing strategy version 2 should be used to ensure fidelity if the value is being hashed in different places or systems.

|[[oracle-property-binary-handling-mode]]<<oracle-property-binary-handling-mode, `+binary.handling.mode+`>>
|bytes
|Specifies how binary (`blob`) columns should be represented in change events, including: `bytes` represents binary data as byte array (default), `base64` represents binary data as base64-encoded String, `hex` represents binary data as hex-encoded (base16) String

|[[oracle-property-decimal-handling-mode]]<<oracle-property-decimal-handling-mode, `+decimal.handling.mode+`>>
|`precise`
| Specifies how the connector should handle floating point values for `NUMBER`, `DECIMAL` and `NUMERIC` columns.
You can set one of the following options:

`precise` (default):: Represents values precisely by using `java.math.BigDecimal` values represented in change events in a binary form.
`double`:: Represents values by using `double` values.
  Using `double` values is easier, but can result in a loss of precision.
`string`:: Encodes values as formatted strings.
  Using the `string` option is easier to consume, but results in a loss of semantic information about the real type.
  For more information, see <<oracle-decimal-types>>.

|[[oracle-property-interval-handling-mode]]<<oracle-property-interval-handling-mode, `+interval.handling.mode+`>>
|`numeric`
| Specifies how the connector should handle values for `interval` columns: +
 +
`numeric` represents intervals using approximate number of microseconds. +
 +
`string` represents intervals exactly by using the string pattern representation `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`. For example: `P1Y2M3DT4H5M6.78S`.

|[[oracle-property-event-processing-failure-handling-mode]]<<oracle-property-event-processing-failure-handling-mode, `+event.processing.failure.handling.mode+`>>
|`fail`
| Specifies how the connector should react to exceptions during processing of events.
You can set one of the following options:

`fail`:: Propagates the exception (indicating the offset of the problematic event), causing the connector to stop.
`warn`:: Causes the problematic event to be skipped. The offset of the problematic event is then logged.
`skip`:: Causes the problematic event to be skipped.

|[[oracle-property-max-queue-size]]<<oracle-property-max-queue-size, `+max.queue.size+`>>
|`8192`
|A positive integer value that specifies the maximum size of the blocking queue.
Change events read from the database log are placed in the blocking queue before they are written to Kafka.
This queue can provide backpressure to the binlog reader when, for example, writes to Kafka are slow, or if Kafka is not available.
Events that appear in the queue are not included in the offsets that the connector records periodically.
Always specify a value that is larger than the maximum batch size that specified for the `max.batch.size` property.

|[[oracle-property-max-batch-size]]<<oracle-property-max-batch-size, `+max.batch.size+`>>
|`2048`
|A positive integer value that specifies the maximum size of each batch of events to process during each iteration of this connector.

|[[oracle-property-max-queue-size-in-bytes]]<<oracle-property-max-queue-size-in-bytes, `+max.queue.size.in.bytes+`>>
|`0` (disabled)
|Long value for the maximum size in bytes of the blocking queue. To activate the feature, set the value to a positive long data type.

|[[oracle-property-poll-interval-ms]]<<oracle-property-poll-interval-ms, `+poll.interval.ms+`>>
|`1000` (1 second)
|Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear.

|[[oracle-property-tombstones-on-delete]]<<oracle-property-tombstones-on-delete, `+tombstones.on.delete+`>>
|`true`
|Controls whether a _delete_ event is followed by a tombstone event.
The following values are possible:

`true`:: For each delete operation, the connector emits a _delete_ event and a subsequent tombstone event.
`false`:: For each delete operation, the connector emits only a _delete_ event.

After a source record is deleted, a tombstone event (the default behavior) enables Kafka to completely delete all events that share the key of the deleted row in topics that have {link-kafka-docs}/#compaction[log compaction] enabled.

|[[oracle-property-message-key-columns]]<<oracle-property-message-key-columns, `+message.key.columns+`>>
|No default
|A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables.

By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns. +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
   `_<fullyQualifiedTableName>_`:``_<keyColumn>_``,``_<keyColumn>_`` +
 +
To base a table key on multiple column names, insert commas between the column names. +
Each fully-qualified table name is a regular expression in the following format: +
 +
`_<schemaName>_._<tableName>_` +
 +
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list. +
 The following example sets the message key for the tables `inventory.customers` and `purchase.orders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
For the table `inventory.customer`, the columns `pk1` and `pk2` are specified as the message key.
For the `purchaseorders` tables in any schema, the columns `pk3` and `pk4` server as the message key. +
There is no limit to the number of columns that you use to create custom message keys.
However, it's best to use the minimum number that are required to specify a unique key.

|[[oracle-property-column-truncate-to-length-chars]]<<oracle-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of character-based columns to be truncated in change event messages if their length exceeds the specified number of characters.
Length is specified as a positive integer. A configuration can include multiple properties that specify different lengths.
Specify the fully-qualified name for columns by using the following format: `_<schemaName>_._<tableName>_._<columnName>_`.

|[[oracle-property-column-mask-with-length-chars]]<<oracle-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|No default
|An optional comma-separated list of regular expressions for masking column names in change event messages by replacing characters with asterisks (`*`). +
Specify the number of characters to replace in the name of the property, for example, `column.mask.with.8.chars`. +
Specify length as a positive integer or zero.
Then add regular expressions to the list for each character-based column name where you want to apply a mask. +
Use the following format to specify fully-qualified column names: `_<schemaName>_._<tableName>_._<columnName>_`. +
 +
The connector configuration can include multiple properties that specify different lengths.

|[[oracle-property-column-propagate-source-type]]<<oracle-property-column-propagate-source-type, `+column.propagate.source.type+`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change messages.
The schema parameters `pass:[_]pass:[_]debezium.source.column.type`, `pass:[_]pass:[_]debezium.source.column.length`, and `pass:[_]pass:[_]debezium.source.column.scale` are used to propagate the original type name and length (for variable-width types), respectively.
Useful to properly size corresponding columns in sink databases. +
 +
Fully-qualified names for columns are of the form `_<tableName>_._<columnName>_`, or `_<schemaName>_._<tableName>_._<columnName>_`.

|[[oracle-property-datatype-propagate-source-type]]<<oracle-property-datatype-propagate-source-type, `+datatype.propagate.source.type+`>>
|No default
|An optional comma-separated list of regular expressions that match the database-specific data type name of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change messages.
The schema parameters `pass:[_]pass:[_]debezium.source.column.type`, `pass:[_]pass:[_]debezium.source.column.length` and `pass:[_]pass:[_]debezium.source.column.scale` are used to propagate the original type name and length (for variable-width types), respectively.
Useful to properly size corresponding columns in sink databases. +
 +
Fully-qualified data type names are of the form `_<tableName>_._<typeName>_`, or `_<schemaName>_._<tableName>_._<typeName>_`. +
See the {link-prefix}:{link-oracle-connector}#oracle-data-type-mappings[list of Oracle-specific data type names].

|[[oracle-property-heartbeat-interval-ms]]<<oracle-property-heartbeat-interval-ms, `+heartbeat.interval.ms+`>>
|`0`
|Specifies, in milliseconds, how frequently the connector sends messages to a heartbeat topic. +
Use this property to determine whether the connector continues to receive change events from the source database. +
It can also be useful to set the property in situations where the connector no change events occur in captured tables for an extended period. +
In such a a case, although the connector continues to read the redo log, it emits no change event messages, so that the offset in the Kafka topic remains unchanged.
Because the connector does not flush the latest system change number (SCN) that it read from the database, the database might retain the redo log files for longer than necessary.
If the connector restarts, the extended retention period could result in the connector redundantly sending some change events. +
The default value of `0` prevents the connector from sending any heartbeat messages.

|[[oracle-property-heartbeat-topics-prefix]]<<oracle-property-heartbeat-topics-prefix, `+heartbeat.topics.prefix+`>>
|`__debezium-heartbeat`
|Specifies the string that prefixes the name of the topic to which the connector sends heartbeat messages. +
The topic is named according to the pattern `_<heartbeat.topics.prefix>.<serverName>_`.

|[[oracle-property-snapshot-delay-ms]]<<oracle-property-snapshot-delay-ms, `+snapshot.delay.ms+`>>
|No default
|Specifies an interval in milliseconds that the connector waits after it starts before it takes a snapshot. +
Use this property to prevent snapshot interruptions when you start multiple connectors in a cluster, which might cause re-balancing of connectors.

|[[oracle-property-snapshot-fetch-size]]<<oracle-property-snapshot-fetch-size, `+snapshot.fetch.size+`>>
|`2000`
|Specifies the maximum number of rows that should be read in one go from each table while taking a snapshot.
The connector reads table contents in multiple batches of the specified size.

|[[oracle-property-sanitize-field-names]]<<oracle-property-sanitize-field-names, `+sanitize.field.names+`>>
|`true` when the connector configuration explicitly specifies the `key.converter` or `value.converter` parameters to use Avro, otherwise defaults to `false`.
|Specifies whether field names are normalized to comply with Avro naming requirements.
For more information, see {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming].

|[[oracle-property-provide-transaction-metadata]]<<oracle-property-provide-transaction-metadata, `+provide.transaction.metadata+`>>
|`false`
|Set the property to `true` if you want {prodname} to generate events with transaction boundaries and enriches data events envelope with transaction metadata.

See {link-prefix}:{link-oracle-connector}#oracle-transaction-metadata[Transaction Metadata] for additional details.

|[[oracle-property-transaction-topic]]<<oracle-property-transaction-topic, `transaction.topic`>>
|`${database.server.name}.transaction`
|Controls the name of the topic to which the connector sends transaction metadata messages. The placeholder `${database.server.name}` can be used for referring to the connector's logical name; defaults to `${database.server.name}.transaction`, for example `dbserver1.transaction`.

|[[oracle-property-log-mining-strategy]]<<oracle-property-log-mining-strategy, `+log.mining.strategy+`>>
|`redo_log_catalog`
|Specifies the mining strategy that controls how Oracle LogMiner builds and uses a given data dictionary for resolving table and column ids to names. +
 +
`redo_log_catalog`:: Writes the data dictionary to the online redo logs causing more archive logs to be generated over time.
This also enables tracking DDL changes against captured tables, so if the schema changes frequently this is the ideal choice. +
 +
`online_catalog`:: Uses the database's current data dictionary to resolve object ids and does not write any extra information to the online redo logs.
This allows LogMiner to mine substantially faster but at the expense that DDL changes cannot be tracked.
If the captured table(s) schema changes infrequently or never, this is the ideal choice.

|[[oracle-property-log-mining-buffer-type]]<<oracle-property-log-mining-buffer-type, `+log.mining.buffer.type+`>>
|`memory`
|The buffer type controls how the connector manages buffering transaction data. +
 +
`memory` - Uses the JVM process' heap to buffer all transaction data.
Choose this option if you don't expect the connector to process a high number of long-running or large transactions.
When this option is active, the buffer state is not persisted across restarts.
Following a restart, recreate the buffer from the SCN value of the current offset. +
ifdef::community[]
 +
`infinispan` - This option uses an embedded Infinispan cache to buffer transaction data and persist it to disk.
Choose this option if you expect the connector to process long-running or large transactions.
When this option is active, the buffer state is persisted across restarts.
After a restart, there is no need to recreate the buffer.
Since the buffer state is persisted across restarts, the buffer does not need to be recreated at restart.
The infinispan option requires that you specify a cache file directory.
Use the `log.mining.buffer.location` property to define the location for storing cache files.

|[[oracle-property-log-mining-buffer-infinispan-cache-transactions]]<<oracle-property-log-mining-buffer-infinispan-cache-transactions, `+log.mining.buffer.infinispan.cache.transactions+`>>
|No default
|The XML configuration for the Infinispan transaction cache.
For more information, see xref:oracle-event-buffering-infinispan[Infinispan event buffering].

|[[oracle-property-log-mining-buffer-infinispan-cache-events]]<<oracle-property-log-mining-buffer-infinispan-cache-events, `+log.mining.buffer.infinispan.cache.events+`>>
|No default
|The XML configuration for the Infinispan events cache.
For more information, see xref:oracle-event-buffering-infinispan[Infinispan event buffering].

|[[oracle-property-log-mining-buffer-infinispan-cache-processed-transactions]]<<oracle-property-log-mining-buffer-infinispan-cache-processed-transactions, `+log.mining.buffer.infinispan.cache.processed_transactions+`>>
|No default
|The XML configuration for the Infinispan processed transactions cache.
For more information, see xref:oracle-event-buffering-infinispan[Infinispan event buffering].

|[[oracle-property-log-mining-buffer-infinispan-cache-schema-changes]]<<oracle-property-log-mining-buffer-infinispan-cache-schema-changes, `+log.mining.buffer.infinispan.cache.schema_changes+`>>
|No default
|The XML configuration for the Infinispan schema changes cache.

|[[oracle-property-log-mining-buffer-drop-on-stop]]<<oracle-property-log-mining-buffer-drop-on-stop, `+log.mining.buffer.drop.on.stop+`>>
|`false`
|Specifies whether the buffer state is deleted after the connector stops in a graceful, expected way. +
 +
This setting only impacts buffer implementations that persist state across restarts, such as `infinispan`. +
The default behavior is that the buffer state is always retained between restarts. +
 +
Set to `true` only in testing or development environments.
endif::community[]

|[[oracle-property-log-mining-batch-size-min]]<<oracle-property-log-mining-batch-size-min, `+log.mining.batch.size.min+`>>
|`1000`
|The minimum SCN interval size that this connector attempts to read from redo/archive logs. Active batch size is also increased/decreased by this amount for tuning connector throughput when needed.

|[[oracle-property-log-mining-batch-size-max]]<<oracle-property-log-mining-batch-size-max, `+log.mining.batch.size.max+`>>
|`100000`
|The maximum SCN interval size that this connector uses when reading from redo/archive logs.

|[[oracle-property-log-mining-batch-size-default]]<<oracle-property-log-mining-batch-size-default, `+log.mining.batch.size.default+`>>
|`20000`
|The starting SCN interval size that the connector uses for reading data from redo/archive logs.

|[[oracle-property-log-mining-sleep-time-min-ms]]<<oracle-property-log-mining-sleep-time-min-ms, `+log.mining.sleep.time.min.ms+`>>
|`0`
|The minimum amount of time that the connector sleeps after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.

|[[oracle-property-log-mining-sleep-time-max-ms]]<<oracle-property-log-mining-sleep-time-max-ms, `+log.mining.sleep.time.max.ms+`>>
|`3000`
|The maximum amount of time that the connector ill sleeps after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.

|[[oracle-property-log-mining-sleep-time-default-ms]]<<oracle-property-log-mining-sleep-time-default-ms, `+log.mining.sleep.time.default.ms+`>>
|`1000`
|The starting amount of time that the connector sleeps after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.

|[[oracle-property-log-mining-sleep-time-increment-ms]]<<oracle-property-log-mining-sleep-time-increment-ms, `+log.mining.sleep.time.increment.ms+`>>
|`200`
|The maximum amount of time up or down that the connector uses to tune the optimal sleep time when reading data from logminer. Value is in milliseconds.

|[[oracle-property-log-mining-view-fetch-size]]<<oracle-property-log-mining-view-fetch-size, `+log.mining.view.fetch.size+`>>
|`10000`
|The number of content records that the connector fetches from the LogMiner content view.

|[[oracle-property-log-mining-archive-log-hours]]<<oracle-property-log-mining-archive-log-hours, `+log.mining.archive.log.hours+`>>
|`0`
|The number of hours in the past from SYSDATE to mine archive logs.
When the default setting (`0`) is used, the connector mines all archive logs.

|[[oracle-property-log-mining-archive-log-only-mode]]<<oracle-property-log-mining-archive-log-only-mode, `+log.mining.archive.log.only.mode+`>>
|`false`
|Controls whether or not the connector mines changes from just archive logs or a combination of the online redo logs and archive logs (the default). +
 +
Redo logs use a circular buffer that can be archived at any point.
In environments where online redo logs are archived frequently, this can lead to LogMiner session failures.
In contrast to redo logs, archive logs are guaranteed to be reliable.
Set this option to `true` to force the connector to mine archive logs only.
After you set the connector to mine only the archive logs, the latency between an operation being committed and the connector emitting an associated change event might increase.
The degree of latency depends on how frequently the database is configured to archive online redo logs.

|[[oracle-property-log-mining-archive-log-only-scn-poll-interval-ms]]<<oracle-property-log-mining-archive-log-only-scn-poll-interval-ms, `+log.mining.archive.log.only.scn.poll.interval.ms+`>>
|`10000`
|The number of milliseconds the connector will sleep in between polling to determine if the starting system change number is in the archive logs.
If `log.mining.archive.log.only.mode` is not enabled, this setting is not used.

|[[oracle-property-log-mining-transaction-retention-hours]]<<oracle-property-log-mining-transaction-retention-hours, `log.mining.transaction.retention.hours`>>
|`0`
|Positive integer value that specifies the number of hours to retain long running transactions between redo log switches.
When set to `0`, transactions are retained until a commit or rollback is detected.

The LogMiner adapter maintains an in-memory buffer of all running transactions.
Because all of the DML operations that are part of a transaction are buffered until a commit or rollback is detected,
long-running transactions should be avoided in order to not overflow that buffer.
Any transaction that exceeds this configured value is discarded entirely, and the connector does not emit any messages for the operations that were part of the transaction.
ifdef::community[]
While this option allows the behavior to be configured on a case-by-case basis,
we have plans to enhance this behavior in a future release by means of adding a scalable transaction buffer, (see {link-prefix}:{jira-url}/browse/DBZ-3123[DBZ-3123]).
endif::community[]
|[[oracle-property-log-mining-archive-destination-name]]<<oracle-property-log-mining-archive-destination-name, `+log.mining.archive.destination.name+`>>
|No default
|Specifies the configured Oracle archive destination to use when mining archive logs with LogMiner. +
 +
The default behavior automatically selects the first valid, local configured destination.
However, you can use a specific destination can be used by providing the destination name, for example, `LOG_ARCHIVE_DEST_5`.

|[[oracle-property-log-mining-username-exclude-list]]<<oracle-property-log-mining-username-exclude-list, `+log.mining.username.exclude.list+`>>
|No default
|List of database users to exclude from the LogMiner query.
It can be useful to set this property if you want the capturing process to always exclude the changes that specific users make.

|[[oracle-property-log-mining-scn-gap-detection-gap-size-min]]<<oracle-property-log-mining-scn-gap-detection-gap-size-min, `+log.mining.scn.gap.detection.gap.size.min+`>>
|`1000000`
|Specifies a value that the connector compares to the difference between the current and previous SCN values to determine whether an SCN gap exists.
If the difference between the SCN values  is greater than the specified value, and the time difference is smaller than xref:oracle-property-log-mining-scn-gap-detection-time-interval-max-ms[`log.mining.scn.gap.detection.time.interval.max.ms`] then an SCN gap is detected, and the connector uses a mining window larger than the configured maximum batch.

|[[oracle-property-log-mining-scn-gap-detection-time-interval-max-ms]]<<oracle-property-log-mining-scn-gap-detection-time-interval-max-ms, `+log.mining.scn.gap.detection.time.interval.max.ms+`>>
|`20000`
|Specifies a value,  in milliseconds, that the connector compares to the difference between the current and previous SCN timestamps  to determine whether an SCN gap exists.
If the difference between the timestamps is less than the specified value, and the SCN delta is greater than xref:oracle-property-log-mining-scn-gap-detection-gap-size-min[`log.mining.scn.gap.detection.gap.size.min`], then an SCN gap is detected and the connector uses a mining window larger than the configured maximum batch.

|[[oracle-property-lob-enabled]]<<oracle-property-lob-enabled, `+lob.enabled+`>>
|`false`
|Controls whether or not large object (CLOB or BLOB) column values are emitted in change events. +
 +
By default, change events have large object columns, but the columns contain no values.
There is a certain amount of overhead in processing and managing large object column types and payloads.
To capture large object values and serialized them in change events, set this option to `true`.

|[[oracle-property-unavailable-value-placeholder]]<<oracle-property-unavailable-value-placeholder, `+unavailable.value.placeholder+`>>
|`__debezium_unavailable_value`
|Specifies the constant that the connector provides to indicate that the original value is unchanged and not provided by the database.

|[[oracle-property-rac-nodes]]<<oracle-property-rac-nodes, `+rac.nodes+`>>
|No default
|A comma-separated list of Oracle Real Application Clusters (RAC) node host names or addresses.
This field is required to enable Oracle RAC support.
Specify the list of RAC nodes by using one of the following methods:

* Specify a value for xref:oracle-property-database-port[`database.port`], and use the specified port value for each address in the `rac.nodes` list.
For example:
+
[source,properties]
----
database.port=1521
rac.nodes=192.168.1.100,192.168.1.101
----

* Specify a value for xref:oracle-property-database-port[`database.port`], and override the default port for one or more entries in the list.
The list can include entries that use the default `database.port` value, and entries that define their own unique port values.
For example:
+
[source,properties]
----
database.port=1521
rac.nodes=192.168.1.100,192.168.1.101:1522
----

If you supply a raw JDBC URL for the database by using the xref:oracle-property-database-url[`database.url`] property, instead of defining a value for `database.port`, each RAC node entry must explicitly specify a port value.

|[[oracle-property-skipped-operations]]<<oracle-property-skipped-operations, `+skipped.operations+`>>
|No default
|A comma-separated list of the operation types that you want the connector to skip during streaming.
You can configure the connector to skip the following types of operations:

* `c` (insert/create)
* `u` (update)
* `d` (delete)
* `t` (truncate)

By default, no operations are skipped.

|[[oracle-property-signal-data-collection]]<<oracle-property-signal-data-collection,`+signal.data.collection+`>>
|No default value
a|Fully-qualified name of the data collection that is used to send {link-prefix}:{link-signalling}#debezium-signaling-enabling-signaling[signals] to the connector. +
Use the following format to specify the collection name: +
`_<databaseName>_._<schemaName>_._<tableName>_`

|[[oracle-property-incremental-snapshot-chunk-size]]<<oracle-property-incremental-snapshot-chunk-size, `+incremental.snapshot.chunk.size+`>>
|`1024`
|The maximum number of rows that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.

|===

[id="debezium-{context}-connector-database-history-configuration-properties"]
==== {prodname} connector database history configuration properties

include::{partialsdir}/modules/all-connectors/ref-connector-configuration-database-history-properties.adoc[leveloffset=+1]

[id="debezium-{context}-connector-pass-through-database-driver-configuration-properties"]
==== {prodname} connector pass-through database driver configuration properties

include::{partialsdir}/modules/all-connectors/ref-connector-pass-through-database-driver-configuration-properties.adoc[leveloffset=+1]

// Type: assembly
// ModuleID: monitoring-debezium-oracle-connector-performance
// Title: Monitoring {prodname} Oracle connector performance
[[oracle-monitoring]]
== Monitoring

The {prodname} Oracle connector provides three metric types in addition to the built-in support for JMX metrics that Apache Zookeeper, Apache Kafka, and Kafka Connect have.

* {link-prefix}:{link-oracle-connector}#oracle-snapshot-metrics[snapshot metrics]; for monitoring the connector when performing snapshots
* {link-prefix}:{link-oracle-connector}#oracle-streaming-metrics[streaming metrics]; for monitoring the connector when processing change events
* {link-prefix}:{link-oracle-connector}#oracle-schema-history-metrics[schema history metrics]; for monitoring the status of the connector's schema history

Please refer to the {link-prefix}:{link-debezium-monitoring}#monitoring-debezium[monitoring documentation] for details of how to expose these metrics via JMX.

// Type: reference
// ModuleID: debezium-oracle-connector-snapshot-metrics
// Title: {prodname} Oracle connector snapshot metrics
[[oracle-snapshot-metrics]]
=== Snapshot Metrics

[[oracle-monitoring-snapshots]]

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-snapshot-metrics.adoc[leveloffset=+1]

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-incremental-snapshot-metrics.adoc[leveloffset=+1]

// Type: reference
// ModuleID: debezium-oracle-connector-streaming-metrics
// Title: {prodname} Oracle connector streaming metrics
[[oracle-streaming-metrics]]
=== Streaming Metrics

[[oracle-monitoring-streaming]]

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-streaming-metrics.adoc[leveloffset=+1]

The {prodname} Oracle connector also provides the following additional streaming metrics:

.Descriptions of additional streaming metrics
[cols="45%a,25%a,30%a"]
|===
|Attributes |Type |Description

|[[oracle-streaming-metrics-currentscn]]<<oracle-streaming-metrics-currentscn, `+CurrentScn+`>>
|`string`
|The most recent system change number that has been processed.

|[[oracle-streaming-metrics-oldest-scn]]<<oracle-streaming-metrics-oldest-scn, `+OldestScn+`>>
|`string`
|The oldest system change number in the transaction buffer.

|[[oracle-streaming-metrics-committed-scn]]<<oracle-streaming-metrics-committed-scn, `+ComittedScn+`>>
|`string`
|The last committed system change number from the transaction buffer.

|[[oracle-streaming-metrics-offset-scn]]<<oracle-streaming-metrics-offset-scn, `+OffsetScn+`>>
|`string`
|The system change number currently written to the connector's offsets.

|[[oracle-streaming-metrics-currentredologfilename]]<<oracle-streaming-metrics-currentredologfilename, `+CurrentRedoLogFileName+`>>
|`string[]`
|Array of the log files that are currently mined.

|[[oracle-streaming-metrics-minimumminedlogcount]]<<oracle-streaming-metrics-minimumminedlogcount, `+MinimumMinedLogCount+`>>
|`long`
|The minimum number of logs specified for any LogMiner session.

|[[oracle-streaming-metrics-maximumminedlogcount]]<<oracle-streaming-metrics-maximumminedlogcount, `+MaximumMinedLogCount+`>>
|`long`
|The maximum number of logs specified for any LogMiner session.

|[[oracle-streaming-metrics-redologstatus]]<<oracle-streaming-metrics-redologstatus, `+RedoLogStatus+`>>
|`string[]`
|Array of the current state for each mined logfile with the format `_filename_\|_status_`.

|[[oracle-streaming-metrics-switchcounter]]<<oracle-streaming-metrics-switchcounter, `+SwitchCounter+`>>
|`int`
|The number of times the database has performed a log switch for the last day.

|[[oracle-streaming-metrics-lastcaptureddmlcount]]<<oracle-streaming-metrics-lastcaptureddmlcount, `+LastCapturedDmlCount+`>>
|`long`
|The number of DML operations observed in the last LogMiner session query.

|[[oracle-streaming-metrics-maxcaptureddmlinbatch]]<<oracle-streaming-metrics-maxcaptureddmlinbatch, `+MaxCapturedDmlInBatch+`>>
|`long`
|The maximum number of DML operations observed while processing a single LogMiner session query.

|[[oracle-streaming-metrics-totalcaptureddmlcount]]<<oracle-streaming-metrics-totalcaptureddmlcount, `+TotalCapturedDmlCount+`>>
|`long`
|The total number of DML operations observed.

|[[oracle-streaming-metrics-fetchingquerycount]]<<oracle-streaming-metrics-fetchingquerycount, `+FetchingQueryCount+`>>
|`long`
|The total number of LogMiner session query (aka batches) performed.

|[[oracle-streaming-metrics-lastdurationoffetchqueryinmilliseconds]]<<oracle-streaming-metrics-lastdurationoffetchqueryinmilliseconds, `+LastDurationOfFetchQueryInMilliseconds+`>>
|`long`
|The duration of the last LogMiner session query's fetch in milliseconds.

|[[oracle-streaming-metrics-maxdurationoffetchqueryinmilliseconds]]<<oracle-streaming-metrics-maxdurationoffetchqueryinmilliseconds, `+MaxDurationOfFetchQueryInMilliseconds+`>>
|`long`
|The maximum duration of any LogMiner session query's fetch in milliseconds.

|[[oracle-streaming-metrics-lastbatchprocessingtimeinmilliseconds]]<<oracle-streaming-metrics-lastbatchprocessingtimeinmilliseconds, `+LastBatchProcessingTimeInMilliseconds+`>>
|`long`
|The duration for processing the last LogMiner query batch results in milliseconds.

|[[oracle-streaming-metrics-totalparsetimeinmilliseconds]]<<oracle-streaming-metrics-totalparsetimeinmilliseconds, `+TotalParseTimeInMilliseconds+`>>
|`long`
|The time in milliseconds spent parsing DML event SQL statements.

|[[oracle-streaming-metrics-lastminingsessionstarttimeinmilliseconds]]<<oracle-streaming-metrics-lastminingsessionstarttimeinmilliseconds, `+LastMiningSessionStartTimeInMilliseconds+`>>
|`long`
|The duration in milliseconds to start the last LogMiner session.

|[[oracle-streaming-metrics-maxminingsessionstarttimeinmilliseconds]]<<oracle-streaming-metrics-maxminingsessionstarttimeinmilliseconds, `+MaxMiningSessionStartTimeInMilliseconds+`>>
|`long`
|The longest duration in milliseconds to start a LogMiner session.

|[[oracle-streaming-metrics-totalminingsessionstarttimeinmilliseconds]]<<oracle-streaming-metrics-totalminingsessionstarttimeinmilliseconds, `+TotalMiningSessionStartTimeInMilliseconds+`>>
|`long`
|The total duration in milliseconds spent by the connector starting LogMiner sessions.

|[[oracle-streaming-metrics-minbatchprocessingtimeinmilliseconds]]<<oracle-streaming-metrics-minbatchprocessingtimeinmilliseconds, `+MinBatchProcessingTimeInMilliseconds+`>>
|`long`
|The minimum duration in milliseconds spent processing results from a single LogMiner session.

|[[oracle-streaming-metrics-maxbatchprocessingtimeinmilliseconds]]<<oracle-streaming-metrics-maxbatchprocessingtimeinmilliseconds, `+MaxBatchProcessingTimeInMilliseconds+`>>
|`long`
|The maximum duration in milliseconds spent processing results from a single LogMiner session.

|[[oracle-streaming-metrics-totalprocessingtimeinmilliseconds]]<<oracle-streaming-metrics-totalprocessingtimeinmilliseconds, `+TotalProcessingTimeInMilliseconds+`>>
|`long`
|The total duration in milliseconds spent processing results from LogMiner sessions.

|[[oracle-streaming-metrics-totalresultsetnexttimeinmilliseconds]]<<oracle-streaming-metrics-totalresultsetnexttimeinmilliseconds, `+TotalResultSetNextTimeInMilliseconds+`>>
|`long`
|The total duration in milliseconds spent by the JDBC driver fetching the next row to be processed from the log mining view.

|[[oracle-streaming-metrics-totalprocessedrows]]<<oracle-streaming-metrics-totalprocessedrows, `+TotalProcessedRows+`>>
|`long`
|The total number of rows processed from the log mining view across all sessions.

|[[oracle-streaming-metrics-batchsize]]<<oracle-streaming-metrics-batchsize, `+BatchSize+`>>
|`int`
|The number of entries fetched by the log mining query per database round-trip.

|[[oracle-streaming-metrics-millisecondtosleepbetweenminingquery]]<<oracle-streaming-metrics-millisecondtosleepbetweenminingquery, `+MillisecondToSleepBetweenMiningQuery+`>>
|`long`
|The number of milliseconds the connector sleeps before fetching another batch of results from the log mining view.

|[[oracle-streaming-metrics-maxbatchprocessingthroughput]]<<oracle-streaming-metrics-maxbatchprocessingthroughput, `+MaxBatchProcessingThroughput+`>>
|`long`
|The maximum number of rows/second processed from the log mining view.

|[[oracle-streaming-metrics-averagebatchprocessingthroughput]]<<oracle-streaming-metrics-averagebatchprocessingthroughput, `+AverageBatchProcessingThroughput+`>>
|`long`
|The average number of rows/second processed from the log mining.

|[[oracle-streaming-metrics-lastbatchprocessingthroughput]]<<oracle-streaming-metrics-lastbatchprocessingthroughput, `+LastBatchProcessingThroughput+`>>
|`long`
|The average number of rows/second processed from the log mining view for the last batch.

|[[oracle-streaming-metrics-networkconnectionproblemscounter]]<<oracle-streaming-metrics-networkconnectionproblemscounter, `+NetworkConnectionProblemsCounter+`>>
|`long`
|The number of connection problems detected.

|[[oracle-streaming-metrics-hourstokeeptransactioninbuffer]]<<oracle-streaming-metrics-hourstokeeptransactioninbuffer, `+HoursToKeepTransactionInBuffer+`>>
|`int`
|The number of hours that transactions are retained by the connector's in-memory buffer without being committed or rolled back before being discarded.
See <<oracle-property-log-mining-transaction-retention-hours, `log.mining.transaction.retention`>> for more details.

|[[oracle-streaming-metrics-number-of-active-transactions]]<<oracle-streaming-metrics-number-of-active-transactions, `+NumberOfActiveTransactions+`>>
|`long`
|The number of current active transactions in the transaction buffer.

|[[oracle-streaming-metrics-number-of-committed-transactions]]<<oracle-streaming-metrics-number-of-committed-transactions, `+NumberOfCommittedTransactions+`>>
|`long`
|The number of committed transactions in the transaction buffer.

|[[oracle-streaming-metrics-number-of-rolledback-transactions]]<<oracle-streaming-metrics-number-of-rolledback-transactions, `+NumberOfRolledBackTransactions+`>>
|`long`
|The number of rolled back transactions in the transaction buffer.

|[[oracle-streaming-metrics-commit-throughput]]<<oracle-streaming-metrics-commit-throughput, `+CommitThroughput+`>>
|`long`
|The average number of committed transactions per second in the transaction buffer.

|[[oracle-streaming-metrics-registered-dml-count]]<<oracle-streaming-metrics-registered-dml-count, `+RegisteredDmlCount+`>>
|`long`
|The number of registered DML operations in the transaction buffer.

|[[oracle-streaming-metrics-lag-from-source-in-milliseconds]]<<oracle-streaming-metrics-lag-from-source-in-milliseconds, `+LagFromSourceInMilliseconds+`>>
|`long`
|The time difference in milliseconds between when a change occurred in the transaction logs and when its added to the transaction buffer.

|[[oracle-streaming-metrics-max-lag-from-source-in-milliseconds]]<<oracle-streaming-metrics-max-lag-from-source-in-milliseconds, `+MaxLagFromSourceInMilliseconds+`>>
|`long`
|The maximum time difference in milliseconds between when a change occurred in the transaction logs and when its added to the transaction buffer.

|[[oracle-streaming-metrics-min-lag-from-source-in-milliseconds]]<<oracle-streaming-metrics-min-lag-from-source-in-milliseconds, `+MinLagFromSourceInMilliseconds+`>>
|`long`
|The minimum time difference in milliseconds between when a change occurred in the transaction logs and when its added to the transaction buffer.

|[[oracle-streaming-metrics-abandoned-transaction-ids]]<<oracle-streaming-metrics-abandoned-transaction-ids, `+AbandonedTransactionIds+`>>
|`string[]`
|An array of abandoned transaction identifiers removed from the transaction buffer due to their age.
See <<oracle-property-log-mining-transaction-retention-hours, `log.mining.transaction.retention.hours`>> for details.

|[[oracle-streaming-metrics-rolled-back-transaction-ids]]<<oracle-streaming-metrics-rolled-back-transaction-ids, `+RolledBackTransactionIds+`>>
|`string[]`
|An array of transaction identifiers that have been mined and rolled back in the transaction buffer.

|[[oracle-streaming-metrics-last-commit-duration-in-milliseconds]]<<oracle-streaming-metrics-last-commit-duration-in-milliseconds, `+LastCommitDurationInMilliseconds+`>>
|`long`
|The duration of the last transaction buffer commit operation in milliseconds.

|[[oracle-streaming-metrics-max-commit-duration-in-milliseconds]]<<oracle-streaming-metrics-max-commit-duration-in-milliseconds, `+MaxCommitDurationInMilliseconds+`>>
|`long`
|The duration of the longest transaction buffer commit operation in milliseconds.

|[[oracle-streaming-metrics-error-count]]<<oracle-streaming-metrics-error-count, `+ErrorCount+`>>
|`int`
|The number of errors detected.

|[[oracle-streaming-metrics-warning-count]]<<oracle-streaming-metrics-warning-count, `+WarningCount+`>>
|`int`
|The number of warnings detected.

|[[oracle-streaming-metrics-scn-freeze-count]]<<oracle-streaming-metrics-scn-freeze-count, `+ScnFreezeCount+`>>
|`int`
|The number of times the system change number has been checked for advancement and remains unchanged.
This is an indicator that long-running transaction(s) are ongoing and preventing the connector from flushing the latest processed system change number to the connector's offsets.
Under optimal operations, this should always be or remain close to `0`.

|[[oracle-streaming-metrics-unparsable-ddl-count]]<<oracle-streaming-metrics-unparsable-ddl-count, `+UnparsableDdlCount+`>>
|`int`
|The number of DDL records that have been detected but could not be parsed by the DDL parser.
This should always be `0`; however when allowing unparsable DDL to be skipped, this metric can be used to determine if any warnings have been written to the connector logs.

|[[oracle-streaming-metrics-mining-session-user-global-area-memory-in-bytes]]<<oracle-streaming-metrics-mining-session-user-global-area-memory-in-bytes, `+MiningSessionUserGlobalAreaMemoryInBytes+`>>
|`long`
|The current mining session's user global area (UGA) memory consumption in bytes.

|[[oracle-streaming-metrics-mining-session-user-global-area-max-memory-in-bytes]]<<oracle-streaming-metrics-mining-session-user-global-area-max-memory-in-bytes, `+MiningSessionUserGlobalAreaMaxMemoryInBytes+`>>
|`long`
|The maximum mining session's user global area (UGA) memory consumption in bytes across all mining sessions.

|[[oracle-streaming-metrics-mining-session-process-global-area-memory-in-bytes]]<<oracle-streaming-metrics-mining-session-process-global-area-memory-in-bytes, `+MiningSessionProcessGlobalAreaMemoryInBytes+`>>
|`long`
|The current mining session's process global area (PGA) memory consumption in bytes.

|[[oracle-streaming-metrics-mining-session-process-global-area-max-memory-in-bytes]]<<oracle-streaming-metrics-mining-session-process-global-area-max-memory-in-bytes, `+MiningSessionProcessGlobalAreaMaxMemoryInBytes+`>>
|`long`
|The maximum mining session's process global area (PGA) memory consumption in bytes across all mining sessions.

|===

// Type: reference
// ModuleID: debezium-oracle-connector-schema-history-metrics
// Title: {prodname} Oracle connector schema history metrics
[[oracle-schema-history-metrics]]
=== Schema History Metrics

[[oracle-monitoring-schema-history]]

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-schema-history-metrics.adoc[leveloffset=+1]

ifdef::community[]
[[surrogate-schema-evolution]]
== Surrogate schema evolution

The Oracle connector automatically tracks and applies table schema changes by parsing DDL from the redo logs.
If the DDL parser encounters an incompatible statement, if needed, the connector provides an alternative way to apply the schema change.

By default, the connector stops when it encounters a DDL statement that it cannot parse.
You can use {prodname} link:/documentation/reference/configuration/signalling[signaling] to trigger the update of the database schema from such DDL statements.

The type of the schema update action is `schema-changes`.
This action updates the schema of all tables enumerated in the signal parameters.
The message does not contain the update to the schema.
Instead, it contains the complete new schema structure.

.Action parameters
[cols="3,9",options="header"]
|===
|Name | Description

|`database`
|The name of the Oracle database.

|`schema`
|The name of the schema where changes are applied.

|`changes`
|An array containing the requested schema updates.

|`changes.type`
|Type of the schema change, usually `ALTER`

|`changes.id`
|The fully-qualified name of the table

|`changes.table`
|The fully-qualified name of the table

|`changes.table.defaultCharsetName`
|The character set name used for the table if different from database default

|`changes.table.primaryKeyColumnNames`
|Array with the name of columns composing the primary key

|`changes.table.columns`
|Array with the column metadata

|`...columns.name`
|The name of the column

|`...columns.jdbcType`
|The JDBC type of the column as defined at link:https://docs.oracle.com/javase/8/docs/api/java/sql/Types.html[JDBC API]

|`...columns.typeName`
|The name of the column type

|`...columns.typeExpression`
|The full column type definition

|`...columns.charsetName`
|The column character set if different from the default

|`...columns.length`
|The length/size constraint of the column

|`...columns.scale`
|The scale of numeric column

|`...columns.position`
|The position of the column in the table starting with `1`

|`...columns.optional`
|Boolean `true` if column value is not mandatory

|`...columns.autoIncremented`
|Boolean `true` if column value is automatically calculated from a sequence

|`...columns.generated`
|Boolean `true` if column value is automatically calculated

|===

After the `schema-changes` signal is inserted, the connector must be restarted with an altered configuration that includes specifying the  <<{context}-property-database-history-skip-unparseable-ddl, `+database.history.skip.unparseable.ddl+`>> option as `true`.
After the connector's commit SCN advances beyond the DDL change, to prevent unparseable DDL statements from being skipped unexpectedly, return the connector configuration to its previous state.

.Example of a logging record
[cols="1,9a",options="header"]
|===
|Column | Value

|id
|`924e3ff8-2245-43ca-ba77-2af9af02fa07`

|type
|`schema-changes`

|data
|[source,json,indent=0,subs="attributes"]
----
{
   "database":"ORCLPDB1",
   "schema":"DEBEZIUM",
   "changes":[
      {
         "type":"ALTER",
         "id":"\"ORCLPDB1\".\"DEBEZIUM\".\"CUSTOMER\"",
         "table":{
            "defaultCharsetName":null,
            "primaryKeyColumnNames":[
               "ID",
               "NAME"
            ],
            "columns":[
               {
                  "name":"ID",
                  "jdbcType":2,
                  "typeName":"NUMBER",
                  "typeExpression":"NUMBER",
                  "charsetName":null,
                  "length":9,
                  "scale":0,
                  "position":1,
                  "optional":false,
                  "autoIncremented":false,
                  "generated":false
               },
               {
                  "name":"NAME",
                  "jdbcType":12,
                  "typeName":"VARCHAR2",
                  "typeExpression":"VARCHAR2",
                  "charsetName":null,
                  "length":1000,
                  "position":2,
                  "optional":true,
                  "autoIncremented":false,
                  "generated":false
               },
               {
                  "name":"SCORE",
                  "jdbcType":2,
                  "typeName":"NUMBER",
                  "typeExpression":"NUMBER",
                  "charsetName":null,
                  "length":6,
                  "scale":2,
                  "position":3,
                  "optional":true,
                  "autoIncremented":false,
                  "generated":false
               },
               {
                  "name":"REGISTERED",
                  "jdbcType":93,
                  "typeName":"TIMESTAMP(6)",
                  "typeExpression":"TIMESTAMP(6)",
                  "charsetName":null,
                  "length":6,
                  "position":4,
                  "optional":true,
                  "autoIncremented":false,
                  "generated":false
               }
            ]
         }
      }
   ]
}
----

|===

[[oracle-xstreams-support]]
== XStreams support

The {prodname} Oracle connector by default ingests changes using native Oracle LogMiner.
The connector can be toggled to use Oracle XStream instead.
To configure the connector to use Oracle XStream, you must apply specific database and connector configurations that differ from those that you use with LogMiner.

.Prerequisites

* To use the XStream API, you must have a license for the GoldenGate product.
Installing GoldenGate is not required.

=== Preparing the Database

.Configuration needed for Oracle XStream
[source,indent=0]
----
ORACLE_SID=ORCLCDB dbz_oracle sqlplus /nolog

CONNECT sys/top_secret AS SYSDBA
alter system set db_recovery_file_dest_size = 5G;
alter system set db_recovery_file_dest = '/opt/oracle/oradata/recovery_area' scope=spfile;
alter system set enable_goldengate_replication=true;
shutdown immediate
startup mount
alter database archivelog;
alter database open;
-- Should show "Database log mode: Archive Mode"
archive log list

exit;
----

In addition, supplemental logging must be enabled for captured tables or the database in order for data changes to capture the _before_ state of changed database rows.
The following illustrates how to configure this on a specific table, which is the ideal choice to minimize the amount of information captured in the Oracle redo logs.

[source,indent=0]
----
ALTER TABLE inventory.customers ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
----

=== Creating XStream users for the connector

The {prodname} Oracle connector requires that users accounts be set up with specific permissions so that the connector can capture change events.
The following briefly describes these user configurations using a multi-tenant database model.


[[oracle-create-users-xstream]]
.Creating an XStream Administrator user
[source,indent=0]
----
sqlplus sys/top_secret@//localhost:1521/ORCLCDB as sysdba
  CREATE TABLESPACE xstream_adm_tbs DATAFILE '/opt/oracle/oradata/ORCLCDB/xstream_adm_tbs.dbf'
    SIZE 25M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED;
  exit;

sqlplus sys/top_secret@//localhost:1521/ORCLPDB1 as sysdba
  CREATE TABLESPACE xstream_adm_tbs DATAFILE '/opt/oracle/oradata/ORCLCDB/ORCLPDB1/xstream_adm_tbs.dbf'
    SIZE 25M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED;
  exit;

sqlplus sys/top_secret@//localhost:1521/ORCLCDB as sysdba
  CREATE USER c##dbzadmin IDENTIFIED BY dbz
    DEFAULT TABLESPACE xstream_adm_tbs
    QUOTA UNLIMITED ON xstream_adm_tbs
    CONTAINER=ALL;

  GRANT CREATE SESSION, SET CONTAINER TO c##dbzadmin CONTAINER=ALL;

  BEGIN
     DBMS_XSTREAM_AUTH.GRANT_ADMIN_PRIVILEGE(
        grantee                 => 'c##dbzadmin',
        privilege_type          => 'CAPTURE',
        grant_select_privileges => TRUE,
        container               => 'ALL'
     );
  END;
  /

  exit;
----

.Creating the connector's XStream user
[source,indent=0]
----
sqlplus sys/top_secret@//localhost:1521/ORCLCDB as sysdba
  CREATE TABLESPACE xstream_tbs DATAFILE '/opt/oracle/oradata/ORCLCDB/xstream_tbs.dbf'
    SIZE 25M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED;
  exit;

sqlplus sys/top_secret@//localhost:1521/ORCLPDB1 as sysdba
  CREATE TABLESPACE xstream_tbs DATAFILE '/opt/oracle/oradata/ORCLCDB/ORCLPDB1/xstream_tbs.dbf'
    SIZE 25M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED;
  exit;

sqlplus sys/top_secret@//localhost:1521/ORCLCDB as sysdba
  CREATE USER c##dbzuser IDENTIFIED BY dbz
    DEFAULT TABLESPACE xstream_tbs
    QUOTA UNLIMITED ON xstream_tbs
    CONTAINER=ALL;

  GRANT CREATE SESSION TO c##dbzuser CONTAINER=ALL;
  GRANT SET CONTAINER TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT ON V_$DATABASE to c##dbzuser CONTAINER=ALL;
  GRANT FLASHBACK ANY TABLE TO c##dbzuser CONTAINER=ALL;
  GRANT SELECT_CATALOG_ROLE TO c##dbzuser CONTAINER=ALL;
  GRANT EXECUTE_CATALOG_ROLE TO c##dbzuser CONTAINER=ALL;
  exit;
----

=== Create an XStream Outbound Server

Create an https://docs.oracle.com/cd/E11882_01/server.112/e16545/xstrm_cncpt.htm#XSTRM1088[XStream Outbound server]
(given the right privileges, this might be done automatically by the connector going forward, see {jira-url}/browse/DBZ-721[DBZ-721]):

.Create an XStream Outbound Server
[source,indent=0]
----
sqlplus c##dbzadmin/dbz@//localhost:1521/ORCLCDB
DECLARE
  tables  DBMS_UTILITY.UNCL_ARRAY;
  schemas DBMS_UTILITY.UNCL_ARRAY;
BEGIN
    tables(1)  := NULL;
    schemas(1) := 'debezium';
  DBMS_XSTREAM_ADM.CREATE_OUTBOUND(
    server_name     =>  'dbzxout',
    table_names     =>  tables,
    schema_names    =>  schemas);
END;
/
exit;
----

[NOTE]
====
When setting up an XStream Outbound Server to capture changes from a pluggable database,
the `source_container_name` parameter should be provided specifying the pluggable database name.
====

.Configure the XStream user account to connect to the XStream Outbound Server
[source,indent=0]
----
sqlplus sys/top_secret@//localhost:1521/ORCLCDB as sysdba
BEGIN
  DBMS_XSTREAM_ADM.ALTER_OUTBOUND(
    server_name  => 'dbzxout',
    connect_user => 'c##dbzuser');
END;
/
exit;
----

[NOTE]
====
A single XStream Outbound server cannot be shared by multiple {prodname} Oracle connectors.
Each connector requires a unique XStream Outbound connector to be configured.
====

[[selecting-the-adapter]]
=== Configuring the XStream adapter

By default, {prodname} uses Oracle LogMiner to ingest change events from Oracle.
You can adjust the connector configuration to enable the connector to use the Oracle XStreams adapter.

The following configuration example adds the properties `database.connection.adapter` and `database.out.server.name` to enable the connector to use the XStream API implementation.

[source,json,indent=0]
----
{
    "name": "inventory-connector",
    "config": {
        "connector.class" : "io.debezium.connector.oracle.OracleConnector",
        "tasks.max" : "1",
        "database.server.name" : "server1",
        "database.hostname" : "<oracle ip>",
        "database.port" : "1521",
        "database.user" : "c##dbzuser",
        "database.password" : "dbz",
        "database.dbname" : "ORCLCDB",
        "database.pdb.name" : "ORCLPDB1",
        "database.history.kafka.bootstrap.servers" : "kafka:9092",
        "database.history.kafka.topic": "schema-changes.inventory",
        "database.connection.adapter": "xstream",
        "database.out.server.name" : "dbzxout"
    }
}
----

[[oracle-xstreams-connector-properties]]
=== XStream connector properties

The following configuration properties are _required_ when using XStreams unless a default value is available.

[cols="30%a,25%a,45%a"]
|===
|Property
|Default
|Description

|[[oracle-property-database-out-server-name]]<<oracle-property-database-out-server-name, `+database.out.server.name+`>>
|No default
|Name of the XStream outbound server configured in the database.

|===
endif::community[]

// Type: concept
// ModuleID: how-debezium-oracle-connectors-handle-faults-and-problems
// Title: How {prodname} Oracle connectors handle faults and problems
[[oracle-when-things-go-wrong]]
== Behavior when things go wrong

{prodname} is a distributed system that captures all changes in multiple upstream databases; it never misses or loses an event.
When the system is operating normally or being managed carefully then {prodname} provides _exactly once_ delivery of every change event record.

If a fault occurs, {prodname} does not lose any events.
However, while it is recovering from the fault, it might repeat some change events.
In these abnormal situations, {prodname}, like Kafka, provides _at least once_ delivery of change events.

The rest of this section describes how {prodname} handles various kinds of faults and problems.

[id="oracle-cannot-reference-overflow-table"]
=== ORA-25191 - Cannot reference overflow table of an index-organized table

Oracle might issue this error during the snapshot phase when encountering an index-organized table (IOT).
This error means that the connector has attempted to execute an operation that must be executed against the parent index-organized table that contains the specified overflow table.

To resolve this, the IOT name used in the SQL operation should be replaced with the parent index-organized table name.
To determine the parent index-organized table name, use the following SQL:

[source,sql]
----
SELECT IOT_NAME
  FROM DBA_TABLES
 WHERE OWNER='<tablespace-owner>'
   AND TABLE_NAME='<iot-table-name-that-failed>'
----

The connector's `table.include.list` or `table.exclude.list` configuration options should then be adjusted to explicitly include or exclude the appropriate tables to avoid the connector from attempting to capture changes from the child index-organized table.

[id="oracle-sys-system-change-not-emitted"]
=== LogMiner adapter does not capture changes made by SYS or SYSTEM

Oracle uses the `SYS` and `SYSTEM` accounts for lots of internal changes and therefore the connector automatically filters changes made by these users when fetching changes from LogMiner.
Never use the `SYS` or `SYSTEM` user accounts for changes to be emitted by the {prodname} Oracle connector.
