// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-db2"]
= {prodname} connector for Db2

ifdef::community[]

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]

[NOTE]
====
This connector is in an incubating state. Exact semantics, configuration options and other features may change in future revisions, based on the feedback we receive. Please let us know if you encounter any problems.
====
endif::community[]


ifdef::product[]
[IMPORTANT]
====
The {prodname} Db2 connector is a Technology Preview feature. Technology Preview features are not supported with Red Hat production service-level agreements (SLAs) and might not be functionally complete; therefore, Red Hat does not recommend implementing any Technology Preview features in production environments. This Technology Preview feature provides early access to upcoming product innovations, enabling you to test functionality and provide feedback during the development process. For more information about support scope, see link:https://access.redhat.com/support/offerings/techpreview/[Technology Preview Features Support Scope].
====
endif::product[]

{prodname}'s Db2 connector can capture row-level changes in the tables of a Db2 database. This connector is strongly inspired by the {prodname} implementation of SQL Server, which uses a SQL-based polling model that puts tables into "capture mode". When a table is in capture mode, the {prodname} Db2 connector generates and streams a change event for each row-level update to that table.

A table that is in capture mode has an associated change-data table, which Db2 creates. For each change to a table that is in capture mode, Db2 adds data about that change to the table's associated change-data table. A change-data table contains an entry for each state of a row. It also has special entries for deletions. The {prodname} Db2 connector reads change events from change-data tables and emits the events to Kafka topics.

The first time a {prodname} Db2 connector connects to a Db2 database, the connector reads a consistent snapshot of the tables for which the connector is configured to capture changes. By default, this is all non-system tables. There are connector configuration properties that let you specify which tables to put into capture mode, or which tables to exclude from capture mode.

When the snapshot is complete the connector begins emitting change events for committed updates to tables that are in capture mode. By default, change events for a particular table go to a Kafka topic that has the same name as the table. Applications and services consume change events from these topics.

The connector uses the abstract syntax notation (ASN) libraries that come as a standard part of Db2 LUW (Db2 for Linux, UNIX and Windows) and which you can add to Db2 zOS. To use ASN and hence this connector, you must have a license for the IBM InfoSphere Data Replication (IIDR) product. However, IIDR does not need to be installed.

The Db2 connector has been tested with Db2/Linux {linux-version}. It is expected that the connector would also work on Windows, AIX and zOS.

ifdef::product[]
Information and procedures for using a {prodname} Db2 connector is organized as follows:

* xref:overview-of-debezium-db2-connector[]
* xref:how-debezium-db2-connectors-work[]
* xref:descriptions-of-debezium-db2-connector-data-change-events[]
* xref:how-debezium-db2-connectors-map-data-types[]
* xref:setting-up-db2-to-run-a-debezium-connector[]
* xref:deploying-debezium-db2-connectors[]
* xref:monitoring-debezium-db2-connector-performance[]
* xref:managing-debezium-db2-connectors[]
* xref:updating-schemas-for-db2-tables-in-capture-mode-for-debezium-connectors[]

endif::product[]

// Type: concept
// Title: Overview of {prodname} Db2 connector
// ModuleID: overview-of-debezium-db2-connector
[[db2-overview]]
== Overview

The {prodname} Db2 connector is based on the link:https://www.ibm.com/support/pages/q-replication-and-sql-replication-product-documentation-pdf-format-version-101-linux-unix-and-windows[ASN Capture/Apply agents]
that enable SQL Replication in Db2. A capture agent:

* Generates change-data tables for tables that are in capture mode.
* Monitors tables in capture mode and stores change events for updates to those tables in their corresponding change-data tables.

The {prodname} connector uses a SQL interface to query change-data tables for  change events.

The database administrator must put the tables for which you want to capture changes into capture mode. For convenience and for automating testing, there are {link-prefix}:{link-db2-connector}#managing-debezium-db2-connectors[{prodname} user-defined functions (UDFs)] in C that you can compile and then use to do the following management tasks:

* Start, stop, and reinitialize the ASN agent
* Put tables into capture mode
* Create the replication (ASN) schemas and change-data tables
* Remove tables from capture mode

Alternatively, you can use Db2 control commands to accomplish these tasks.

After the tables of interest are in capture mode, the connector reads their corresponding change-data tables to obtain change events for table updates. The connector emits a change event for each row-level insert, update, and delete operation to a Kafka topic that has the same name as the changed table. This is default behavior that you can modify. Client applications read the Kafka topics that correspond to the database tables of interest and can react to each row-level change event.

Typically, the database administrator puts a table into capture mode in the middle of the life of a table. This means that the connector does not have the complete history of all changes that have been made to the table. Therefore, when the Db2 connector first connects to a particular Db2 database, it starts by performing a _consistent snapshot_ of each table that is in capture mode. After the connector completes the snapshot, the connector streams change events from the point at which the snapshot was made. In this way, the connector starts with a consistent view of the tables that are in capture mode, and does not drop any changes that were made while it was performing the snapshot.

{prodname} connectors are tolerant of failures. As the connector reads and produces change events, it records the log sequence number (LSN) of the change-data table entry. The LSN is the position of the change event in the database log. If the connector stops for any reason, including communication failures, network problems, or crashes, upon restarting it continues reading the change-data tables where it left off. This includes snapshots. That is, if the snapshot was not complete when the connector stopped, upon restart the connector begins a new snapshot.

// Type: assembly
// ModuleID: how-debezium-db2-connectors-work
// Title: How {prodname} Db2 connectors work
[[how-the-db2-connector-works]]
== How the connector works

To optimally configure and run a {prodname} Db2 connector, it is helpful to understand how the connector performs snapshots, streams change events, determines Kafka topic names, and handles schema changes.

ifdef::product[]
Details are in the following topics:

* xref:how-debezium-db2-connectors-perform-database-snapshots[]
* xref:how-debezium-db2-connectors-read-change-data-tables[]
* xref:default-names-of-kafka-topics-that-receive-db2-change-event-records[]
* xref:about-the-debezium-db2-connector-schema-change-topic[]
* xref:debezium-db2-connector-generated-events-that-represent-transaction-boundaries[]

endif::product[]

// Type: concept
// ModuleID: how-debezium-db2-connectors-perform-database-snapshots
// Title: How {prodname} Db2 connectors perform database snapshots
[[db2-snapshots]]
=== Snapshots

Db2`s replication feature is not designed to store the complete history of database changes. Consequently, when a {prodname} Db2 connector connects to a database for the first time, it takes a consistent snapshot of tables that are in capture mode and streams this state to Kafka. This establishes the baseline for table content.

By default, when a Db2 connector performs a snapshot, it does the following:

. Determines which tables are in capture mode, and thus must be included in the snapshot. By default, all non-system tables are in capture mode. Connector configuration properties, such as `table.exclude.list` and `table.include.list` let you specify which tables should be in capture mode.
. Obtains a lock on each of the tables in capture mode. This ensures that no schema changes can occur in those tables during the snapshot.
The level of the lock is determined by the `snapshot.isolation.mode` connector  configuration property.
. Reads the highest (most recent) LSN position in the server's transaction log.
. Captures the schema of all tables that are in capture mode. The connector persists this information in its internal database history topic.
. Optional, releases the locks obtained in step 2. Typically, these locks are held for only a short time.
. At the LSN position read in step 3, the connector scans the capture mode tables as well as their schemas. During the scan, the connector:
.. Confirms that the table was created before the start of the snapshot. If it was not, the snapshot skips that table. After the snapshot is complete, and the connector starts emitting change events, the connector produces change events for any tables that were created during the snapshot.
.. Produces a _read_ event for each row in each table that is in capture mode. All _read_ events contain the same LSN position, which is the LSN position that was obtained in step 3.
.. Emits each _read_ event to the Kafka topic that has the same name as the table.
. Records the successful completion of the snapshot in the connector offsets.

// Type: concept
// Title: How {prodname} Db2 connectors read change-data tables
[id="how-debezium-db2-connectors-read-change-data-tables"]
=== Change-data tables

After a complete snapshot, when a {prodname} Db2 connector starts for the first time, the connector identifies the change-data table for each source table that is in capture mode. The connector does the following for each change-data table:

. Reads change events that were created between the last stored, highest LSN and the current, highest LSN.
. Orders the change events according to the commit LSN and the change LSN for each event. This ensures that the connector emits the change events in the order in which the table changes occurred.
. Passes commit and change LSNs as offsets to Kafka Connect.
. Stores the highest LSN that the connector passed to Kafka Connect.

After a restart, the connector resumes emitting change events from the offset (commit and change LSNs) where it left off. While the connector is running and emitting change events, if you remove a table from capture mode or add a table to capture mode, the connector detects this and modifies its behavior accordingly.

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-db2-change-event-records
// Title: Default names of Kafka topics that receive {prodname} Db2 change event records
[[db2-topic-names]]
=== Topic names

By default, the Db2 connector writes change events for all insert, update, and delete operations on a single table to a single Kafka topic. The name of the Kafka topic has the following format:

_databaseName_._schemaName_._tableName_

_databaseName_:: The logical name of the connector as specified with the `database.server.name` connector configuration property.

_schemaName_:: The name of the schema in which the operation occurred.

_tableName_:: The name of the table in which the operation occurred.

For example, consider a Db2 installation with the `mydatabase` database,  which contains four tables: `PRODUCTS`, `PRODUCTS_ON_HAND`, `CUSTOMERS`, and `ORDERS` that are in the `MYSCHEMA` schema. The connector would emit events to these four Kafka topics:

* `mydatabase.MYSCHEMA.PRODUCTS`
* `mydatabase.MYSCHEMA.PRODUCTS_ON_HAND`
* `mydatabase.MYSCHEMA.CUSTOMERS`
* `mydatabase.MYSCHEMA.ORDERS`

To configure a Db2 connector to emit change events to differently-named Kafka topics, see the documentation for the {link-prefix}:{link-topic-routing}#topic-routing[topic routing transformation].

// Type: concept
// Title: About the {prodname} Db2 connector schema change topic
[id="about-the-debezium-db2-connector-schema-change-topic"]
=== Schema change topic

For a table that is in capture mode, the {prodname} Db2 connector stores the history of schema changes to that table in a database history topic. This topic reflects an internal connector state and you should not use it. If your application needs to track schema changes, there is a public schema change topic. The name of the schema change topic is the same as the logical server name specified in the connector configuration.

[WARNING]
====
The format of messages that a connector emits to its schema change topic is in an incubating state and can change without notice.
====

{prodname} emits a message to the schema change topic when:

* A new table goes into capture mode.
* A table is removed from capture mode.
* During a {link-prefix}:{link-db2-connector}#db2-schema-evolution[database schema update], there is a change in the schema for a table that is in capture mode.

A message to the schema change topic contains a logical representation of the table schema, for example:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
  ...
  },
  "payload": {
    "source": {
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "db2",
      "ts_ms": 1588252618953,
      "snapshot": "true",
      "db": "testdb",
      "schema": "DB2INST1",
      "table": "CUSTOMERS",
      "change_lsn": null,
      "commit_lsn": "00000025:00000d98:00a2",
      "event_serial_no": null
    },
    "databaseName": "TESTDB", // <1>
    "schemaName": "DB2INST1",
    "ddl": null, // <2>
    "tableChanges": [ // <3>
      {
        "type": "CREATE", // <4>
        "id": "\"DB2INST1\".\"CUSTOMERS\"", // <5>
        "table": { // <6>
          "defaultCharsetName": null,
          "primaryKeyColumnNames": [ // <7>
            "ID"
          ],
          "columns": [ // <8>
            {
              "name": "ID",
              "jdbcType": 4,
              "nativeType": null,
              "typeName": "int identity",
              "typeExpression": "int identity",
              "charsetName": null,
              "length": 10,
              "scale": 0,
              "position": 1,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "FIRST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 2,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "LAST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 3,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "EMAIL",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 4,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            }
          ]
        }
      }
    ]
  }
}
----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,3,6",options="header"]
|===
|Item |Field name |Description

|1
|`databaseName` +
`schemaName`
|Identifies the database and the schema that contain the change.

|2
|`ddl`
|Always `null` for the Db2 connector. For other connectors, this field contains the DDL responsible for the schema change. This DDL is not available to Db2 connectors.

|3
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|4
|`type`
a|Describes the kind of change. The value is one of the following:

* `CREATE` - table created
* `ALTER` - table modified
* `DROP` - table deleted

|5
|`id`
|Full identifier of the table that was created, altered, or dropped.

|6
|`table`
|Represents table metadata after the applied change.

|7
|`primaryKeyColumnNames`
|List of columns that compose the table's primary key.

|8
|`columns`
|Metadata for each column in the changed table.

|===

In messages to the schema change topic, the key is the name of the database that contains the schema change. In the following example, the `payload` field contains the key:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.db2.SchemaChangeKey"
  },
  "payload": {
    "databaseName": "TESTDB"
  }
}
----


// Type: concept
// ModuleID: debezium-db2-connector-generated-events-that-represent-transaction-boundaries
// Title: {prodname} Db2 connector-generated events that represent transaction boundaries
[[db2-transaction-metadata]]
=== Transaction metadata

{prodname} can generate events that represent transaction boundaries and that enrich change data event messages. For every transaction `BEGIN` and `END`, {prodname} generates an event that contains the following fields:

* `status` - `BEGIN` or `END`
* `id` - string representation of unique transaction identifier
* `event_count` (for `END` events) - total number of events emitted by the transaction
* `data_collections` (for `END` events) - an array of pairs of `data_collection` and `event_count` that provides the number of events emitted by changes originating from the given data collection

.Example

[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "00000025:00000d08:0025",
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "00000025:00000d08:0025",
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "testDB.dbo.tablea",
      "event_count": 1
    },
    {
      "data_collection": "testDB.dbo.tableb",
      "event_count": 1
    }
  ]
}
----

The connector emits transaction events to the `_database.server.name_.transaction` topic.

.Data change event enrichment

When transaction metadata is enabled the connector enriches the change event  `Envelope` with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

* `id` - string representation of unique transaction identifier
* `total_order` - absolute position of the event among all events generated by the transaction
* `data_collection_order` - the per-data collection position of the event among all events that were emitted by the transaction

Following is an example of a message:

[source,json,indent=0,subs="+attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "transaction": {
    "id": "00000025:00000d08:0025",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

// Type: assembly
// ModuleID: descriptions-of-debezium-db2-connector-data-change-events
// Title: Descriptions of {prodname} Db2 connector data change events
[[db2-events]]
== Data change events

The {prodname} Db2 connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { //<1>
   ...
  },
 "payload": { //<2>
   ...
 },
 "schema": { //<3>
   ...
 },
 "payload": { //<4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +
 +
Rarely, converter configuration overrides the key column with some other structure. In this case, the first schema field describes that structure.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.

|===

By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-db2-connector}#db2-topic-names[topic names].

[WARNING]
====
The {prodname} Db2 connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or \_. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or \_. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.

Also, Db2 names for databases, schemas, and tables can be case sensitive. This means that the connector could emit event records for more than one table to the same Kafka topic.
====

ifdef::product[]
Details are in the following topics:

* xref:about-keys-in-debezium-db2-change-events[]
* xref:about-values-in-debezium-db2-change-events[]

endif::product[]

// Type: concept
// ModuleID: about-keys-in-debezium-db2-change-events
// Title: About keys in {prodname} db2 change events
[[db2-change-event-keys]]
=== Change event keys

A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.

Consider the following `customers` table, which is followed by an example of a change event key for this table.

.Example table
[source,sql,indent=0]
----
CREATE TABLE customers (
 ID INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
 FIRST_NAME VARCHAR(255) NOT NULL,
 LAST_NAME VARCHAR(255) NOT NULL,
 EMAIL VARCHAR(255) NOT NULL UNIQUE
);
----

.Example change event key
Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:

[source,json,indent=0]
----
{
    "schema": {  // <1>
        "type": "struct",
        "fields": [  // <2>
            {
                "type": "int32",
                "optional": false,
                "field": "ID"
            }
        ],
        "optional": false,  // <3>
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Key"  // <4>
    },
    "payload": {  // <5>
        "ID": 1004
    }
}
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.

|4
|`mydatabase.MYSCHEMA.CUSTOMERS.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: +

* `mydatabase` is the name of the connector that generated this event. +
* `MYSCHEMA` is the database schema that contains the table that was changed. +
* `CUSTOMERS` is the table that was updated.

|5
|`payload`
|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `ID` field whose value is `1004`.

|===

////
[NOTE]
====
Although the `column.exclude.list` connector configuration property allows you to omit columns from event values, all columns in a primary or unique key are always included in the event's key.
====

[WARNING]
====
If the table does not have a primary or unique key, then the change event's key is null. The rows in a table without a primary or unique key constraint cannot be uniquely identified.
====
////

// Type: concept
// ModuleID: about-values-in-debezium-db2-change-events
// Title: About values in {prodname} Db2 change events
[[db2-change-event-values]]
=== Change event values

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample table that was used to show an example of a change event key:

.Example table
[source,sql,indent=0]
----
CREATE TABLE customers (
 ID INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
 FIRST_NAME VARCHAR(255) NOT NULL,
 LAST_NAME VARCHAR(255) NOT NULL,
 EMAIL VARCHAR(255) NOT NULL UNIQUE
);
----

The event value portion of every change event for the `customers` table specifies the same schema. The event value's payload varies according to the event type:

* <<db2-create-events,_create_ events>>
* <<db2-update-events,_update_ events>>
* <<db2-delete-events,_delete_ events>>

[[db2-create-events]]
=== _create_ events

The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {  // <1>
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "ID"
          },
          {
            "type": "string",
            "optional": false,
            "field": "FIRST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "LAST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "EMAIL"
          }
        ],
        "optional": true,
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Value",  // <2>
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "ID"
          },
          {
            "type": "string",
            "optional": false,
            "field": "FIRST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "LAST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "EMAIL"
          }
        ],
        "optional": true,
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Value",  // <2>
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": false,
            "field": "schema"
          },
          {
            "type": "string",
            "optional": false,
            "field": "table"
          },
          {
            "type": "string",
            "optional": true,
            "field": "change_lsn"
          },
          {
            "type": "string",
            "optional": true,
            "field": "commit_lsn"
          },
        ],
        "optional": false,
        "name": "io.debezium.connector.db2.Source",  // <2>
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      }
    ],
    "optional": false,
    "name": "mydatabase.MYSCHEMA.CUSTOMERS.Envelope"  // <2>
  },
  "payload": {  // <3>
    "before": null,  // <4>
    "after": {  // <5>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "john.doe@example.org"
    },
    "source": {  // <6>
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559729468470,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000758:0003",
      "commit_lsn": "00000027:00000758:0005",
    },
    "op": "c",  // <7>
    "ts_ms": 1559729471739  // <8>
  }
}
----

.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. In this example:

* `mydatabase.MYSCHEMA.CUSTOMERS.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. The connector uses this schema for all rows in the `MYSCHEMA.CUSTOMERS` table. Names of schemas for `before` and `after` fields are of the form `_logicalName_._schemaName_._tableName_.Value`, which ensures that the schema name is unique in the database. This means that when using the {link-prefix}:{link-avro-serialization}[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.

* `io.debezium.connector.db2.Source` is the schema for the payload's `source` field. This schema is specific to the Db2 connector. The connector uses it for all events that it generates.

* `mydatabase.MYSCHEMA.CUSTOMERS.Envelope` is the schema for the overall structure of the payload, where `mydatabase` is the database, `MYSCHEMA` is the schema, and `CUSTOMERS` is the table.

|3
|`payload`
|The value's actual data. This is the information that the change event is providing.

It may appear that JSON representations of events are much larger than the rows they describe. This is because a JSON representation must include the schema portion and the payload portion of the message.
However, by using the {link-prefix}:{link-avro-serialization}[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|4
|`before`
| An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content.

|5
|`after`
| An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `ID`, `FIRST_NAME`, `LAST_NAME`, and `EMAIL` columns.

|6
|`source`
a| Mandatory field that describes the source metadata for the event. The `source` structure shows Db2 information about this change, which provides traceability. It also has information you can use to compare to other events in the same topic or in other topics to know whether this event occurred before, after, or as part of the same commit as other events. The source metadata includes:

* {prodname} version
* Connector type and name
* Timestamp for when the connector read the record
* Whether the event is part of an ongoing snapshot
* Name of the database, schema, and table that contain the new row
* Change LSN
* Commit LSN (omitted if this event is part of a snapshot)

|7
|`op`
a| Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)

|8
|`ts_ms`
a| Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.

|===

[[db2-update-events]]
=== _update_ events
The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the _update_ event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": {  // <1>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "john.doe@example.org"
    },
    "after": {  // <2>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "noreply@example.org"
    },
    "source": {  // <3>
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559729995937,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000ac0:0002",
      "commit_lsn": "00000027:00000ac0:0007",
    },
    "op": "u",  // <4>
    "ts_ms": 1559729998706  // <5>
  }
}
----

.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, note that the `EMAIL` value is `john.doe@example.com`.

|2
|`after`
| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `EMAIL` value is now `noreply@example.com`.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. The `source` field structure contains the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event has different LSNs. You can use this information to compare this event to other events to know whether this event occurred before, after, or as part of the same commit as other events. The source metadata includes:

* {prodname} version
* Connector type and name
* Timestamp for when the connector read the record
* Whether the event is part of an ongoing snapshot
* Name of the database, schema, and table that contain the new row
* Change LSN
* Commit LSN (omitted if this event is part of a snapshot)

|4
|`op`
a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.

|5
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.

|===

[NOTE]
====
Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a {link-prefix}:{link-db2-connector}#db2-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row.
====

[[db2-delete-events]]
=== _delete_ events

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The event value `payload` in a _delete_ event for the sample `customers` table looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { ... },
  },
  "payload": {
    "before": {  // <1>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "noreply@example.org"
    },
    "after": null,  // <2>
    "source": {  // <3>
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559730445243,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000db0:0005",
      "commit_lsn": "00000027:00000db0:0007"
    },
    "op": "d",  // <4>
    "ts_ms": 1559730450205  // <5>
  }
}
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.

|2
|`after`
| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and LSN field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata:

* {prodname} version
* Connector type and name
* Timestamp for when the connector read the record
* Whether the event is part of an ongoing snapshot
* Name of the database, schema, and table that contain the new row
* Change LSN
* Commit LSN (omitted if this event is part of a snapshot)

|4
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.

|5
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.

|===

A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.

Db2 connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

[[db2-tombstone-events]]
When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}’s Db2 connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.

// Type: reference
// ModuleID: how-debezium-db2-connectors-map-data-types
// Title: How {prodname} Db2 connectors map data types
[[db2-data-types]]
== Data type mappings

Db2's data types are described in https://www.ibm.com/support/knowledgecenter/en/SSEPGG_11.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008483.html[Db2 SQL Data Types].

The Db2 connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. How that value is represented in the event depends on the Db2 data type of the column. This section describes these mappings.

ifdef::product[]
Details are in the following sections:

* xref:db2-basic-types[]
* xref:db2-temporal-types[]
* xref:db2-timestamp-types[]
* xref:db2-decimal-types[]

endif::product[]

[id="db2-basic-types"]
=== Basic types

The following table describes how the connector maps each of the Db2 data types to a _literal type_ and a _semantic type_ in event fields.

* _literal type_ describes how the value is represented using Kafka Connect schema types: `INT8`, `INT16`, `INT32`, `INT64`, `FLOAT32`, `FLOAT64`, `BOOLEAN`, `STRING`, `BYTES`, `ARRAY`, `MAP`, and `STRUCT`.

* _semantic type_ describes how the Kafka Connect schema captures the _meaning_ of the field using the name of the Kafka Connect schema for the field.

.Mappings for Db2 basic data types
[cols="20%a,15%a,30%a,35%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) |Notes

|`BOOLEAN`
|`BOOLEAN`
|n/a
|

|`BIGINT`
|`INT64`
|n/a
|

|`BINARY`
|`BYTES`
|n/a
|

|`BLOB`
|`BYTES`
|n/a
|

|`CHAR[(N)]`
|`STRING`
|n/a
|

|`CLOB`
|`STRING`
|n/a
|

|`DATE`
|`INT32`
|`io.debezium.time.Date`
|String representation of a timestamp without timezone information

|`DECFLOAT`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|

|`DECIMAL`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|

|`DBCLOB`
|`STRING`
|n/a
|

|`DOUBLE`
|`FLOAT64`
|n/a
|

|`INTEGER`
|`INT32`
|n/a
|

|`REAL`
|`FLOAT32`
|n/a
|

|`SMALLINT`
|`INT16`
|n/a
|

|`TIME`
|`INT32`
|`io.debezium.time.Time`
|String representation of a time without timezone information

|`TIMESTAMP`
|`INT64`
|`io.debezium.time.MicroTimestamp`
|String representation of a timestamp without timezone information

|`VARBINARY`
|`BYTES`
|n/a
|

|`VARCHAR[(N)]`
|`STRING`
|n/a
|

|`VARGRAPHIC`
|`STRING`
|n/a
|

|`XML`
|`STRING`
|`io.debezium.data.Xml`
|String representation of an XML document
|===

If present, a column's default value is propagated to the corresponding field's Kafka Connect schema. Change events contain the field's default value unless an explicit column value had been given. Consequently, there is rarely a need to obtain the default value from the schema.
ifdef::community[]
Passing the default value helps satisfy compatibility rules when {link-prefix}:{link-avro-serialization}[using Avro] as the serialization format together with the Confluent schema registry.
endif::community[]

[[db2-temporal-types]]
=== Temporal types

Other than Db2's `DATETIMEOFFSET` data type, which contains time zone information, how temporal types are mapped depends on the value of the `time.precision.mode` connector configuration property. The following sections describe these mappings:

* xref:db2-time-precision-mode-adaptive[`time.precision.mode=adaptive`]
* xref:db2-time-precision-mode-connect[`time.precision.mode=connect`]

[[db2-time-precision-mode-adaptive]]
.`time.precision.mode=adaptive`
When the `time.precision.mode` configuration property is set to `adaptive`, the default, the connector determines the literal type and semantic type based on the column's data type definition. This ensures that events _exactly_ represent the values in the database.

.Mappings when `time.precision.mode` is `adaptive`
[cols="20%a,15%a,30%a,35%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) |Notes

|`DATE`
|`INT32`
|`io.debezium.time.Date`
|Represents the number of days since the epoch.

|`TIME(0)`, `TIME(1)`, `TIME(2)`, `TIME(3)`
|`INT32`
|`io.debezium.time.Time`
|Represents the number of milliseconds past midnight, and does not include timezone information.

|`TIME(4)`, `TIME(5)`, `TIME(6)`
|`INT64`
|`io.debezium.time.MicroTime`
|Represents the number of microseconds past midnight, and does not include timezone information.

|`TIME(7)`
|`INT64`
|`io.debezium.time.NanoTime`
|Represents the number of nanoseconds past midnight, and does not include timezone information.

|`DATETIME`
|`INT64`
|`io.debezium.time.Timestamp`
|Represents the number of milliseconds since the epoch, and does not include timezone information.

|`SMALLDATETIME`
|`INT64`
|`io.debezium.time.Timestamp`
|Represents the number of milliseconds since the epoch, and does not include timezone information.

|`DATETIME2(0)`, `DATETIME2(1)`, `DATETIME2(2)`, `DATETIME2(3)`
|`INT64`
|`io.debezium.time.Timestamp`
|Represents the number of milliseconds since the epoch, and does not include timezone information.

|`DATETIME2(4)`, `DATETIME2(5)`, `DATETIME2(6)`
|`INT64`
|`io.debezium.time.MicroTimestamp`
|Represents the number of microseconds since the epoch, and does not include timezone information.

|`DATETIME2(7)`
|`INT64`
|`io.debezium.time.NanoTimestamp`
|Represents the number of nanoseconds past the epoch, and does not include timezone information.
|===

[[db2-time-precision-mode-connect]]
.`time.precision.mode=connect`
When the `time.precision.mode` configuration property is set to `connect`, the connector uses Kafka Connect logical types. This may be useful when consumers can handle only the built-in Kafka Connect logical types and are unable to handle variable-precision time values. However, since Db2 supports tenth of a microsecond precision, the events generated by a connector with the `connect` time precision *results in a loss of precision* when the database column has a _fractional second precision_ value that is greater than 3.

.Mappings when `time.precision.mode` is `connect`
[cols="20%a,15%a,30%a,35%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) |Notes

|`DATE`
|`INT32`
|`org.apache.kafka.connect.data.Date`
| Represents the number of days since the epoch.

|`TIME([P])`
|`INT64`
|`org.apache.kafka.connect.data.Time`
| Represents the number of milliseconds since midnight, and does not include timezone information. Db2 allows `P` to be in the range 0-7 to store up to tenth of a microsecond precision, though this mode results in a loss of precision when `P` is greater than 3.

|`DATETIME`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp`
| Represents the number of milliseconds since the epoch, and does not include timezone information.

|`SMALLDATETIME`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp`
| Represents the number of milliseconds since the epoch, and does not include timezone information.

|`DATETIME2`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp`
| Represents the number of milliseconds since the epoch, and does not include timezone information. Db2 allows `P` to be in the range 0-7 to store up to tenth of a microsecond precision, though this mode results in a loss of precision when `P` is greater than 3.
|===

[[db2-timestamp-types]]
=== Timestamp types

The `DATETIME`, `SMALLDATETIME` and `DATETIME2` types represent a timestamp without time zone information.
Such columns are converted into an equivalent Kafka Connect value based on UTC. For example, the `DATETIME2` value "2018-06-20 15:13:16.945104" is represented by an `io.debezium.time.MicroTimestamp` with the value "1529507596945104".

The timezone of the JVM running Kafka Connect and {prodname} does not affect this conversion.

[[db2-decimal-types]]
=== Decimal types

[cols="15%a,15%a,35%a,35%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) |Notes

|`NUMERIC[(P[,S])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer that represents how many digits the decimal point is shifted.
The `connect.decimal.precision` schema parameter contains an integer that represents the precision of the given decimal value.

|`DECIMAL[(P[,S])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer that represents how many digits the decimal point is shifted.
The `connect.decimal.precision` schema parameter contains an integer that  represents the precision of the given decimal value.

|`SMALLMONEY`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer that represents how many digits the decimal point iss shifted.
The `connect.decimal.precision` schema parameter contains an integer that represents the precision of the given decimal value.

|`MONEY`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer that represents how many digits the decimal point is shifted.
The `connect.decimal.precision` schema parameter contains an integer that represents the precision of the given decimal value.
|===

// Type: procedure
// ModuleID: setting-up-db2-to-run-a-debezium-connector
// Title: Setting up Db2 to run a {prodname} connector
[[setting-up-db2]]
== Set up

A database administrator must put tables into capture mode before you can run a {prodname} Db2 connector to capture changes that are committed to a Db2 database. To put tables into capture mode, {prodname} provides a set of user-defined functions (UDFs) for your convenience. The procedure here shows how to install and run these management UDFs. Alternatively, you can run Db2 control commands to put tables into capture mode.

This procedure assumes that you are logged in as the `db2instl` user, which is the default instance and user name when using the Db2 docker container image.

.Prerequisites

* On the machine on which Db2 is running, the content in `debezium-connector-db2/src/test/docker/db2-cdc-docker` is available in the `$HOME/asncdctools/src` directory.

.Procedure

. Compile the {prodname} management UDFs on the Db2 server host by using the `bldrtn`
command provided with Db2:
+
[source,shell]
----
cd $HOME/asncdctools/src
----
+
[source,shell]
----
./bldrtn asncdc
----

. Start the database if it is not already running. Replace `DB_NAME` with the name of the database that you want {prodname} to connect to.
+
[source,shell]
----
db2 start db DB_NAME
----

. Ensure that JDBC can read the Db2 metadata catalog:
+
[source,shell]
----
cd $HOME/sqllib/bnd
----
+
[source,shell]
----
db2 bind db2schema.bnd blocking all grant public sqlerror continue
----

. Ensure that the database was recently backed-up. The ASN agents must have a recent starting point to read from. If you need to perform a backup, run the following commands, which prune the data so that only the most recent version is available. If you do not need to retain the older versions of the data, specify `dev/null` for the backup location.

.. Back up the database. Replace `DB_NAME` and `BACK_UP_LOCATION` with appropriate values:
+
[source,shell]
----
db2 backup db DB_NAME to BACK_UP_LOCATION
----

.. Restart the database:
+
[source,shell]
----
db2 restart db DB_NAME
----

. Connect to the database to install the {prodname} management UDFs. It is assumed that you are logged in as the `db2instl` user so the UDFs should be installed on the `db2inst1` user.
+
[source,shell]
----
db2 connect to DB_NAME
----

. Copy the {prodname} management UDFs and set permissions for them:
+
[source,shell]
----
cp $HOME/asncdctools/src/asncdc $HOME/sqllib/function
----
+
[source,shell]
----
chmod 777 $HOME/sqllib/function
----

. Enable the {prodname} UDF that starts and stops the ASN capture agent:
+
[source,shell]
----
db2 -tvmf $HOME/asncdctools/src/asncdc_UDF.sql
----

. Create the ASN control tables:
+
[source,shell]
----
$ db2 -tvmf $HOME/asncdctools/src/asncdctables.sql
----

. Enable the {prodname} UDF that adds tables to capture mode and removes tables from capture mode:
+
[source,shell]
----
$ db2 -tvmf $HOME/asncdctools/src/asncdcaddremove.sql
----
+
After you set up the Db2 server, use the UDFs to control Db2 replication (ASN) with SQL commands. Some of the UDFs expect a return value in which case you use the  SQL `VALUE` statement to invoke them. For other UDFs, use the SQL `CALL` statement.

. Start the ASN agent:
+
[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('start','asncdc');
----

. Put tables into capture mode. Invoke the following statement for each table that you want to put into capture. Replace `MYSCHEMA`  with the name of the schema that contains the table you want to put into capture mode. Likewise, replace `MYTABLE` with the name of the table to put into capture mode:
+
[source,sql]
----
CALL ASNCDC.ADDTABLE('MYSCHEMA', 'MYTABLE');
----

. Reinitialize the ASN service:
+
[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('reinit','asncdc');
----

.Additional resource

{link-prefix}:{link-db2-connector}#managing-debezium-db2-connectors[Reference table for {prodname} Db2 management UDFs]

// Type: assembly
// ModuleID: deploying-debezium-db2-connectors
// Title: Deploying {prodname} Db2 connectors
[[db2-deploying-a-connector]]
== Deployment

ifdef::community[]

With https://zookeeper.apache.org[Zookeeper], http://kafka.apache.org/[Kafka], and {link-kafka-docs}.html#connect[Kafka Connect] installed, the remaining tasks to deploy a {prodname} Db2 connector are:

. Download the link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-db2/{debezium-version}/debezium-connector-db2-{debezium-version}-plugin.tar.gz[connector's plug-in archive].

. Extract the JAR files into your Kafka Connect environment.
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. Obtain the link:https://www.ibm.com/support/pages/db2-jdbc-driver-versions-and-downloads[JDBC driver for Db2].
. Add the JDBC driver JAR file to the directory with the {prodname} Db2 connector JARs.
. {link-prefix}:{link-db2-connector}#db2-adding-connector-configuration[Configure the connector and add the configuration to your Kafka Connect cluster.]
. Restart your Kafka Connect process to pick up the new JAR files.

If you need immutable containers, see link:https://hub.docker.com/r/debezium/[{prodname}'s Container images] for Zookeeper, Kafka and Kafka Connect with the Db2 connector already installed and ready to run.
You can also link:/docs/openshift/[run {prodname} on OpenShift].
endif::community[]

ifdef::product[]
To deploy a {prodname} Db2 connector, install the {prodname} Db2 connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect. Details are in the following topics:

* xref:steps-for-installing-debezium-db2-connectors[]
* xref:debezium-db2-connector-configuration-example[]
* xref:adding-debezium-db2-connector-configuration-to-kafka-connect[]
* xref:descriptions-of-debezium-db2-connector-configuration-properties[]

// Type: concept
[id="steps-for-installing-debezium-db2-connectors"]
=== Steps for installing {prodname} Db2 connectors

To install the Db2 connector, follow the procedures in {LinkDebeziumInstallOpenShift}[{NameDebeziumInstallOpenShift}]. The main steps are:

. {LinkDebeziumUserGuide}#setting-up-db2-to-run-a-debezium-connector[Set up Db2 to run a {prodname} connector]. This enables Db2 replication to expose change-data for tables that are in capture mode.

. Use link:https://access.redhat.com/products/red-hat-amq#streams[Red Hat AMQ Streams] to set up Apache Kafka and Kafka Connect on OpenShift. AMQ Streams offers operators and images that bring Kafka to OpenShift.

. Download the {prodname} link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=red.hat.integration&downloadType=distributions[Db2 connector].

. Extract the files into your Kafka Connect environment.
. Add the plug-in's parent directory to your Kafka Connect `plugin.path`, for example:
+
[source]
----
plugin.path=/kafka/connect
----
+
The above example assumes that you extracted the {prodname} Db2 connector to the `/kafka/connect/{prodname}-connector-db2` path.

. Restart your Kafka Connect process to ensure that the new JAR files are picked up.

endif::product[]

// Type: concept
// ModuleID: debezium-db2-connector-configuration-example
// Title: {prodname} db2 connector configuration example
[[db2-example]]
[[db2-example-configuration]]
=== Connector configuration example

ifdef::community[]

Following is an example of the configuration for a Db2 connector that connects to a Db2 server on port 50000 at 192.168.99.100, whose logical name is `fullfillment`. Typically, you configure the {prodname} Db2 connector in a `.json` file using the configuration properties available for the connector.

You can choose to produce events for a subset of the schemas and tables. Optionally, ignore, mask, or truncate columns that are sensitive, too large, or not needed.

[source,json]
----
{
  "name": "db2-connector",  // <1>
  "config": {
    "connector.class": "io.debezium.connector.db2.Db2Connector", // <2>
    "database.hostname": "192.168.99.100", // <3>
    "database.port": "50000", // <4>
    "database.user": "db2inst1", // <5>
    "database.password": "Password!", // <6>
    "database.dbname": "mydatabase", // <7>
    "database.server.name": "fullfillment", // <8>
    "table.include.list": "MYSCHEMA.CUSTOMERS", // <9>
    "database.history.kafka.bootstrap.servers": "kafka:9092", // <10>
    "database.history.kafka.topic": "dbhistory.fullfillment" // <11>
  }
}
----
<1> The name of the connector when registered with a Kafka Connect service.
<2> The name of this Db2 connector class.
<3> The address of the Db2 instance.
<4> The port number of the Db2 instance.
<5> The name of the Db2 user.
<6> The password for the Db2 user.
<7> The name of the database to capture changes from.
<8> The logical name of the Db2 instance/cluster, which forms a namespace and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the {link-prefix}:{link-avro-serialization}[Avro Connector] is used.
<9> A list of all tables whose changes {prodname} should capture.
<10> The list of Kafka brokers that this connector uses to write and recover DDL statements to the database history topic.
<11> The name of the database history topic where the connector writes and recovers DDL statements. This topic is for internal use only and should not be used by consumers.

endif::community[]

ifdef::product[]

Following is an example of the configuration for a Db2 connector that connects to a Db2 server on port 50000 at 192.168.99.100, whose logical name is `fullfillment`. Typically, you configure a {prodname} Db2 connector in a `.yaml` file using the configuration properties available for the connector.

You can choose to produce events for a subset of the schemas and tables. Optionally, ignore, mask, or truncate columns that are sensitive, too large, or not needed.

[source,yaml,options="nowrap"]
----
apiVersion: kafka.strimzi.io/v1beta1
  kind: KafkaConnector
  metadata:
    name: inventory-connector  // <1>
    labels: strimzi.io/cluster: my-connect-cluster
  spec:
    class: io.debezium.connector.db2.Db2Connector
    tasksMax: 1  // <2>
    config:  // <3>
      database.hostname: 192.168.99.100   // <4>
      database.port: 50000
      database.user: db2inst1
      database.password: Password!
      database.dbname: mydatabase
      database.server.name: fullfillment   // <5>
      database.include.list: public.inventory   // <6>
----
<1> The name of the connector.
<2> Only one task should operate at any one time.
<3> The connector’s configuration.
<4> The database host, which is the address of the Db2 instance.
<5> The logical name of the Db2 instance/cluster, which forms a namespace and is used in the names of the Kafka topics to which the connector writes, the names of Kafka Connect schemas, and the namespaces of the corresponding Avro schema when the {link-prefix}:{link-avro-serialization}[Avro Connector] is used.
<6> Changes in only the `public.inventory` database are captured.

endif::product[]

See the {link-prefix}:{link-db2-connector}#db2-connector-properties[complete list of connector properties] that you can specify in these configurations.

You can send this configuration with a `POST` command to a running Kafka Connect service. The service records the configuration and starts one connector task that connects to the Db2 database, reads change-data tables for tables in capture mode, and streams change event records to Kafka topics.

// Type: procedure
// ModuleID: adding-debezium-db2-connector-configuration-to-kafka-connect
// Title: Adding {prodname} Db2 connector configuration to Kafka Connect
[[db2-adding-connector-configuration]]
=== Adding connector configuration

ifdef::community[]
To start running a Db2 connector, create a connector configuration file and add it to your Kafka Connect cluster.

.Prerequisites

* The {link-prefix}:{link-db2-connector}#setting-up-db2-to-run-a-debezium-connector[Db2 replication] is enabled to expose change-data for tables that are in capture mode

* The Db2 connector is installed.

.Procedure

. Create a configuration file for the Db2 connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.

endif::community[]

ifdef::product[]
You can use a provided {prodname} container to deploy a {prodname} Db2 connector. In this procedure, you build a custom Kafka Connect container image for {prodname}, configure the {prodname} connector as needed, and then add your connector configuration to your Kafka Connect environment.

.Prerequisites

* You have Podman installed and sufficient rights to create and manage containers.
* You installed the {prodname} Db2 connector archive.

.Procedure

. Extract the {prodname} Db2 connector archive to create a directory structure for the connector plug-in, for example:
+
[subs=+macros]
----
pass:quotes[*tree ./my-plugins/*]
./my-plugins/
├── debezium-connector-db2
│   ├── ...
----

. Create and publish a custom image for running your {prodname} connector:

.. Create a new `Dockerfile` by using `{DockerKafkaConnect}` as the base image. In the following example, you would replace _my-plugins_ with the name of your plug-ins directory:
+
[subs=+macros]
----
FROM registry.redhat.io/amq7/amq-streams-kafka-25:1.5.0
USER root:root
pass:quotes[COPY _./my-plugins/_ /opt/kafka/plugins/]
USER 1001
----
+
Before Kafka Connect starts running the connector, Kafka Connect loads any third-party plug-ins that are in the `/opt/kafka/plugins` directory.

.. Build the docker container image. For example, if you saved the docker file that you created in the previous step as `debezium-container-for-db2`, then you would run the following command:
+
`podman build -t debezium-container-for-db2:latest`

.. Push your custom image to your container registry, for example:
+
`podman push debezium-container-for-db2:latest`

.. Point to the new container image. Do one of the following:
+
* Edit the `spec.image` property of the `KafkaConnector` custom resource. If set, this property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator. For example:
+
[source,yaml,subs=attributes+]
----
apiVersion: {KafkaConnectApiVersion}
kind: KafkaConnector
metadata:
  name: my-connect-cluster
spec:
  #...
  image: debezium-container-for-db2
----
+
* In the `install/cluster-operator/050-Deployment-strimzi-cluster-operator.yaml` file, edit the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable to point to the new container image and reinstall the Cluster Operator. If you edit this file you must apply it to your OpenShift cluster.

. Create a `KafkaConnector` custom resource that defines your {prodname} Db2 connector instance. See {LinkDebeziumUserGuide}#debezium-db2-connector-configuration-example[the connector configuration example].

. Apply the connector instance, for example:
+
`oc apply -f inventory-connector.yaml`
+
This registers `inventory-connector` and the connector starts to run against the `inventory` database.

. Verify that the connector was created and has started to capture changes in the specified database. You can verify the connector instance by watching the Kafka Connect log output as, for example, `inventory-connector` starts.

.. Display the Kafka Connect log output:
+
[source,shell,options="nowrap"]
----
oc logs $(oc get pods -o name -l strimzi.io/name=my-connect-cluster-connect)
----

.. Review the log output to verify that the initial snapshot has been executed. You should see something like the following lines:
+
[source,shell,options="nowrap"]
----
... INFO Starting snapshot for ...
... INFO Snapshot is using user 'debezium' ...
----

endif::product[]

.Results

When the connector starts, it {link-prefix}:{link-db2-connector}#db2-snapshots[performs a consistent snapshot] of the Db2 database tables that the connector is configured to capture changes for. The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics.

// Type: reference
// ModuleID: descriptions-of-debezium-db2-connector-configuration-properties
// Title: Description of {prodname} Db2 connector configuration properties
[[db2-connector-properties]]
=== Connector properties

The {prodname} Db2 connector has numerous configuration properties that you can use to achieve the right connector behavior for your application. Many properties have default values. Information about the properties is organized as follows:

* xref:db2-required-configuration-properties[Required configuration properties]
* xref:db2-advanced-configuration-properties[Advanced configuration properties]
* xref:db2-pass-through-properties[Pass-through configuration properties]

[id="db2-required-configuration-properties"]
The following configuration properties are _required_ unless a default value is available.

.Required connector configuration properties
[cols="30%a,25%a,45%a",options="header"]
|===
|Property |Default |Description

|[[db2-property-name]]<<db2-property-name, `name`>>
|
|Unique name for the connector. Attempting to register again with the same name will fail. This property is required by all Kafka Connect connectors.

|[[db2-property-connector-class]]<<db2-property-connector-class, `connector.class`>>
|
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.db2.Db2Connector` for the Db2 connector.

|[[db2-property-tasks-max]]<<db2-property-tasks-max, `tasks.max`>>
|`1`
|The maximum number of tasks that should be created for this connector. The Db2 connector always uses a single task and therefore does not use this value, so the default is always acceptable.

|[[db2-property-database-hostname]]<<db2-property-database-hostname, `database.hostname`>>
|
|IP address or hostname of the Db2 database server.

|[[db2-property-database-port]]<<db2-property-database-port, `database.port`>>
|`50000`
|Integer port number of the Db2 database server.

|[[db2-property-database-user]]<<db2-property-database-user, `database.user`>>
|
|Name of the Db2 database user for connecting to the Db2 database server.

|[[db2-property-database-password]]<<db2-property-database-password, `database.password`>>
|
|Password to use when connecting to the Db2 database server.

|[[db2-property-database-dbname]]<<db2-property-database-dbname, `database.dbname`>>
|
|The name of the Db2 database from which to stream the changes

|[[db2-property-database-server-name]]<<db2-property-database-server-name, `database.server.name`>>
|
|Logical name that identifies and provides a namespace for the particular Db2 database server that hosts the database for which {prodname} is capturing changes. Only alphanumeric characters and underscores should be used in the database server logical name. The logical name should be unique across all other connectors, since it is used as a topic name prefix for all Kafka topics that receive records from this connector.

|[[db2-property-database-history-kafka-topic]]<<db2-property-database-history-kafka-topic, `database.history.kafka.topic`>>
|
|The full name of the Kafka topic where the connector stores the database schema history.

|[[db2-property-database-history-kafka-bootstrap-servers]]<<db2-property-database-history-kafka-bootstrap-servers, `database.history{zwsp}.kafka.bootstrap.servers`>>
|
|A list of host/port pairs that the connector uses to establish an initial connection to the Kafka cluster. This connection is used for retrieving database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the {prodname} Kafka Connect process.

|[[db2-property-table-whitelist]]
[[db2-property-table-include-list]]<<db2-property-table-include-list, `table.include.list`>>
|
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you want the connector to capture. Any table not included in the include list does not have its changes captured. Each identifier is of the form _schemaName_._tableName_. By default, the connector captures changes in every non-system table. Do not also set the `table.exclude.list` property.

|[[db2-property-table-blacklist]]
[[db2-property-table-exclude-list]]<<db2-property-table-exclude-list, `table.exclude.list`>>
|
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want the connector to capture. The connector captures changes in each non-system table that is not included in the exclude list. Each identifier is of the form _schemaName_._tableName_. Do not also set the `table.include.list` property.

|[[db2-property-column-blacklist]]
[[db2-property-column-exclude-list]]<<db2-property-column-exclude-list, `column.exclude.list`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.
Primary key columns are always included in the event's key, even if they are excluded from the value.

|[[db2-property-column-mask-hash]]<<db2-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be pseudonyms in change event values. A pseudonym is a field value that  consists of the hashed value obtained by applying the `_hashAlgorithm_` algorithm and the `_salt_` salt that you specify in the property name. +
 +
Based on the hash algorithm applied, referential integrity is kept while data is masked. Supported hash algorithms are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.
The hash value is automatically shortened to the length of the column. +
 +
You can specify multiple instances of this property with different algorthims and salts. Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. For example: +
 +
`column.mask.hash.SHA-256.with.salt.CzQMA0cB5K =` + `inventory.orders.customerName, inventory.shipment.customerName` +
 +
where `CzQMA0cB5K` is a randomly selected salt.
 +
Depending on the `_hashAlgorithm_` used, the `_salt_` selected, and the actual data set, the field value may not be completely masked.

|[[db2-property-time-precision-mode]]<<db2-property-time-precision-mode, `time.precision.mode`>>
|`adaptive`
| Time, date, and timestamps can be represented with different kinds of precision: +
 +
`adaptive` captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +
 +
`connect` always represents time and timestamp values by using Kafka Connect's built-in representations for `Time`, `Date`, and `Timestamp`, which uses millisecond precision regardless of the database columns' precision. See {link-prefix}:{link-db2-connector}#db2-temporal-values[temporal values].

|[[db2-property-tombstones-on-delete]]<<db2-property-tombstones-on-delete, `tombstones.on.delete`>>
|`true`
| Controls whether a tombstone event should be generated after a _delete_ event. +
 +
`true` - delete operations are represented by a _delete_ event and a subsequent tombstone event. +
 +
`false` - only a _delete_ event is sent. +
 +
After a _delete_ operation, emitting a tombstone event enables Kafka to delete all change event records that have the same key as the deleted row.

|[[db2-property-include-schema-changes]]<<db2-property-include-schema-changes, `include.schema.changes`>>
|`true`
|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded with a key that contains the database name and a value that is a JSON structure that describes the schema update. This is independent of how the connector internally records database history.

|[[db2-property-column-truncate-to-length-chars]]<<db2-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns. Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. In change event records, values in these columns are truncated if they are longer than the number of characters specified by _length_ in the property name. You can specify multiple properties with different lengths in a single configuration. Length must be a positive integer, for example, `column.truncate.to.20.chars`.

|[[db2-property-column-mask-with-length-chars]]<<db2-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns. Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. In change event values, the values in the specified table columns are replaced with _length_ number of asterisk (`*`) characters. You can specify multiple properties with different lengths in a single configuration. Length must be a positive integer or zero. When you specify zero, the connector replaces a value with an empty string.

|[[db2-property-column-propagate-source-type]]<<db2-property-column-propagate-source-type, `column.propagate.source.type`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_. +
 +
For each specified column, the connector adds the column's original type and original length as parameters to the corresponding field schemas in the emitted change records. The following added schema parameters propagate the original type name and also the original length for variable-width types: +
 +
`pass:[_]pass:[_]debezium.source.column.type` + `pass:[_]pass:[_]debezium.source.column.length` + `pass:[_]pass:[_]debezium.source.column.scale` +
 +
This property is useful for properly sizing corresponding columns in sink databases.

|[[db2-property-datatype-propagate-source-type]]<<db2-property-datatype-propagate-source-type, `datatype.propagate.source.type`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the database-specific data type name for some columns. Fully-qualified data type names are of the form _databaseName_._tableName_._typeName_, or _databaseName_._schemaName_._tableName_._typeName_. +
 +
For these data types, the connector adds parameters to the corresponding field schemas in emitted change records. The added parameters specify the original type and length of the column: +
 +
`pass:[_]pass:[_]debezium.source.column.type` + `pass:[_]pass:[_]debezium.source.column.length` + `pass:[_]pass:[_]debezium.source.column.scale` +
 +
These parameters propagate a column's original type name and length, for variable-width types, respectively. This property is useful for properly sizing corresponding columns in sink databases. +
 +
See {link-prefix}:{link-db2-connector}#db2-data-types[Db2 data types] for the list of Db2-specific data type names.

|[[db2-property-message-key-columns]]<<db2-property-message-key-columns, `message.key.columns`>>
|_empty string_
A semicolon separated list of tables with regular expressions that match table column names. The connector maps values in matching columns to key fields in change event records that it sends to Kafka topics. This is useful when a table does not have a primary key, or when you want to order change event records in a Kafka topic according to a field that is not a primary key. +
 +
Separate entries with semicolons. Insert a colon between the fully-qualified table name and its regular expression. The format is: +
 +
_schema-name_._table-name_:_regexp_;... +
 +
For example, +
 +
`schemaA.table_a:regex_1;schemaB.table_b:regex_2;schemaC.table_c:regex_3` +
 +
If `table_a` has a an `id` column, and `regex_1` is `^i` (matches any column that starts with `i`), the connector maps the value in ``table_a``'s `id` column to a key field in change events that the connector sends to Kafka.

|===

[id="db2-advanced-configuration-properties"]
The following _advanced_ configuration properties have defaults that work in most situations and therefore rarely need to be specified in the connector's configuration.

.Advanced connector configuration properties
[cols="30%a,25%a,45%a",options="header"]
|===
|Property |Default |Description

|[[db2-property-snapshot-mode]]<<db2-property-snapshot-mode, `snapshot.mode`>>
|`initial`
|Specifies the criteria for performing a snapshot when the connector starts: +
 +
`initial` - For tables in capture mode, the connector takes a snapshot of the schema for the table and the data in the table. This is useful for populating Kafka topics with a complete representation of the data. +
 +
`schema_only` - For tables in capture mode, the connector takes a snapshot of only the schema for the table. This is useful when only the changes that are happening from now on need to be emitted to Kafka topics. After the snapshot is complete, the connector continues by reading change events from the database's redo logs.

|[[db2-property-snapshot-isolation-mode]]<<db2-property-snapshot-isolation-mode, `snapshot.isolation.mode`>>
|`repeatable_read`
|During a snapshot, controls the transaction isolation level and how long the connector locks the tables that are in capture mode. The possible values are: +
 +
`read_uncommitted` - Does not prevent other transactions from updating table rows during an initial snapshot. This mode has no data consistency guarantees; some data might be lost or corrupted. +
 +
`read_committed` - Does not prevent other transactions from updating table rows during an initial snapshot. It is possible for a new record to appear twice: once in the initial snapshot and once in the streaming phase. However, this consistency level is appropriate for data mirroring. +
 +
`repeatable_read` - Prevents other transactions from updating table rows during an initial snapshot. It is possible for a new record to appear twice: once in the initial snapshot and once in the streaming phase. However, this consistency level is appropriate for data mirroring. +
 +
`exclusive` - Uses repeatable read isolation level but takes an  exclusive lock for all tables to be read. This mode prevents other transactions from updating table rows during an initial snapshot. Only `exclusive` mode guarantees full consistency; the initial snapshot and streaming logs constitute a linear history.

|[[db2-property-event-processing-failure-handling-mode]]<<db2-property-event-processing-failure-handling-mode, `event.processing{zwsp}.failure.handling.mode`>>
|`fail`
|Specifies how the connector handles exceptions during processing of events. The possible values are: +
 +
`fail` - The connector logs the offset of the problematic event and stops processing. +
 +
`warn` - The connector logs the offset of the problematic event and continues processing with the next event. +
 +
`skip` - The connector skips the problematic event and continues processing with the next event.

|[[db2-property-poll-interval-ms]]<<db2-property-poll-interval-ms, `poll.interval.ms`>>
|`1000`
|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 1000 milliseconds, or 1 second.

|[[db2-property-max-queue-size]]<<db2-property-max-queue-size, `max.queue.size`>>
|`8192`
|Positive integer value for the maximum size of the blocking queue. The connector places change events that it reads from the database log into the blocking queue before writing them to Kafka. This queue can provide backpressure for reading change-data tables when, for example, writing records to Kafka is slower than it should be or Kafka is not available. Events that appear in the queue are not included in the offsets that are  periodically recorded by the connector. The `max.queue.size` value should always be larger than the value of the `max.batch.size` connector  configuration property.

|[[db2-property-max-batch-size]]<<db2-property-max-batch-size, `max.batch.size`>>
|`2048`
|Positive integer value that specifies the maximum size of each batch of events that the connector processes.

|[[db2-property-heartbeat-interval-ms]]<<db2-property-heartbeat-interval-ms, `heartbeat.interval.ms`>>
|`0`
|Controls how frequently the connector sends heartbeat messages to a Kafka topic. The default behavior is that the connector does not send heartbeat messages. +
 +
Heartbeat messages are useful for monitoring whether the connector is receiving change events from the database. Heartbeat messages might help decrease the number of change events that need to be re-sent when a connector restarts. To send heartbeat messages, set this property to a positive integer, which indicates the number of milliseconds between heartbeat messages. +
 +
Heartbeat messages are useful when there are many updates in a database that is being tracked but only a tiny number of updates are in tables that are in capture mode. In this situation, the connector reads from the database transaction log as usual but rarely emits change records to Kafka. This means that the connector has few opportunities to send the latest offset to Kafka. Sending heartbeat messages enables the connector to send the latest offset to Kafka.

|[[db2-property-heartbeat-topics-prefix]]<<db2-property-heartbeat-topics-prefix, `heartbeat.topics.prefix`>>
|`__debezium-heartbeat`
|Specifies the prefix for the name of the topic to which the connector sends heartbeat messages. The format for this topic name is  `<heartbeat.topics.prefix>.<server.name>`.

|[[db2-property-snapshot-delay-ms]]<<db2-property-snapshot-delay-ms, `snapshot.delay.ms`>>
|
|An interval in milliseconds that the connector should wait before performing a snapshot when the connector starts. If you are starting multiple connectors in a cluster, this property is useful for avoiding snapshot interruptions, which might cause re-balancing of connectors.

|[[db2-property-snapshot-fetch-size]]<<db2-property-snapshot-fetch-size, `snapshot.fetch.size`>>
|`2000`
|During a snapshot, the connector reads table content in batches of rows. This property specifies the maximum number of rows in a batch.

|[[db2-property-snapshot-lock-timeout-ms]]<<db2-property-snapshot-lock-timeout-ms, `snapshot.lock.timeout.ms`>>
|`10000`
|Positive integer value that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If the connector cannot acquire table locks in this interval, the snapshot fails. {link-prefix}:{link-db2-connector}#db2-snapshots[How the connector performs snapshots] provides details. Other possible settings are: +
 +
`0` -  The connector immediately fails when it cannot obtain a lock. +
 +
`-1` - The connector waits infinitely.

|[[db2-property-snapshot-select-statement-overrides]]<<db2-property-snapshot-select-statement-overrides, `snapshot.select.statement.overrides`>>
|
|Controls which table rows are included in snapshots. This property affects snapshots only. It does not affect events that the connector reads from the log. Specify a comma-separated list of fully-qualified table names in the form _schemaName.tableName_. +
 +
For each table that you specify, also specify another configuration property: `snapshot.select.statement.overrides._SCHEMA_NAME_._TABLE_NAME_`. For example: `snapshot.select.statement.overrides.customers.orders`. Set this property to a `SELECT` statement that obtains only the rows that you want in the snapshot. When the connector performs a snapshot, it executes this `SELECT` statement to retrieve data from that table. +
 +
A possible use case for setting these properties is large, append-only tables. You can specify a `SELECT` statement that sets a specific point for where to start a snapshot, or where to resume a snapshot if a previous snapshot was interrupted.

|[[db2-property-sanitize-field-names]]<<db2-property-sanitize-field-names, `sanitize.field.names`>>
|`true` if connector configuration sets the `key.converter` or `value.converter` property to the Avro converter.

`false` if not.
|Indicates whether field names are sanitized to adhere to {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming requirements].

|[[db2-property-provide-transaction-metadata]]<<db2-property-provide-transaction-metadata, `provide.transaction.metadata`>>
|`false`
|Determines whether the connector generates events with transaction boundaries and enriches change event envelopes with transaction metadata. Specify `true` if you want the connector to do this. See  {link-prefix}:{link-db2-connector}#db2-transaction-metadata[Transaction metadata] for details.

|===

[id="db2-pass-through-properties"]
.Pass-through connector configuration properties

The connector also supports _pass-through_ configuration properties that it uses when it creates Kafka producers and consumers:

 * All connector configuration properties that begin with the `database.history.producer.` prefix are used (without the prefix) when creating the Kafka producer that writes to the database history topic.

 * All connector configuration properties that begin with the  `database.history.consumer.` prefix are used (without the prefix) when creating the Kafka consumer that reads the database history when the connector starts.

For example, the following connector configuration properties {link-kafka-docs}.html#security_configclients[secure connections to the Kafka broker]:

[source,indent=0]
----
database.history.producer.security.protocol=SSL
database.history.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
database.history.producer.ssl.keystore.password=test1234
database.history.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
database.history.producer.ssl.truststore.password=test1234
database.history.producer.ssl.key.password=test1234
database.history.consumer.security.protocol=SSL
database.history.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
database.history.consumer.ssl.keystore.password=test1234
database.history.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
database.history.consumer.ssl.truststore.password=test1234
database.history.consumer.ssl.key.password=test1234
----

Be sure to consult the {link-kafka-docs}.html[Kafka documentation] for all of the configuration properties for Kafka producers and consumers. Note that the Db2 connector uses the {link-kafka-docs}.html#newconsumerconfigs[new consumer].

Also, the connector passes configuration properties that start with `database.` to the JDBC URL, for example, `database.applicationName=debezium`.

// Type: assembly
// ModuleID: monitoring-debezium-db2-connector-performance
// Title: Monitoring {prodname} Db2 connector performance
[[db2-monitoring]]
== Monitoring

The {prodname} Db2 connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* {link-prefix}:{link-db2-connector}#db2-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* {link-prefix}:{link-db2-connector}#db2-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is capturing changes and streaming change event records.
* {link-prefix}:{link-db2-connector}#db2-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history.

{link-prefix}:{link-debezium-monitoring}[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.

// Type: reference
// ModuleID: monitoring-debezium-during-snapshots-of-db2-databases
// Title: Monitoring {prodname} during snapshots of Db2 databases
[[db2-monitoring-snapshots]]
[[db2-snapshot-metrics]]
=== Snapshot metrics

The *MBean* is `debezium.db2:type=connector-metrics,context=snapshot,server=_<database.server.name>_`.

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-snapshot-metrics.adoc[leveloffset=+1]

// Type: reference
// ModuleID: monitoring-debezium-db2-connector-record-streaming
// Title: Monitoring {prodname} Db2 connector record streaming
[[db2-monitoring-streaming]]
[[db2-streaming-metrics]]
=== Streaming metrics

The *MBean* is `debezium.db2:type=connector-metrics,context=streaming,server=_<database.server.name>_`.

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-streaming-metrics.adoc[leveloffset=+1]

// Type: reference
// ModuleID: monitoring-debezium-db2-connector-schema history
// Title: Monitoring {prodname} Db2 connector schema history
[[db2-monitoring-schema-history]]
[[db2-schema-history-metrics]]
=== Schema history metrics

The *MBean* is `debezium.db2:type=connector-metrics,context=schema-history,server=_<database.server.name>_`.

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-schema-history-metrics.adoc[leveloffset=+1]

// Type: reference
// ModuleID: managing-debezium-db2-connectors
// Title: Managing {prodname} Db2 connectors
[[db2-management]]
== Management

After you deploy a {prodname} Db2 connector, use the {prodname} management UDFs to control Db2 replication (ASN) with SQL commands. Some of the UDFs expect a return value in which case you use the  SQL `VALUE` statement to invoke them. For other UDFs, use the SQL `CALL` statement.

.Descriptions of {prodname} management UDFs
[cols="1,3, 2",options="header"]
|===
|Task |Command |Notes

|[[debezium-db2-start-asn-agent]]<<debezium-db2-start-asn-agent,Start the ASN agent>>
|`VALUES ASNCDC.ASNCDCSERVICES('start','asncdc');`
|

|[[debezium-db2-stop-asn-agent]]<<debezium-db2-stop-asn-agent,Stop the ASN agent>>
|`VALUES ASNCDC.ASNCDCSERVICES('stop','asncdc');`
|

|[[debezium-db2-check-asn-agent]]<<debezium-db2-check-asn-agent,Check the status of the ASN agent>>
|`VALUES ASNCDC.ASNCDCSERVICES('status','asncdc');`
|

|[[debezium-db2-put-capture-mode]]<<debezium-db2-put-capture-mode,Put a table into capture mode>>
|`CALL ASNCDC.ADDTABLE('MYSCHEMA', 'MYTABLE');`
|Replace `MYSCHEMA`  with the name of the schema that contains the table you want to put into capture mode. Likewise, replace `MYTABLE` with the name of the table to put into capture mode.

|[[debezium-db2-remove-capture-mode]]<<debezium-db2-remove-capture-mode,Remove a table from capture mode>>
|`CALL ASNCDC.REMOVETABLE('MYSCHEMA', 'MYTABLE');`
|

|[[debezium-db2-reinitialize-asn-service]]<<debezium-db2-reinitialize-asn-service,Reinitialize the ASN service>>
|`VALUES ASNCDC.ASNCDCSERVICES('reinit','asncdc');`
|Do this after you put a table into capture mode or after you remove a table from capture mode.

|===

// Type: assembly
// ModuleID: updating-schemas-for-db2-tables-in-capture-mode-for-debezium-connectors
// Title: Updating schemas for Db2 tables in capture mode for {prodname} connectors
[[db2-schema-evolution]]
== Schema evolution

While a {prodname} Db2 connector can capture schema changes, to update a schema, you must collaborate with a database administrator to ensure that the connector continues to produce change events. This is required by the way that Db2 implements replication.

For each table in capture mode, Db2's replication feature creates a change-data table that contains all changes to that source table. However, change-data table schemas are static. If you update the schema for a table in capture mode then you must also update the schema of its corresponding change-data table. A {prodname} Db2 connector cannot do this. A database administrator with elevated privileges must update schemas for tables that are in capture mode.

[WARNING]
====
It is vital to execute a schema update procedure completely before there is a new schema update on the same table. Consequently, the recommendation is to execute all DDLs in a single batch so the schema update procedure is done only once.
====

There are generally two procedures for updating table schemas:

* {link-prefix}:{link-db2-connector}#db2-offline-schema-update[Offline - executed while {prodname} is stopped]
* {link-prefix}:{link-db2-connector}#db2-online-schema-update[Online - executed while {prodname} is running]

Each approach has advantages and disadvantages.

// Type: procedure
// ModuleID: performing-offline-schema-updates-for-debezium-db2-connectors
// Title: Performing offline schema updates for {prodname} Db2 connectors
[[db2-offline-schema-update]]
=== Offline schema update

You stop the {prodname} Db2 connector before you perform an offline schema update. While this is the safer schema update procedure, it might not be feasible for applications with high-availability requirements.

.Prerequisites

* One or more tables that are in capture mode require schema updates.

.Procedure

. Suspend the application that updates the database.
. Wait for the {prodname} connector to stream all unstreamed change event records.
. Stop the {prodname} connector.
. Apply all changes to the source table schema.
. In the ASN register table, mark the tables with updated schemas as `INACTIVE`.
. {link-prefix}:{link-db2-connector}#debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.
. Remove the source table with the old schema from capture mode by {link-prefix}:{link-db2-connector}#debezium-db2-remove-capture-mode[running the {prodname} UDF for removing tables from capture mode].
. Add the source table with the new schema to capture mode by {link-prefix}:{link-db2-connector}#debezium-db2-put-capture-mode[running the {prodname} UDF for adding tables to capture mode].
. In the ASN register table, mark the updated source tables as `ACTIVE`.
. {link-prefix}:{link-db2-connector}#debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Resume the application that updates the database.
. Restart the {prodname} connector.

// Type: procedure
// ModuleID: performing-online-schema-updates-for-debezium-db2-connectors
// Title: Performing online schema updates for {prodname} Db2 connectors
[[db2-hot-schema-update]]
=== Online schema update

An online schema update does not require application and data processing downtime. That is, you do not stop the {prodname} Db2 connector before you perform an online schema update. Also, an online schema update procedure is simpler than the procedure for an offline schema update.

However, when a table is in capture mode, after a change to a column name, the Db2 replication feature continues to use the old column name. The new column name does not appear in {prodname} change events. You must restart the connector to see the new column name in change events.

.Prerequisites

* One or more tables that are in capture mode require schema updates.

.Procedure when adding a column to the end of a table

. Lock the source tables whose schema you want to change.
. In the ASN register table, mark the locked tables as `INACTIVE`.
. {link-prefix}:{link-db2-connector}#debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Apply all changes to the schemas for the source tables.
. Apply all changes to the schemas for the corresponding change-data tables.
. In the ASN register table, mark the source tables as `ACTIVE`.
. {link-prefix}:{link-db2-connector}#debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Optional. Restart the connector to see updated column names in change events.

.Procedure when adding a column to the middle of a table

. Lock the source table(s) to be changed.
. In the ASN register table, mark the locked tables as `INACTIVE`.
. {link-prefix}:{link-db2-connector}#debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. For each source table to be changed:
.. Export the data in the source table.
.. Truncate the source table.
.. Alter the source table and add the column.
.. Load the exported data into the altered source table.
.. Export the data in the source table's corresponding change-data table.
.. Truncate the change-data table.
.. Alter the change-data table and add the column.
.. Load the exported data into the altered change-data table.
. In the ASN register table, mark the tables as `INACTIVE`. This marks the old change-data tables as inactive, which allows the data in them to remain but they are no longer updated.
. {link-prefix}:{link-db2-connector}#debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Optional. Restart the connector to see updated column names in change events.
