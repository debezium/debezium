// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-db2"]
= {prodname} connector for Db2 

:community: true

ifdef::community[]

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]

[NOTE]
====
This connector is in an incubating state. Exact semantics, configuration options and other features may change in future revisions, based on the feedback we receive. Please let us know if you encounter any problems.
====
endif::community[]

{prodname}'s Db2 connector can capture row-level changes in the tables of a Db2 database. This connector is strongly inspired by the {prodname} implementation of SQL Server, which uses a SQL-based polling model that puts tables into "capture mode". When a table is in capture mode, the {prodname} Db2 connector generates and streams a change event for each row-level update to that table. 

A table that is in capture mode has an associated change-data table, which Db2 creates. For each change to a table that is in capture mode, Db2 adds data about that change to the table's associated change-data table. A change-data table contains an entry for each state of a row. It also has specify entries for deletions. The {prodname} Db2 connector reads change events from change-data tables and emits them to Kafka topics. 

The first time a {prodname} Db2 connector connects to a Db2 database, the connector reads a consistent snapshot of the tables for which the connector is configured to capture changes. By default, this is all non-system tables. There are connector configuration properties that let you specify which tables to put into capture mode, or which tables to exclude from capture mode. 

When the snapshot is complete the connector begins emitting change events for committed updates to tables that are in capture mode. By default, change events for a particular table go to a Kafka topic that has the same name as the table. Applications and services consume change events from these topics.

The connector uses the abstract syntax notation (ASN) libraries that come as a standard part of Db2 LUW (Db2 for Linux, UNIX and Windows) and which you can add to Db2 zOS. To use ASN and hence this connector, you must have a license for the IBM InfoSphere Data Replication (IIDR) product. However, IIDR does not need to be installed. 

The connector has been tested with Db2/Linux 11.5.0.0. It is expected that the connector would also work on Windows, AIX and zOS.

ifdef::product[]
Information and procedures for using a {prodname} Db2 connector is organized as follows: 

* xref:overview-of-debezium-db2-connector[]
* xref:how-debezium-db2-connectors-work[]
* xref:descriptions-of-debezium-db2-connector-data-change-events[]
* xref:how-debezium-db2-connectors-map-data-types[]
* xref:setting-up-db2-to-run-a-debezium-connector[]
* xref:deploying-and-managing-debezium-db2-connectors[]

endif::product[]

// Type: concept
// Title: Overview of {prodname} Db2 connector 
// ModuleID: overview-of-debezium-db2-connector
[[db2-overview]]
== Overview

The {prodname} Db2 connector is based on the link:https://www.ibm.com/support/pages/q-replication-and-sql-replication-product-documentation-pdf-format-version-101-linux-unix-and-windows[ASN Capture/Apply agents] 
that enable SQL Replication in Db2. A capture agent: 

* Generates change-data tables for tables that are in capture mode. 
* Monitors tables in capture mode and stores change events for updates to those tables in their corresponding change-data tables. 

The {prodname} connector uses a SQL interface to query change-data tables for  change events. 

The database administrator must put the tables for which you want to capture changes into capture mode. There are Db2 control commands for doing this. Alternatively, for convenience and for automating testing, there is a {prodname} user-defined function (UDF) in C that you can compile and then use to do the following:  

* Control the ASN agent
* Put tables into capture mode
* Create the ASN schemas and change-data tables
* Remove tables from capture mode

These utilities are described in `debezium-connector-db2/src/test/docker/db2-cdc-docker/`.

After the tables of interest are in capture mode, the connector reads their corresponding change-data tables to obtain change events for table updates. The connector produces a change event for each row-level insert, update, and delete operation on a table that is in capture mode. For each table in capture mode, the connector streams change events to a Kafka topic that has the same name as the changed table. This is default behavior that you can modify. Client applications read the Kafka topics that correspond to the database tables of interest and can react to each row-level change event.

Typically, the database administrator puts a table into capture mode in the middle of the life of a table. This means that the connector does not have the complete history of all changes that have been made to the table. Therefore, when the Db2 connector first connects to a particular Db2 database, it starts by performing a _consistent snapshot_ of each table that is in capture mode. After the connector completes the snapshot, the connector streams change events from the point at which the snapshot was made. In this way, the connector starts with a consistent view of the tables that are in capture mode, and does not drop any changes that were made while it was performing the snapshot.

{prodname} connectors are tolerant of failures. As the connector reads and produces change events, it records the log sequence number (LSN) of the change-data table entry. The LSN is the position of the change event in the database log. If the connector stops for any reason, including communication failures, network problems, or crashes, upon restarting it continues reading the change-data tables where it left off. This includes snapshots. That is, if the snapshot was not complete when the connector stopped, upon restart the connector begins a new snapshot. 

// Type: assembly
// ModuleID: how-debezium-db2-connectors-work
// Title: How {prodname} Db2 connectors work
[[how-the-db2-connector-works]]
== How the Db2 connector works

To optimally configure and run a {prodname} Db2 connector, it is helpful to understand how the connector performs snapshots, streams change events, determines Kafka topic names, and handles schema changes. 

ifdef::product[]
Details are in the following topics: 

* xref:how-debezium-db2-connectors-perform-database-snapshots[]
* xref:how-debezium-db2-connectors-read-change-data-tables[]
* xref:default-names-of-kafka-topics-that-receive-db2-change-event-records[]
* xref:about-the-debezium-db2-connector-schema-change-topic[]
* xref:debezium-db2-connector-generated-events-that-represent-transaction-boundaries[]
* xref:how-debezium-db2-connectors-handle-database-schema-evolution[]

endif::product[]

// Type: concept
// ModuleID: how-debezium-db2-connectors-perform-database-snapshots
// Title: How {prodname} Db2 connectors perform database snapshots
[[db2-snapshots]]
=== Snapshots

Db2`s change data capture feature is not designed to store the complete history of database changes. Consequently, when a {prodname} Db2 connector connects to a database for the first time, it takes a consistent snapshot of tables that are in capture mode and streams this state to Kafka. This establishes the baseline for table content. 

By default, when a Db2 connector performs a snapshot, it does the following: 

. Determines which tables are in capture mode, and thus must be included in the snapshot. By default, all non-system tables are in capture mode. Connector configuration properties, such as `table.blacklist` and `table.whitelist` let you specify which tables should be in capture mode. 
. Obtains a lock on each of the tables in capture mode. This ensures that no schema changes can occur in those tables during the snapshot.
The level of the lock is determined by the `snapshot.isolation.mode` connector  configuration property.
. Reads the highest (most recent) LSN position in the server's transaction log.
. Captures the schema of all tables that are in capture mode. The connector persists this information in its internal database history topic.
. Optional, releases the locks obtained in step 2. Typically, these locks are held for only a short time.
. At the LSN position read in step 3, scans the tables that are in capture mode and their schemas. During the scan, the connector: 
.. Confirms that the table was created before the start of the snapshot. If it was not, the snapshot skips that table. After the snapshot is complete, and the connector starts emitting change events, the connector produces change events for any tables that were created during the snapshot. 
.. Produces a _read_ event for each row in each table that is in capture mode. All _read_ events contain the same LSN position, which is the LSN position that was obtained in step 3. 
.. Emits each _read_ event to the Kafka topic that has the same name as the table.
. Records the successful completion of the snapshot in the connector offsets.

// Type: concept
// Title: How {prodname} Db2 connectors read change-data tables
[id="how-debezium-db2-connectors-read-change-data-tables"]
=== Change-data tables

After a complete snapshot, when a {prodname} Db2 connector starts for the first time, the connector identifies the change-data table for each source table that is in capture mode. The connector does the following for each change-data table: 

. Reads change events that were created between the last stored, highest LSN and the current, highest LSN.
. Orders the change events according to the commit LSN and the change LSN for each event. This ensures that the connector emits the change events in the order in which the table changes occurred. 
. Passes commit and change LSNs as offsets to Kafka Connect.
. Stores the highest LSN that the connector passed to Kafka Connect.

After a restart, the connector resumes emitting change events from the offset (commit and change LSNs) where it left off. While the connector is running and emitting change events, if you remove a table from capture mode or add a table to capture mode, the connector detects this and modifies its behavior accordingly. 

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-db2-change-event-records
// Title: Default names of Kafka topics that receive {prodname} Db2 change event records
[[db2-topic-names]]
=== Topic names

By default, the Db2 connector writes change events for all insert, update, and delete operations on a single table to a single Kafka topic. The name of the Kafka topic has the following format: 

_databaseName_._schemaName_._tableName_

_databaseName_:: The logical name of the connector as specified with the `database.server.name` connector configuration property.

_schemaName_:: The name of the schema in which the operation occurred.

_tableName_:: The name of the table in which the operation occurred.

Unlike the {prodname} SQL Server connector, it is only possible for a Db2 connector to streams changes from only one Db2 database.

For example, consider a Db2 installation with the `mydatabase` database,  which contains four tables: `PRODUCTS`, `PRODUCTS_ON_HAND`, `CUSTOMERS`, and `ORDERS` that are in the `MYSCHEMA` schema. The connector would emit events to these four Kafka topics:

* `mydatabase.MYSCHEMA.PRODUCTS`
* `mydatabase.MYSCHEMA.PRODUCTS_ON_HAND`
* `mydatabase.MYSCHEMA.CUSTOMERS`
* `mydatabase.MYSCHEMA.ORDERS`

To configure a Db2 connector to emit change events to differently-named Kafka topics, see the documentation for the {link-prefix}:{link-topic-routing}#topic-routing[topic routing transformation].

// Type: concept
// Title: About the {prodname} Db2 connector schema change topic
[id="about-the-debezium-db2-connector-schema-change-topic"]
=== Schema change topic

For a table that is in capture mode, the {prodname} Db2 connector stores the history of schema changes to that table in a database history topic. This topic reflects an internal connector state and you should not use it. If your application needs to track schema changes, there is a public schema change topic. The name of the schema change topic is the same as the logical server name specified in the connector configuration.

[WARNING]
====
The format of messages that a connector emits to its schema change topic is in an incubating state and can change without notice.
====

{prodname} emits a message to the schema change topic when:  

* A new table goes into capture mode. 
* During a {link-prefix}:{link-db2-connector}#db2-schema-evolution[database schema update], there is a change in the schema for a table that is in capture mode. 

A message emitted to the schema change topic means that you need to perform {link-prefix}:{link-db2-connector}#db2-schema-evolution[schema evolution].

A schema change topic message contains a logical representation of the table schema, for example: 

[source,json,indent=0,subs="attributes"]
----
{
  "schema": {
  ...
  },
  "payload": {
    "source": {
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "db2",
      "ts_ms": 1588252618953,
      "snapshot": "true",
      "db": "testdb",
      "schema": "DB2INST1",
      "table": "CUSTOMERS",
      "change_lsn": null,
      "commit_lsn": "00000025:00000d98:00a2",
      "event_serial_no": null
    },
    "databaseName": "TESTDB", // <1>
    "schemaName": "DB2INST1",
    "ddl": null, // <2>
    "tableChanges": [ // <3>
      {
        "type": "CREATE", // <4>
        "id": "\"DB2INST1\".\"CUSTOMERS\"", // <5>
        "table": { // <6>
          "defaultCharsetName": null,
          "primaryKeyColumnNames": [ // <7>
            "ID"
          ],
          "columns": [ // <8>
            {
              "name": "ID",
              "jdbcType": 4,
              "nativeType": null,
              "typeName": "int identity",
              "typeExpression": "int identity",
              "charsetName": null,
              "length": 10,
              "scale": 0,
              "position": 1,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "FIRST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 2,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "LAST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 3,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "EMAIL",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 4,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            }
          ]
        }
      }
    ]
  }
}
----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,3,6",options="header"]
|===
|Item |Field name |Description

|1
|`databaseName` +
`schemaName` 
|Identifies the database and the schema that contain the change.  

|2
|`ddl`
|Always `null` for the Db2 connector. For other connectors, this field contains the DDL responsible for the schema change. This DDL is not available to Db2 connectors. 

|3
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|4
|`type` 
a|Describes the kind of change. The value is one of the following: 

* `CREATE` - table created
* `ALTER` - table modified
* `DROP` - table deleted

|5
|`id`
|Full identifier of the table that was created, altered, or dropped.

|6
|`table` 
|Represents table metadata after the applied change.

|7
|`primaryKeyColumnNames` 
|List of columns that compose the table's primary key.

|8
`columns`
|Metadata for each column in the changed table. 

|===

In messages to the schema change topic, the key is the name of the database that contains the schema change. In the following example, the `payload` field contains the key:

[source,json,indent=0,subs="attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.db2.SchemaChangeKey"
  },
  "payload": {
    "databaseName": "TESTDB"
  }
}
----

// Type: assembly
// ModuleID: how-debezium-db2-connectors-handle-database-schema-evolution
// Title: How {prodname} Db2 connectors handle database schema evolution
[[db2-schema-evolution]]
=== Database schema evolution

While a {prodname} Db2 connector can capture schema changes, to update a schema, you must collaborate with a database administrator to ensure that the connector continues to produce change events. This is required by the way that Db2 implements change data capture. 

For each table in capture mode, Db2's change data capture feature creates a change-data table that contains all changes to that source table. However, change-data table structure is static. If you update the schema for a table in capture mode then you must also update the schema of its corresponding change-data table. A {prodname} Db2 connector cannot do this. A database administrator with elevated privileges must update schemas for tables that are in capture mode.  

[WARNING]
====
It is vital to execute a schema update procedure completely before there is a new schema update on the same table. Consequently, the recommendation is to execute all DDLs in a single batch so the schema update procedure is done only once.
====

There are generally two procedures for updating table schemas:

* {link-prefix}:{link-db2-connector}#db2-cold-schema-update[Cold - executed while {prodname} is stopped]
* {link-prefix}:{link-db2-connector}#db2-hot-schema-update[Hot - executed while {prodname} is running]

Each approach has advantages and disadvantages. 

// Type: procedure
// ModuleID: performing-cold-schema-updates-for-debezium-db2-connectors
// Title: Performing cold schema updates for {prodname} Db2 connectors
[[db2-cold-schema-update]]
==== Cold schema update

You stop the {prodname} Db2 connector before you perform a cold schema update. While this is the safer schema update procedure, it might not be feasible for applications with high-availability requirements.

.Prerequisites

* Database administrator privileges.
* One or more tables that are in capture mode require schema updates. 

.Procedure

. Suspend the application that updates the database.
. Wait for the {prodname} connector to stream all unstreamed change event records. 
. Stop the {prodname} connector.
. Apply all changes to the source table schema.
. Mark the updated tables as `INACTIVE` in the ASN register table.
. Reinitialize the ASN capture service. 
//  (see the UDFs)
. Remove the change-data table with the old schema from ASN.
. Add the change-data table with the new schema to ASN.
. Mark the updated source tables as `ACTIVE` in the ASN register table.
. Reinitialize the ASN capture service. 
// (see the UDFs)
. Resume the application that updates the database.
. Restart the {prodname} connector.

// Type: procedure
// ModuleID: performing-hot-schema-updates-for-debezium-db2-connectors
// Title: Performing hot schema updates for {prodname} Db2 connectors
[[db2-hot-schema-update]]
==== Hot schema update

A hot schema update does not require application and data processing downtime. That is, you do not stop the {prodname} Db2 connector before you perform a hot schema update. Also, a hot schema update procedure is simpler than the procedure for a cold schema update. 

However, When a table is in capture mode, after a change to a column name, the Db2 change data capture feature continues to use the old column name. The new column name does not appear in {prodname} change events. You must restart to connector to see the new column name in change events. 

.Prerequisites

* Database administrator privileges.
* There was a change to the schema of a table that is capture mode. 

.Procedure when adding a column after the last column

. Lock the source tables whose schema you want to change. 
. In the ASN register table, mark the locked tables as `INACTIVE`. 
. Reinitialize the ASN capture service.
// (see the UDFs). 
. Apply all changes to the schemas for the source tables.  
. Apply all changes to the schemas for the corresponding change-data tables.
. In the ASN register table, mark the source tables as `ACTIVE`.
. Reinitialize the ASN capture service.
// (see the UDFs)
. Optional. Restart the connector to see updated column names in change events. 

.Procedure when adding a column in the middle

. Lock the source table(s) to be changed.
. Mark the locked tables as `INACTIVE` in the ASN register table.
. Reinitialize the ASN capture service.
//  (see the UDFs)
. For each source table to be changed: 
.. Export the data in the source table. 
.. Truncate the source table.
.. Alter the source table ti add the column. 
.. Load the exported data into the altered source table.
.. Export the data in the source table's corresponding change-data table.
.. Truncate the change-data table.
.. Alter the change-data table to add the column. 
.. Load the exported data into the altered change-data table.
. Mark the locked tables as `ACTIVE` in the ASN register table.
. Reinitialize the ASN capture service.
//  (see the UDFs)
. Optional. Restart the connector to see updated column names in change events. 

ifdef::community[]
==== Example

To be added. 
endif::community[]

// Type: concept
// ModuleID: debezium-db2-connector-generated-events-that-represent-transaction-boundaries
// Title: {prodname} Db2 connector-generated events that represent transaction boundaries
[[db2-transaction-metadata]]
=== Transaction metadata

{prodname} can generate events that represent transaction boundaries and that enrich change data event messages. For every transaction `BEGIN` and `END`, {prodname} generates an event that contains the following fields: 

* `status` - `BEGIN` or `END`
* `id` - string representation of unique transaction identifier
* `event_count` (for `END` events) - total number of events emitted by the transaction
* `data_collections` (for `END` events) - an array of pairs of `data_collection` and `event_count` that provides the number of events emitted by changes originating from given data collection

.Example

[source,json,indent=0,subs="attributes"]
----
{
  "status": "BEGIN",
  "id": "00000025:00000d08:0025",
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "00000025:00000d08:0025",
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "testDB.dbo.tablea",
      "event_count": 1
    },
    {
      "data_collection": "testDB.dbo.tableb",
      "event_count": 1
    }
  ]
}
----

Transaction events are written to the topic named `_database.server.name_.transaction`.

.Data change event enrichment

When transaction metadata is enabled the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

* `id` - string representation of unique transaction identifier
* `total_order` - absolute position of the event among all events generated by the transaction
* `data_collection_order` - the per-data collection position of the event among all events that were emitted by the transaction

Following is an example of a message:

[source,json,indent=0,subs="attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "transaction": {
    "id": "00000025:00000d08:0025",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

// Type: assembly
// ModuleID: descriptions-of-debezium-db2-connector-data-change-events
// Title: Descriptions of {prodname} Db2 connector data change events
[[db2-events]]
== Data change events

All data change events produced by the Db2 connector have a key and a value, although the structure of the key and value depend on the table from which the change events originated (see {link-prefix}:{link-db2-connector}#db2-topic-names[Topic names]).

[WARNING]
====
The {prodname} Db2 connector ensures that all Kafka Connect _schema names_ are http://avro.apache.org/docs/current/spec.html#names[valid Avro schema names].
This means that the logical server name must start with Latin letters or an underscore (e.g., [a-z,A-Z,\_]),
and the remaining characters in the logical server name and all characters in the schema and table names must be Latin letters, digits, or an underscore (e.g., [a-z,A-Z,0-9,\_]).
If not, then all invalid characters will automatically be replaced with an underscore character.

This can lead to unexpected conflicts when the database name, schema names, and table names contain other characters, and the only distinguishing characters between table full names are invalid and thus replaced with underscores.
In addition, note that databases, schemas and tables  can be case sensitive in Db2 meaning that different tables maybe mapped to the same Kafka topic.
====

{prodname} and Kafka Connect are designed around _continuous streams of event messages_, and the structure of these events may change over time.
This could be difficult for consumers to deal with, so to make it easy Kafka Connect makes each event self-contained.
Every message key and value has two parts: a _schema_ and _payload_.
The schema describes the structure of the payload, while the payload contains the actual data.

ifdef::product[]
Details are in the following topics:

* xref:about-keys-in-debezium-db2-change-events[]
* xref:about-values-in-debezium-db2-change-events[]
* xref:about-debezium-db2-change-events-for-operations-that-create-content[]
* xref:about-debezium-db2-change-events-for-operations-that-update-content[]
* xref:about-debezium-db2-change-events-for-operations-that-delete-content[]

endif::product[]

// Type: concept
// ModuleID: about-keys-in-debezium-db2-change-events
// Title: About keys in {prodname} db2 change events
[[db2-change-event-keys]]
=== Change event keys

For a given table, the change event's key has a structure that contains a field for each column in the primary key (or unique key constraint) of the table at the time the event was created.

Consider a `customers` table defined in the `mydatabase` database, in the `MYSCHEMA` schema:

[source,sql,indent=0]
----
CREATE TABLE customers (
 ID INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
 FIRST_NAME VARCHAR(255) NOT NULL,
 LAST_NAME VARCHAR(255) NOT NULL,
 EMAIL VARCHAR(255) NOT NULL UNIQUE
);
----

If the `database.server.name` connector configuration property has the value  `mydatabase`, every change event for the `customers` table while it has this definition has the same key structure, which in JSON looks like this:

[source,json,indent=0]
----
{
    "schema": {
        "type": "struct",
        "fields": [
            {
                "type": "int32",
                "optional": false,
                "field": "ID"
            }
        ],
        "optional": false,
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Key"
    },
    "payload": {
        "ID": 1004
    }
}
----

The `schema` portion of the key contains a Kafka Connect schema that describes what is in the key's `payload` portion. In this case, it means that:

* The key's `payload` value is not optional.
* The `mydatabase.MYSCHEMA.CUSTOMERS.Key` schema defines the structure of the key's payload. 
* They key's payload contains one required field named `id` of type `int32`.

If you look at the key's `payload` value, you see that it is indeed a structure, which in JSON is just an object, with a single `id` field, whose value is `1004`. This key describes output from the connector that is reading from the `mydatabase` database. The output is the `MYSCHEMA.CUSTOMERS` table row whose primary key, the `id` column, had a value of `1004`.

////
[NOTE]
====
Although the `column.blacklist` connector configuration property allows you to omit columns from event values, all columns in a primary or unique key are always included in the event's key.
====

[WARNING]
====
If the table does not have a primary or unique key, then the change event's key is null. The rows in a table without a primary or unique key constraint cannot be uniquely identified.
====
////

// Type: concept
// ModuleID: about-values-in-debezium-db2-change-events
// Title: About values in {prodname} Db2 change events
[[db2-change-event-values]]
=== Change event values

Like the message key, the value of a change event message has a _schema_ section and _payload_ section.
The payload section of every change event value produced by the Db2 connector has an _envelope_ structure with the following fields:

* `op` is a mandatory field that contains a string value describing the type of operation. Values for the Db2 connector are `c` for create (or insert), `u` for update, `d` for delete, and `r` for read (in the case of a snapshot).
* `before` is an optional field that if present contains the state of the row _before_ the event occurred. The structure will be described by the `mydatabase.MYSCHEMA.CUSTOMERS.Value` Kafka Connect schema, which the connector reading from 
`mydatabase` uses for all rows in the `MYSCHEMA.CUSTOMERS` table.

* `after` is an optional field that if present contains the state of the row _after_ the event occurred. The structure is described by the same `mydatabase.MYSCHEMA.CUSTOMERS.Value` Kafka Connect schema used in `before`.
* `source` is a mandatory field that contains a structure describing the source metadata for the event, which in the case of Db2 contains these fields: the {prodname} version, the connector name, whether the event is part of an ongoing snapshot or not, the commit LSN (not while snapshotting), the LSN of the change, database, schema and table where the change happened, and a timestamp representing the point in time when the record was read from the the source database by the connector. 

* `ts_ms` is optional and if present contains the time (using the system clock in the JVM running the Kafka Connect task) at which the connector processed the event.

And of course, the _schema_ portion of the event message's value contains a schema that describes this envelope structure and the nested fields within it.

// Type: concept
// ModuleID: about-debezium-db2-change-events-for-operations-that-create-content
// Title: About {prodname} Db2 change events for operations that create content
[[db2-create-events]]
=== _create_ events

Let's look at what a _create_ event value might look like for our `customers` table:

[source,json,indent=0,subs="attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "ID"
          },
          {
            "type": "string",
            "optional": false,
            "field": "FIRST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "LAST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "EMAIL"
          }
        ],
        "optional": true,
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Value",
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "ID"
          },
          {
            "type": "string",
            "optional": false,
            "field": "FIRST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "LAST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "EMAIL"
          }
        ],
        "optional": true,
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Value",
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": false,
            "field": "schema"
          },
          {
            "type": "string",
            "optional": false,
            "field": "table"
          },
          {
            "type": "string",
            "optional": true,
            "field": "change_lsn"
          },
          {
            "type": "string",
            "optional": true,
            "field": "commit_lsn"
          },
        ],
        "optional": false,
        "name": "io.debezium.connector.db2.Source",
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      }
    ],
    "optional": false,
    "name": "mydatabase.MYSCHEMA.CUSTOMERS.Envelope"
  },
  "payload": {
    "before": null,
    "after": {
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "john.doe@example.org"
    },
    "source": {
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559729468470,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000758:0003",
      "commit_lsn": "00000027:00000758:0005",
    },
    "op": "c",
    "ts_ms": 1559729471739
  }
}
----

If we look at the `schema` portion of this event's _value_, we can see the schema for the _envelope_, the schema for the `source` structure (which is specific to the Db2 connector and reused across all events), and the table-specific schemas for the `before` and `after` fields.

[TIP]
====
The names of the schemas for the `before` and `after` fields are of the form _logicalName_._schemaName_._tableName_.Value, and thus are entirely independent from all other schemas for all other tables.
This means that when using the link:/docs/faq/#avro-converter[Avro Converter], the resulting Avro schems for _each table_ in each _logical source_ have their own evolution and history.
====

If we look at the `payload` portion of this event's _value_, we can see the information in the event, namely that it is describing that the row was created (since `op=c`), and that the `after` field value contains the values of the new inserted row's' `ID`, `FIRST_NAME`, `LAST_NAME`, and `EMAIL` columns.

[TIP]
====
It may appear that the JSON representations of the events are much larger than the rows they describe.
This is true, because the JSON representation must include the _schema_ and the _payload_ portions of the message.
It is possible and even recommended to use the link:/docs/faq/#avro-converter[Avro Converter] to dramatically decrease the size of the actual messages written to the Kafka topics.
====

// Type: concept
// ModuleID: about-debezium-db2-change-events-for-operations-that-update-content
// Title: About {prodname} Db2 change events for operations that update content
[[db2-update-events]]
=== _update_ events
The value of an _update_ change event on this table will actually have the exact same _schema_, and its payload will be structured the same but will hold different values.
Here's an example:

[source,json,indent=0,subs="attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": {
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "john.doe@example.org"
    },
    "after": {
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "noreply@example.org"
    },
    "source": {
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559729995937,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000ac0:0002",
      "commit_lsn": "00000027:00000ac0:0007",
    },
    "op": "u",
    "ts_ms": 1559729998706
  }
}
----

When we compare this to the value in the _insert_ event, we see a couple of differences in the `payload` section:

* The `op` field value is now `u`, signifying that this row changed because of an update
* The `before` field now has the state of the row with the values before the database commit
* The `after` field now has the updated state of the row, and here was can see that the `email` value is now `noreply@example.org`.
* The `source` field structure has the same fields as before, but the values are different since this event is from a different position in the transaction log.
* The `ts_ms` shows the timestamp that {prodname} processed this event.

There are several things we can learn by just looking at this `payload` section. We can compare the `before` and `after` structures to determine what actually changed in this row because of the commit.
The `source` structure tells us information about Db2's record of this change (providing traceability), but more importantly this has information we can compare to other events in this and other topics to know whether this event occurred before, after, or as part of the same Db2 commit as other events.

[NOTE]
====
When the columns for a row's primary/unique key are updated, the value of the row's key has changed so {prodname} will output _three_ events: a `DELETE` event and a {link-prefix}:{link-db2-connector}#db2-tombstone-events[tombstone event] with the old key for the row, followed by an `INSERT` event with the new key for the row.
====

// Type: concept
// ModuleID: about-debezium-db2-change-events-for-operations-that-delete-content
// Title: About {prodname} Db2 change events for operations that delete content
[[db2-delete-events]]
=== _delete_ events

So far we've seen samples of _create_ and _update_ events.
Now, let's look at the value of a _delete_ event for the same table. Once again, the `schema` portion of the value will be exactly the same as with the _create_ and _update_ events:

[source,json,indent=0,subs="attributes"]
----
{
  "schema": { ... },
  },
  "payload": {
    "before": {
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "noreply@example.org"
    },
    "after": null,
    "source": {
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559730445243,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000db0:0005",
      "commit_lsn": "00000027:00000db0:0007"
    },
    "op": "d",
    "ts_ms": 1559730450205
  }
}
----

If we look at the `payload` portion, we see a number of differences compared with the _create_ or _update_ event payloads:

* The `op` field value is now `d`, signifying that this row was deleted
* The `before` field now has the state of the row that was deleted with the database commit.
* The `after` field is null, signifying that the row no longer exists
* The `source` field structure has many of the same values as before, except the `ts_ms`, `commit_lsn` and `change_lsn` fields have changed
* The `ts_ms` shows the timestamp that {prodname} processed this event.

This event gives a consumer all kinds of information that it can use to process the removal of this row.

The Db2 connector's events are designed to work with https://cwiki.apache.org/confluence/display/KAFKA/Log+Compaction[Kafka log compaction],
which allows for the removal of some older messages as long as at least the most recent message for every key is kept.
This allows Kafka to reclaim storage space while ensuring the topic contains a complete dataset and can be used for reloading key-based state.

[[db2-tombstone-events]]
When a row is deleted, the _delete_ event value listed above still works with log compaction, since Kafka can still remove all earlier messages with that same key.
But only if the message value is `null` will Kafka know that it can remove _all messages_ with that same key.
To make this possible, {prodname}'s Db2 connector always follows the _delete_ event with a special _tombstone_ event that has the same key but `null` value.

// Type: reference
// ModuleID: how-debezium-db2-connectors-map-data-types
// Title: How {prodname} Db2 connectors map data types
[[db2-data-types]]
== Data type mappings

A summary of Db2's data types are described in https://www.ibm.com/support/knowledgecenter/en/SSEPGG_11.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008483.html[Data Types].

The Db2 connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. How that value is represented in the event depends on the SQL data type of the column. This section describes these  mappings.

ifdef::product[]
Details are in the following sections: 

* xref:db2-basic-types[]
* xref:db2-temporal-types[]
* xref:db2-timestamp-types[]
* xref:db2-decimal-types[]

endif::product[]

[id="db2-basic-types"]
=== Basic types

The following table describes how the connector maps each of the Db2 data types to a _literal type_ and a _semantic type_ in event fields.

* _literal type_ describes how the value is literally represented using Kafka Connect schema types, namely `INT8`, `INT16`, `INT32`, `INT64`, `FLOAT32`, `FLOAT64`, `BOOLEAN`, `STRING`, `BYTES`, `ARRAY`, `MAP`, and `STRUCT`.

* _semantic type_ describes how the Kafka Connect schema captures the _meaning_ of the field using the name of the Kafka Connect schema for the field.

.Mappings for Db2 basic data types
[cols="20%a,15%a,30%a,35%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) |Notes

|`BOOLEAN`
|`BOOLEAN`
|n/a
|

|`BIGINT`
|`INT64`
|n/a
|

|`BINARY`
|`BYTES`
|n/a
|

|`BLOB`
|`BYTES`
|n/a
|

|`CHAR[(N)]`
|`STRING`
|n/a
|

|`CLOB`
|`STRING`
|n/a
|

|`DATE`
|`INT32`
|`io.debezium.time.Date`
|String representation of a timestamp without timezone information

|`DECFLOAT`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|

|`DECIMAL`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|

|`DBCLOB`
|`STRING`
|n/a
|


|`DOUBLE`
|`FLOAT64`
|n/a
|

|`INTEGER`
|`INT32`
|n/a
|

|`REAL`
|`FLOAT32`
|n/a
|

|`SMALLINT`
|`INT16`
|n/a
|

|`TIME`
|`INT32`
|`io.debezium.time.Time`
|String representation of a time without timezone information

|`TIMESTAMP`
|`INT64`
|`io.debezium.time.MicroTimestamp`
|String representation of a timestamp without timezone information

|`VARBINARY`
|`BYTES`
|n/a
|

|`VARCHAR[(N)]`
|`STRING`
|n/a
|

|`VARGRAPHIC`
|`STRING`
|n/a
|

|`XML`
|`STRING`
|`io.debezium.data.Xml`
|String representation of an XML document
|===

Other data type mappings are described in the following sections.

If present, a column's default value is propagated to the corresponding field's Kafka Connect schema. Change events contain the field's default value unless an explicit column value had been given. Consequently, there is rarely a need to obtain the default value from the schema.
ifdef::community[]
Passing the default value helps satisfy compatibility rules when {link-prefix}:{link-avro-serialization}[using Avro] as the serialization format together with the Confluent schema registry.
endif::community[]

[[db2-temporal-types]]
=== Temporal types

Other than Db2's `DATETIMEOFFSET` data type, which contains time zone information, how temporal types are mapped depends on the value of the `time.precision.mode` connector configuration property. The following sections describe these mappings:

* xref:db2-time-precision-mode-adaptive[`time.precision.mode=adaptive`]
* xref:db2-time-precision-mode-connect[`time.precision.mode=connect`]

[[db2-time-precision-mode-adaptive]]
.`time.precision.mode=adaptive`
When the `time.precision.mode` configuration property is set to `adaptive`, the default, the connector determines the literal type and semantic type based on the column's data type definition. This ensures that events _exactly_ represent the values in the database.

.Mappings when `time.precision.mode` is `adaptive`
[cols="20%a,15%a,30%a,35%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) |Notes

|`DATE`
|`INT32`
|`io.debezium.time.Date`
|Represents the number of days since the epoch.

|`TIME(0)`, `TIME(1)`, `TIME(2)`, `TIME(3)`
|`INT32`
|`io.debezium.time.Time`
|Represents the number of milliseconds past midnight, and does not include timezone information.

|`TIME(4)`, `TIME(5)`, `TIME(6)`
|`INT64`
|`io.debezium.time.MicroTime`
|Represents the number of microseconds past midnight, and does not include timezone information.

|`TIME(7)`
|`INT64`
|`io.debezium.time.NanoTime`
|Represents the number of nanoseconds past midnight, and does not include timezone information.

|`DATETIME`
|`INT64`
|`io.debezium.time.Timestamp`
|Represents the number of milliseconds past the epoch, and does not include timezone information.

|`SMALLDATETIME`
|`INT64`
|`io.debezium.time.Timestamp`
|Represents the number of milliseconds past the epoch, and does not include timezone information.

|`DATETIME2(0)`, `DATETIME2(1)`, `DATETIME2(2)`, `DATETIME2(3)`
|`INT64`
|`io.debezium.time.Timestamp`
|Represents the number of milliseconds past the epoch, and does not include timezone information.

|`DATETIME2(4)`, `DATETIME2(5)`, `DATETIME2(6)`
|`INT64`
|`io.debezium.time.MicroTimestamp`
|Represents the number of microseconds past the epoch, and does not include timezone information.

|`DATETIME2(7)`
|`INT64`
|`io.debezium.time.NanoTimestamp`
|Represents the number of nanoseconds past the epoch, and does not include timezone information.
|===

[[db2-time-precision-mode-connect]]
.`time.precision.mode=connect`
When the `time.precision.mode` configuration property is set to `connect`, the connector uses Kafka Connect logical types. This may be useful when consumers know about only the built-in Kafka Connect logical types and are unable to handle variable-precision time values. However, since Db2 supports tenth of a microsecond precision, the events generated by a connector with the `connect` time precision mode *results in a loss of precision* when the database column has a _fractional second precision_ value greater than 3. 

.Mappings when `time.precision.mode` is `connect`
[cols="20%a,15%a,30%a,35%a",options="header"]
|===
|Db2 Data Type |Literal type (schema type) |Semantic type (schema name) |Notes

|`DATE`
|`INT32`
|`org.apache.kafka.connect.data.Date`
| Represents the number of days since epoch.

|`TIME([P])`
|`INT64`
|`org.apache.kafka.connect.data.Time`
| Represents the number of milliseconds since midnight, and does not include timezone information. Db2 allows `P` to be in the range 0-7 to store up to tenth of microsecond precision, though this mode results in a loss of precision when `P` > 3.

|`DATETIME`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp`
| Represents the number of milliseconds since epoch, and does not include timezone information.

|`SMALLDATETIME`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp`
| Represents the number of milliseconds past epoch, and does not include timezone information.

|`DATETIME2`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp`
| Represents the number of milliseconds since epoch, and does not include timezone information. Db2 allows `P` to be in the range 0-7 to store up to tenth of microsecond precision, though this mode results in a loss of precision when `P` > 3.
|===

[[db2-timestamp-types]]
=== Timestamp types

The `DATETIME`, `SMALLDATETIME` and `DATETIME2` types represent a timestamp without time zone information.
Such columns are converted into an equivalent Kafka Connect value based on UTC.
So for instance the `DATETIME2` value "2018-06-20 15:13:16.945104" will be represented by a `io.debezium.time.MicroTimestamp` with the value "1529507596945104".

Note that the timezone of the JVM running Kafka Connect and {prodname} does not affect this conversion.

[[db2-decimal-types]]
==== Decimal types

[cols="15%a,15%a,35%a,35%a",options="header"]
|===
|Db2 Data Type |Literal type (schema type) |Semantic type (schema name) |Notes

|`NUMERIC[(P[,S])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer representing how many digits the decimal point was shifted.
The `connect.decimal.precision` schema parameter contains an integer representing the precision of the given decimal value.

|`DECIMAL[(P[,S])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer representing how many digits the decimal point was shifted.
The `connect.decimal.precision` schema parameter contains an integer representing the precision of the given decimal value.

|`SMALLMONEY`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer representing how many digits the decimal point was shifted.
The `connect.decimal.precision` schema parameter contains an integer representing the precision of the given decimal value.

|`MONEY`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`
|The `scale` schema parameter contains an integer representing how many digits the decimal point was shifted.
The `connect.decimal.precision` schema parameter contains an integer representing the precision of the given decimal value.
|===

// Type: procedure
// ModuleID: setting-up-db2-to-run-a-debezium-connector
// Title: Setting up Db2 to run a {prodname} connector
[[setting-up-db2]]
== Set up

Before using the Db2 connector to monitor the changes committed on the Db2 database, first enable _CDC_ on a monitored database.

We recommend using the UDF functions that we provide.
However these are only for convenience and manually performing the same commands using
_db2_ control commands would have the same effect. 

We assume here that the contents of 
debezium-connector-db2/src/test/docker/db2-cdc-docker are available
on the machine on which Db2 is running in $HOME/asncdctools/src
and that the user has logged-in as the db2inst1 user.

First compile this function on the Db2 server, using the _bldrtn_
C-compiler

[source,shell]

----
$ cd $HOME/asncdctools/src
----

[source,shell]

----
$ ./bldrtn asncdc
----


Start the database if not already running:


[source,shell]

----
$ db2 start db <DB NAME>

----

We need to make sure that the metadata catalog can be read via JDBC

[source,shell]
----
$ cd $HOME/sqllib/bnd
----

[source,shell]
----
$ db2 bind db2schema.bnd blocking all grant public sqlerror continue 
----

The database needs to have been recently backed-up, such that the ASN agents have a recent starting point to read from. Do the following if this is not the case. Note This will prune the data such that only the most recent version is available:

[source,shell]
----
$ db2 backup db <DB NAME> to <BACK UP LOCATION>
----

/dev/null can be used for the location if the older versions of the data do not need to be retained.

[source,shell]
----
$ db2 restart db <DB NAME>
----

Install the UDF:

[source,shell]

----
$ db2 connect to <DB NAME>
----

We assume that the _db2_ tool is installed on the db2inst1 user

[source,shell]
----
$ cp $HOME/asncdctools/src/asncdc $HOME/sqllib/function
----

[source,shell]
----
$ chmod 777 $HOME/sqllib/function

----



Enable the UDF that allows the ASN capture agent to be started/stopped

[source,shell]

----
$ db2 -tvmf $HOME/asncdctools/src/asncdc_UDF.sql
----

Create the ASN Control tables

[source,shell]

----
$ db2 -tvmf $HOME/asncdctools/src/asncdctables.sql
----


Enable the  UDF that allows us to add/remove tables to be captured

[source,shell]

----
$ db2 -tvmf $HOME/asncdctools/src/asncdcaddremove.sql
----



Having done the above, we can use the UDFs to control ASN via SQL commands.
Some of the UDFs expect a return value in which case we use the SQL _VALUE_
statement to invoke them, while others are fire-and-forget in which case we
use the SQL _CALL_ statement.


First the ASN agent needs to be started:

[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('start','asncdc');
----

If the agent every needs to be stopped:

[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('stop','asncdc');
----

The status if the agent can be checked at any moment:

[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('status','asncdc');
----


A table MYTABLE in MYSCHEMA can be put into capture mode by doing:

[source,sql]
----
CALL ASNCDC.ADDTABLE('MYSCHEMA', 'MYTABLE');
----


At table MYTABLE in MYSCHEMA can be removed from capture mode by doing:


[source,sql]
----
CALL ASNCDC.REMOVETABLE('MYSCHEMA', 'MYTABLE');
----

After a table is added or removed, the user __MUST__ reinitialize the ASN service:


[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('reinit','asncdc');
----

// Type: assembly
// ModuleID: deploying-and-managing-debezium-db2-connectors
// Title: Deploying and managing {prodname} Db2 connectors
[[db2-deploying-a-connector]]
== Deployment

ifdef::community[]

With https://zookeeper.apache.org[Zookeeper], http://kafka.apache.org/[Kafka], and {link-kafka-docs}.html#connect[Kafka Connect] installed, the remaining tasks to deploy a {prodname} Db2 connector are: 

. Download the link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-db2/{debezium-version}/debezium-connector-db2-{debezium-version}-plugin.tar.gz[connector's plug-in archive].

. Extract the JAR files into your Kafka Connect environment. 
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`]. 
. Obtain the link:https://www.ibm.com/support/pages/db2-jdbc-driver-versions-and-downloads[JDBC driver for Db2].
. Add the JDBC driver JAR file to the directory with the {prodname} Db2 connector JARs.
. Restart your Kafka Connect process to pick up the new JAR files.

If you need immutable containers, see link:https://hub.docker.com/r/debezium/[{prodname}'s Container images] for Zookeeper, Kafka and Kafka Connect with the Db2 connector already installed and ready to run.
You can also link:/docs/openshift/[run {prodname} on OpenShift].
endif::community[]

ifdef::product[]
To deploy a {prodname} Db2 connector, install the {prodname} Db2 connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect. Details are in the following topics: 

* xref:steps-for-installing-debezium-db2-connectors[]
* xref:debezium-db2-connector-configuration-example[]
* xref:adding-debezium-db2-connector-configuration-to-kafka-connect[]
* xref:monitoring-debezium-db2-connector-performance[]
* xref:descriptions-of-debezium-db2-connector-configuration-properties[]

// Type: concept
[id="steps-for-installing-debezium-db2-connectors"]
=== Steps for installing {prodname} Db2 connectors

To install the Db2 connector, follow the procedures in {LinkDebeziumInstallOpenShift}[{NameDebeziumInstallOpenShift}]. The main steps are:

. {LinkDebeziumUserGuide}#setting-up-db2-to-run-a-debezium-connector[Set up Db2 to run a {prodname} connector]. This enables the Db2 CDC feature to expose change-data for tables that are in capture mode.

. Use link:https://access.redhat.com/products/red-hat-amq#streams[Red Hat AMQ Streams] to set up Apache Kafka and Kafka Connect on OpenShift. AMQ Streams offers operators and images that bring Kafka to OpenShift. 

. Download the {prodname} link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=red.hat.integration&downloadType=distributions[Db2 connector].

. Extract the files into your Kafka Connect environment.
. Add the plug-in's parent directory to your Kafka Connect `plugin.path`, for example: 
+
[source]
----
plugin.path=/kafka/connect
----
+
The above example assumes that you extracted the {prodname} Db2 connector to the `/kafka/connect/{prodname}-connector-db2` path.

. Restart your Kafka Connect process to ensure that the new JAR files are picked up.

endif::product[]

// Type: concept
// ModuleID:debezium-db2-connector-configuration-example
// Title: {prodname} db2 connector configuration example
[[db2-example]]
[[db2-example-configuration]]
=== Connector configuration example

ifdef::community[]

Following is an example of the configuration for a Db2 connector that connects to a Db2 server on port 50000 at 192.168.99.100, whose logical name is `fullfillment`. Typically, you configure the {prodname} Db2 connector in a `.json` file using the configuration properties available for the connector.

You can choose to produce events for a subset of the schemas and tables. Optionally, ignore, mask, or truncate columns that are sensitive, too large, or not needed.

[source,json]
----
{
  "name": "db2-connector",  // <1>
  "config": {
    "connector.class": "io.debezium.connector.db2.Db2Connector", // <2>
    "database.hostname": "192.168.99.100", // <3>
    "database.port": "50000", // <4>
    "database.user": "db2inst1", // <5>
    "database.password": "Password!", // <6>
    "database.dbname": "mydatabase", // <7>
    "database.server.name": "fullfillment", // <8>
    "table.whitelist": "MYSCHEMA.CUSTOMERS", // <9>
    "database.history.kafka.bootstrap.servers": "kafka:9092", // <10>
    "database.history.kafka.topic": "dbhistory.fullfillment" // <11>
  }
}
----
<1> The name of the connector when registered with a Kafka Connect service.
<2> The name of this Db2 connector class.
<3> The address of the Db2 instance.
<4> The port number of the Db2 instance.
<5> The name of the Db2 user.
<6> The password for the Db2 user.
<7> The name of the database to capture changes from.
<8> The logical name of the Db2 instance/cluster, which forms a namespace and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the {link-prefix}:{link-avro-serialization}[Avro Connector] is used.
<9> A list of all tables whose changes {prodname} should capture.
<10> The list of Kafka brokers that this connector uses to write and recover DDL statements to the database history topic.
<11> The name of the database history topic where the connector writes and recovers DDL statements. This topic is for internal use only and should not be used by consumers.

ifdef::product[]

Following is an example of the configuration for a Db2 connector that connects to a Db2 server on port 50000 at 192.168.99.100, whose logical name is `fullfillment`. Typically, you configure a {prodname} Db2 connector in a `.yaml` file using the configuration properties available for the connector.

You can choose to produce events for a subset of the schemas and tables. Optionally, ignore, mask, or truncate columns that are sensitive, too large, or not needed.

[source,yaml,options="nowrap"]
----
apiVersion: kafka.strimzi.io/v1beta1
  kind: KafkaConnector
  metadata:
    name: inventory-connector  // <1>
    labels: strimzi.io/cluster: my-connect-cluster
  spec:
    class: io.debezium.connector.db2.Db2Connector
    tasksMax: 1  // <2>
    config:  // <3>
      database.hostname: 192.168.99.100   // <4>
      database.port: 50000
      database.user: db2inst1
      database.password: Password!
      database.dbname: mydatabase  
      database.server.name: fullfillment   // <5>
      database.whitelist: public.inventory   // <6>
----
<1> The name of the connector.
<2> Only one task should operate at any one time.
<3> The connectors configuration.
<4> The database host, which is the address of the Db2 instance. 
<5> The logical name of the Db2 instance/cluster, which forms a namespace and is used in the names of the Kafka topics to which the connector writes, the names of Kafka Connect schemas, and the namespaces of the corresponding Avro schema when the {link-prefix}:{link-avro-serialization}[Avro Connector] is used.
<6> Changes in only the `public.inventory` database are captured.

endif::product[]

See the {link-prefix}:{link-db2-connector}#db2-connector-properties[complete list of connector properties] that you can specify in these configurations.

You can send this configuration with a `POST` command to a running Kafka Connect service. The service records the configuration and starts one connector task that connects to the Db2 database, reads change-data tables for tables in capture mode, and streams change event records to Kafka topics.

// Type: procedure
// ModuleID: adding-debezium-db2-connector-configuration-to-kafka-connect
// Title: Adding {prodname} Db2 connector configuration to Kafka Connect
[[db2-adding-connector-configuration]]
=== Adding connector configuration

ifdef::community[]
To start running a Db2 connector, create a connector configuration file and add it to your Kafka Connect cluster. 

.Prerequisites

* The {link-prefix}:{link-db2-connector}#setting-up-db2-to-run-a-debezium-connector[Db2 CDC feature] is enabled to expose change-data for tables that are in capture mode

* The Db2 connector is installed. 

.Procedure

. Create a configuration file for the Db2 connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster. 

endif::community[]

ifdef::product[]
You can use a provided {prodname} container to deploy a {prodname} Db2 connector. In this procedure, you build a custom Kafka Connect container image for {prodname}, configure the {prodname} connector as needed, and then add your connector configuration to your Kafka Connect environment. 

.Prerequisites

* You have Podman installed and sufficient rights to create and manage containers.
* You installed the {prodname} Db2 connector archive. 

.Procedure

. Extract the {prodname} Db2 connector archive to create a directory structure for the connector plug-in, for example: 
+
[subs=+macros]
----
pass:quotes[*tree ./my-plugins/*]
./my-plugins/
 debezium-connector-db2
    ...
----

. Create and publish a custom image for running your {prodname} connector:

.. Create a new `Dockerfile` by using `{DockerKafkaConnect}` as the base image. In the following example, you would replace _my-plugins_ with the name of your plug-ins directory:
+
[subs=+macros]
----
FROM registry.redhat.io/amq7/amq-streams-kafka-25:1.5.0
USER root:root
pass:quotes[COPY _./my-plugins/_ /opt/kafka/plugins/]
USER 1001
----
+
Before Kafka Connect starts running the connector, Kafka Connect loads any third-party plug-ins that are in the `/opt/kafka/plugins` directory.

.. Build the docker container image. For example, if you saved the docker file that you created in the previous step as `debezium-container-for-db2`, then you would run the following command:
+
`podman build -t debezium-container-for-db2:latest`

.. Push your custom image to your container registry, for example:
+
`podman push debezium-container-for-db2:latest`

.. Point to the new container image. Do one of the following:
+
* Edit the `spec.image` property of the `KafkaConnector` custom resource. If set, this property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator. For example:
+
[source,yaml,subs=attributes+]
----
apiVersion: {KafkaConnectApiVersion}
kind: KafkaConnector
metadata:
  name: my-connect-cluster
spec:
  #...
  image: debezium-container-for-db2
----
+
* In the `install/cluster-operator/050-Deployment-strimzi-cluster-operator.yaml` file, edit the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable to point to the new container image and reinstall the Cluster Operator. If you edit this file you must apply it to your OpenShift cluster.

. Create a `KafkaConnector` custom resource that defines your {prodname} Db2 connector instance. See {LinkDebeziumUserGuide}#debezium-db2-connector-configuration-example[the connector configuration example].

. Apply the connector instance, for example: 
+
`oc apply -f inventory-connector.yaml`
+
This registers `inventory-connector` and the connector starts to run against the `inventory` database.

. Verify that the connector was created and has started to capture changes in the specified database. You can verify the connector instance by watching the Kafka Connect log output as, for example, `inventory-connector` starts.

.. Display the Kafka Connect log output:
+
[source,shell,options="nowrap"]
----
oc logs $(oc get pods -o name -l strimzi.io/name=my-connect-cluster-connect)
----

.. Review the log output to verify that the initial snapshot has been executed. You should see something like the following lines: 
+
[source,shell,options="nowrap"]
----
... INFO Starting snapshot for ...
... INFO Snapshot is using user 'debezium' ... 
----

endif::product[]

.Results

When the connector starts, it {link-prefix}:{link-db2-connector}#db2-snapshots[performs a consistent snapshot] of the Db2 database tables that the connector for which the connector is configured to capture changes. The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics. 

// Type: assembly
// ModuleID: monitoring-debezium-db2-connector-performance
// Title: Monitoring {prodname} Db2 connector performance
[[db2-monitoring]]
=== Monitoring

The {prodname} Db2 connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* {link-prefix}:{link-db2-connector}#db2-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot. 
* {link-prefix}:{link-db2-connector}#db2-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is capturing changes and streaming change event records. 
* {link-prefix}:{link-db2-connector}#db2-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history. 

{link-prefix}:{link-debezium-monitoring}[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.

// Type: reference
// ModuleID: monitoring-debezium-during-snapshots-of-db2-databases
// Title: Monitoring {prodname} during snapshots of Db2 databases
[[db2-monitoring-snapshots]]
[[db2-snapshot-metrics]]
==== Snapshot metrics

The *MBean* is `debezium.db2:type=connector-metrics,context=snapshot,server=_<database.server.name>_`.

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-snapshot-metrics.adoc[leveloffset=+1]

// Type: reference
// ModuleID: monitoring-debezium-db2-connector-record-streaming
// Title: Monitoring {prodname} Db2 connector record streaming
[[db2-monitoring-streaming]]
[[db2-streaming-metrics]]
==== Streaming metrics

The *MBean* is `debezium.db2:type=connector-metrics,context=streaming,server=_<database.server.name>_`.

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-streaming-metrics.adoc[leveloffset=+1]

// Type: reference
// ModuleID: monitoring-debezium-db2-connector-schema history
// Title: Monitoring {prodname} Db2 connector schema history
[[db2-monitoring-schema-history]]
[[db2-schema-history-metrics]]
==== Schema history metrics

The *MBean* is `debezium.db2:type=connector-metrics,context=schema-history,server=_<database.server.name>_`.

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-schema-history-metrics.adoc[leveloffset=+1]

// Type: reference
// ModuleID: descriptions-of-debezium-db2-connector-configuration-properties
// Title: Description of {prodname} Db2 connector configuration properties
[[db2-connector-properties]]
=== Connector properties

The {prodname} Db2 connector has many configuration properties that you can use to achieve the right connector behavior for your application. Many properties have default values. Information about the properties is organized as follows: 

* xref:db2-required-configuration-properties[Required configuration properties]
* xref:db2-advanced-configuration-properties[Advanced configuration properties]
* xref:db2-pass-through-properties[Pass-through configuration properties]

[id="db2-required-configuration-properties"]
The following configuration properties are _required_ unless a default value is available.

.Required connector configuration properties
[cols="30%a,25%a,45%a",options="header"]
|===
|Property |Default |Description

|[[db2-property-name]]<<db2-property-name, `name`>>
|
|Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)

|[[db2-property-connector-class]]<<db2-property-connector-class, `connector.class`>>
|
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.db2.Db2Connector` for the Db2 connector.

|[[db2-property-tasks-max]]<<db2-property-tasks-max, `tasks.max`>>
|`1`
|The maximum number of tasks that should be created for this connector. The Db2 connector always uses a single task and therefore does not use this value, so the default is always acceptable.

|[[db2-property-database-hostname]]<<db2-property-database-hostname, `database.hostname`>>
|
|IP address or hostname of the Db2 database server.

|[[db2-property-database-port]]<<db2-property-database-port, `database.port`>>
|`50000`
|Integer port number of the Db2 database server.

|[[db2-property-database-user]]<<db2-property-database-user, `database.user`>>
|
|Username to use when connecting to the Db2 database server.

|[[db2-property-database-password]]<<db2-property-database-password, `database.password`>>
|
|Password to use when connecting to the Db2 database server.

|[[db2-property-database-dbname]]<<db2-property-database-dbname, `database.dbname`>>
|
|The name of the Db2 database from which to stream the changes

|[[db2-property-database-server-name]]<<db2-property-database-server-name, `database.server.name`>>
|
|Logical name that identifies and provides a namespace for the particular Db2 database server being monitored. The logical name should be unique across all other connectors, since it is used as a prefix for all Kafka topic names emanating from this connector.
Only alphanumeric characters and underscores should be used.

|[[db2-property-database-history-kafka-topic]]<<db2-property-database-history-kafka-topic, `database.history.kafka.topic`>>
|
|The full name of the Kafka topic where the connector will store the database schema history.

|[[db2-property-database-history-kafka-bootstrap-servers]]<<db2-property-database-history-kafka-bootstrap-servers, `database.history{zwsp}.kafka.bootstrap.servers`>>
|
|A list of host/port pairs that the connector will use for establishing an initial connection to the Kafka cluster. This connection will be used for retrieving database schema history previously stored by the connector, and for writing each DDL statement read from the source database. This should point to the same Kafka cluster used by the Kafka Connect process.

|[[db2-property-table-whitelist]]<<db2-property-table-whitelist, `table.whitelist`>>
|
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be monitored; any table not included in the whitelist will be excluded from monitoring. Each identifier is of the form _schemaName_._tableName_. By default the connector will monitor every non-system table in each monitored schema. May not be used with `table.blacklist`.

|[[db2-property-table-blacklist]]<<db2-property-table-blacklist, `table.blacklist`>>
|
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be excluded from monitoring; any table not included in the blacklist will be monitored. Each identifier is of the form _schemaName_._tableName_. May not be used with `table.whitelist`.

|[[db2-property-column-blacklist]]<<db2-property-column-blacklist, `column.blacklist`>>
|_empty string_
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns that should be excluded from change event message values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.
Note that primary key columns are always included in the event's key, also if blacklisted from the value.

|[[db2-property-column-mask-hash]]<<db2-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
|An optional comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be pseudonyms in the change event message values with a field value consisting of the hashed value using the algorithm `_hashAlgorithm_` and salt `_salt_`.
Based on the used hash function referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.
The hash is automatically shortened to the length of the column.

Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.

Example:

    column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName

where `CzQMA0cB5K` is a randomly selected salt.

Note: Depending on the `_hashAlgorithm_` used, the `_salt_` selected and the actual data set, the resulting masked data set may not be completely anonymized.

|[[db2-property-time-precision-mode]]<<db2-property-time-precision-mode, `time.precision.mode`>>
|`adaptive`
| Time, date, and timestamps can be represented with different kinds of precision, including: `adaptive` (the default) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type; or `connect` always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision. See {link-prefix}:{link-db2-connector}#db2-temporal-values[temporal values].

|[[db2-property-tombstones-on-delete]]<<db2-property-tombstones-on-delete, `tombstones.on.delete`>>
|`true`
| Controls whether a tombstone event should be generated after a delete event. +
When `true` the delete operations are represented by a delete event and a subsequent tombstone event. When `false` only a delete event is sent. +
Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.

|[[db2-property-column-truncate-to-length-chars]]<<db2-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|_n/a_
|An optional comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be truncated in the change event message values if the field values are longer than the specified number of characters. Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer. Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.

|[[db2-property-column-mask-with-length-chars]]<<db2-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|_n/a_
|An optional comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be replaced in the change event message values with a field value consisting of the specified number of asterisk (`*`) characters. Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.

|[[db2-property-column-propagate-source-type]]<<db2-property-column-propagate-source-type, `column.propagate.source.type`>>
|_n/a_
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change messages.
The schema parameters `pass:[_]pass:[_]debezium.source.column.type`, `pass:[_]pass:[_]debezium.source.column.length` and `pass:[_]pass:[_]debezium.source.column.scale` will be used to propagate the original type name and length (for variable-width types), respectively.
Useful to properly size corresponding columns in sink databases.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.

|[[db2-property-datatype-propagate-source-type]]<<db2-property-datatype-propagate-source-type, `datatype.propagate.source.type`>>
|_n/a_
|An optional comma-separated list of regular expressions that match the database-specific data type name of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change messages.
The schema parameters `pass:[_]pass:[_]debezium.source.column.type`, `pass:[_]pass:[_]debezium.source.column.length` and `pass:[_]pass:[_]debezium.source.column.scale` will be used to propagate the original type name and length (for variable-width types), respectively.
Useful to properly size corresponding columns in sink databases.
Fully-qualified data type names are of the form _schemaName_._tableName_._typeName_.
See {link-prefix}:{link-db2-connector}#db2-data-types[Db2 data types] for the list of Db2-specific data type names.

|[[db2-property-message-key-columns]]<<db2-property-message-key-columns, `message.key.columns`>>
|_empty string_
| A semi-colon list of regular expressions that match fully-qualified tables and columns to map a primary key. +
Each item (regular expression) must match the fully-qualified `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +
Fully-qualified tables could be defined as _schemaName_._tableName_.
|===

[id="db2-advanced-configuration-properties"]
The following _advanced_ configuration properties have defaults that work in most situations and therefore rarely need to be specified in the connector's configuration.

.Advanced connector configuration properties
[cols="30%a,25%a,45%a",options="header"]
|===
|Property |Default |Description

|[[db2-property-snapshot-mode]]<<db2-property-snapshot-mode, `snapshot.mode`>>
|_initial_
|A mode for taking an initial snapshot of the structure and optionally data of captured tables. Supported values are _initial_ (will take a snapshot of structure and data of captured tables; useful if topics should be populated with a complete representation of the data from the captured tables) and _schema_only_ (will take a snapshot of the structure of captured tables only; useful if only changes happening from now onwards should be propagated to topics). Once the snapshot is complete, the connector will continue reading change events from the database's redo logs.

|[[db2-property-snapshot-isolation-mode]]<<db2-property-snapshot-isolation-mode, `snapshot.isolation.mode`>>
|_repeatable_read_
|Mode to control which transaction isolation level is used and how long the connector locks the monitored tables.
There are four possible values: `read_uncommitted`, `read_committed`, `repeatable_read`, and `exclusive` (
in fact, `exclusive` mode uses repeatable read isolation level, however, it takes the exclusive lock on all tables
to be read). +

It is worth documenting that `read_committed` and `read_uncommitted` modes do not prevent other
transactions from updating table rows during initial snapshot, while `exclusive` and `repeatable_read` do. +

Another aspect is data consistency. Only the `exclusive` mode guarantees full consistency, that is, initial
snapshot and streaming logs constitute a linear history.
In case of `repeatable_read` and `read_committed` modes, it might happen that, for instance, a record added appears
twice - once in initial snapshot and once in streaming phase. Nonetheless, that consistency level should do for
data mirroring.
For `read_uncommitted` there are no data consistency guarantees at all (some data might be lost or corrupted).

|[[db2-property-event-processing-failure-handling-mode]]<<db2-property-event-processing-failure-handling-mode, `event.processing{zwsp}.failure.handling.mode`>>
|`fail`
| Specifies how the connector should react to exceptions during processing of events.
`fail` will propagate the exception (indicating the offset of the problematic event), causing the connector to stop. +
`warn` will cause the problematic event to be skipped and the offset of the problematic event to be logged. +
`skip` will cause the problematic event to be skipped.

|[[db2-property-poll-interval-ms]]<<db2-property-poll-interval-ms, `poll.interval.ms`>>
|`1000`
|Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear. Defaults to 1000 milliseconds, or 1 second.

|[[db2-property-max-queue-size]]<<db2-property-max-queue-size, `max.queue.size`>>
|`8192`
|Positive integer value that specifies the maximum size of the blocking queue into which change events read from the database log are placed before they are written to Kafka. This queue can provide backpressure to the change-data table reader when, for example, writes to Kafka are slower or if Kafka is not available. Events that appear in the queue are not included in the offsets periodically recorded by this connector. Defaults to 8192, and should always be larger than the maximum batch size specified in the `max.batch.size` property.

|[[db2-property-max-batch-size]]<<db2-property-max-batch-size, `max.batch.size`>>
|`2048`
|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.

|[[db2-property-heartbeat-interval-ms]]<<db2-property-heartbeat-interval-ms, `heartbeat.interval.ms`>>
|`0`
|Controls how frequently heartbeat messages are sent. +
This property contains an interval in milli-seconds that defines how frequently the connector sends messages into a heartbeat topic.
This can be used to monitor whether the connector is still receiving change events from the database.
You also should leverage heartbeat messages in cases where only records in non-captured tables are changed for a longer period of time.
In such situation the connector would proceed to read the log from the database but never emit any change messages into Kafka,
which in turn means that no offset updates will be committed to Kafka.
This may result in more change events to be re-sent after a connector restart.
Set this parameter to `0` to not send heartbeat messages at all. +
Disabled by default.

|[[db2-property-heartbeat-topics-prefix]]<<db2-property-heartbeat-topics-prefix, `heartbeat.topics.prefix`>>
|`__debezium-heartbeat`
|Controls the naming of the topic to which heartbeat messages are sent. +
The topic is named according to the pattern `<heartbeat.topics.prefix>.<server.name>`.

|[[db2-property-snapshot-delay-ms]]<<db2-property-snapshot-delay-ms, `snapshot.delay.ms`>>
|
|An interval in milli-seconds that the connector should wait before taking a snapshot after starting up; +
Can be used to avoid snapshot interruptions when starting multiple connectors in a cluster, which may cause re-balancing of connectors.

|[[db2-property-snapshot-fetch-size]]<<db2-property-snapshot-fetch-size, `snapshot.fetch.size`>>
|`2000`
|Specifies the maximum number of rows that should be read in one go from each table while taking a snapshot.
The connector will read the table contents in multiple batches of this size. Defaults to 2000.

|[[db2-property-snapshot-lock-timeout-ms]]<<db2-property-snapshot-lock-timeout-ms, `snapshot.lock.timeout.ms`>>
|`10000`
|An integer value that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If table locks cannot be acquired in this time interval, the snapshot will fail (also see {link-prefix}:{link-db2-connector}#db2-snapshots[snapshots]). +
When set to `0` the connector will fail immediately when it cannot obtain the lock. Value `-1` indicates infinite waiting.

|[[db2-property-snapshot-select-statement-overrides]]<<db2-property-snapshot-select-statement-overrides, `snapshot.select.statement.overrides`>>
|
|Controls which rows from tables will be included in snapshot. +
This property contains a comma-separated list of fully-qualified tables _(SCHEMA_NAME.TABLE_NAME)_. Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id `snapshot.select.statement.overrides.[SCHEMA_NAME].[TABLE_NAME]`. The value of those properties is the SELECT statement to use when retrieving data from the specific table during snapshotting. _A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted._ +
*Note*: This setting has impact on snapshots only. Events captured during log reading are not affected by it.

|[[db2-property-sanitize-field-names]]<<db2-property-sanitize-field-names, `sanitize.field.names`>>
|`true` when connector configuration explicitly specifies the `key.converter` or `value.converter` parameters to use Avro, otherwise defaults to `false`.
|Whether field names will be sanitized to adhere to Avro naming requirements.
See {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming] for more details.

|[[db2-property-provide-transaction-metadata]]<<db2-property-provide-transaction-metadata, `provide.transaction.metadata`>>
|`false`
|When set to `true` {prodname} generates events with transaction boundaries and enriches data events envelope with transaction metadata.

See {link-prefix}:{link-db2-connector}#db2-transaction-metadata[Transaction Metadata] for additional details.
|===

[id="db2-pass-through-properties"]
.Pass-through connector configuration properties

The connector also supports _pass-through_ configuration properties that are used when creating the Kafka producer and consumer. Specifically, all connector configuration properties that begin with the `database.history.producer.` prefix are used (without the prefix) when creating the Kafka producer that writes to the database history, and all those that begin with the prefix `database.history.consumer.` are used (without the prefix) when creating the Kafka consumer that reads the database history upon connector startup.

For example, the following connector configuration properties can be used to {link-kafka-docs}.html#security_configclients[secure connections to the Kafka broker]:

In addition to the _pass-through_ to the Kafka producer and consumer, the properties starting with `database.`, e.g. `database.applicationName=debezium` are passed to the JDBC URL.

[source,indent=0]
----
database.history.producer.security.protocol=SSL
database.history.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
database.history.producer.ssl.keystore.password=test1234
database.history.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
database.history.producer.ssl.truststore.password=test1234
database.history.producer.ssl.key.password=test1234
database.history.consumer.security.protocol=SSL
database.history.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
database.history.consumer.ssl.keystore.password=test1234
database.history.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
database.history.consumer.ssl.truststore.password=test1234
database.history.consumer.ssl.key.password=test1234
----

Be sure to consult the {link-kafka-docs}.html[Kafka documentation] for all of the configuration properties for Kafka producers and consumers. (The Db2 connector does use the {link-kafka-docs}.html#newconsumerconfigs[new consumer].)
