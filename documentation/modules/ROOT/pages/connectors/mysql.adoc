// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-mysql"]
= {prodname} connector for MySQL

:context: mysql
:data-collection: table
:mbean-name: {context}
:connector-file: {context}
:connector-class: MySql
:connector-name: MySQL
ifdef::community[]
:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]
endif::community[]

MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.

The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.

As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.

ifdef::community[]
For information about the MySQL Database versions that are compatible with this connector, see the link:https://debezium.io/releases/[{prodname} release overview].
endif::community[]
ifdef::product[]
For information about the MySQL Database versions that are compatible with this connector, see the link:{LinkDebeziumSupportedConfigurations}[{NameDebeziumSupportedConfigurations}].
endif::product[]

ifdef::product[]
Information and procedures for using a {prodname} MySQL connector are organized as follows:

* xref:how-debezium-mysql-connectors-work[]
* xref:descriptions-of-debezium-mysql-connector-data-change-events[]
* xref:how-debezium-mysql-connectors-map-data-types[]
* xref:setting-up-mysql-to-run-a-debezium-connector[]
* xref:deployment-of-debezium-mysql-connectors[]
* xref:monitoring-debezium-mysql-connector-performance[]
* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]

endif::product[]

// Type: assembly
// ModuleID: how-debezium-mysql-connectors-work
// Title: How {prodname} MySQL connectors work
[[how-the-mysql-connector-works]]
== How the connector works

An overview of the MySQL topologies that the connector supports is useful for planning your application. To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names.

ifdef::community[]
[NOTE]
====
The {prodname} MySQL connector has yet to be tested with MariaDB, but multiple reports from the community indicate successful usage of the connector with this database.
Official support for MariaDB is planned for a future {prodname} version.
====
endif::community[]

ifdef::product[]
Details are in the following topics:

* xref:mysql-topologies-supported-by-debezium-connectors[]
* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]
* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]
* xref:how-debezium-mysql-connectors-perform-database-snapshots[]
* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]

endif::product[]


// Type: concept
// ModuleID: mysql-topologies-supported-by-debezium-connectors
// Title: MySQL topologies supported by {prodname} connectors
[id="supported-mysql-topologies"]
=== Supported MySQL topologies

The {prodname} MySQL connector supports the following MySQL topologies:

Standalone::
When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.

Primary and replica::
The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.
+
The connector records its position in the server’s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.

High available clusters::
A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.

Multi-primary::
link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.
+
A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.

Hosted::
There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.
+
Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.

// Type: concept
// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes
// Title: How {prodname} MySQL connectors handle database schema changes
[[mysql-schema-history-topic]]
=== Schema history topic

When a database client queries a database, the client uses the database’s current schema.
However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded.
Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old that were recorded before the tables' schemas were changed.

To ensure correct processing of changes that occur after a schema change, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database.
As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table’s schema.
The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event.
In a separate database schema history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.

When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time.
The connector rebuilds the table structures that existed at this point in time by reading the database schema history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.

This database schema history topic is for connector use only.
The connector can optionally xref:mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].

When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied, there are helper tables created during the migration process.
The connector needs to be configured to capture change to these helper tables.
If consumers do not need the records generated for helper tables, then a single message transform can be applied to filter them out.

See xref:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.

// Type: concept
// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes
// Title: How {prodname} MySQL connectors expose database schema changes
[id="mysql-schema-change-topic"]
=== Schema change topic

You can configure a {prodname} MySQL connector to produce schema change events that describe schema changes that are applied to captured tables in the database.
The connector writes schema change events to a Kafka topic named `_<topicPrefix>_`, where `_topicPrefix_` is the namespace specified in the xref:mysql-property-topic-prefix[`topic.prefix`] connector configuration property.
Messages that the connector sends to the schema change topic contain a payload, and, optionally, also contain the schema of the change event message.

The payload of a schema change event message includes the following elements:

`ddl`:: Provides the SQL `CREATE`, `ALTER`, or `DROP` statement that results in the schema change.
`databaseName`:: The name of the database to which the DDL statements are applied.
The value of `databaseName` serves as the message key.
`pos`:: The position in the binlog where the statements appear.
`tableChanges`::  A structured representation of the entire table schema after the schema change.
The `tableChanges` field contains an array that includes entries for each column of the table.
Because the structured representation presents data in JSON or Avro format, consumers can easily read messages without first processing them through a DDL parser.

[IMPORTANT]
====
For a table that is in capture mode, the connector not only stores the history of schema changes in the schema change topic, but also in an internal database schema history topic.
The internal database schema history topic is for connector use only and it is not intended for direct use by consuming applications.
Ensure that applications that require notifications about schema changes consume that information only from the schema change topic.
====

[IMPORTANT]
====
Never partition the database schema history topic.
For the database schema history topic to function correctly, it must maintain a consistent, global order of the event records that the connector emits to it.

To ensure that the topic is not split among partitions, set the partition count for the topic by using one of the following methods:

* If you create the database schema history topic manually, specify a partition count of `1`.
* If you use the Apache Kafka broker to create the database schema history topic automatically, the topic is created, set the value of the link:{link-kafka-docs}/#brokerconfigs_num.partitions[Kafka `num.partitions`] configuration option to `1`.
====

[WARNING]
====
The format of the messages that a connector emits to its schema change topic is in an incubating state and is subject to change without notice.
====

.Example: Message emitted to the MySQL connector schema change topic
The following example shows a typical schema change message in JSON format.
The message contains a logical representation of the table schema.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { },
  "payload": {
      "source": {  <1>
        "version": "{debezium-version}",
        "connector": "mysql",
        "name": "mysql",
        "ts_ms": 1651535750218, <2>
        "snapshot": "false",
        "db": "inventory",
        "sequence": null,
        "table": "customers",
        "server_id": 223344,
        "gtid": null,
        "file": "mysql-bin.000003",
        "pos": 570,
        "row": 0,
        "thread": null,
        "query": null
      },
      "databaseName": "inventory", <3>
      "schemaName": null,
      "ddl": "ALTER TABLE customers ADD middle_name varchar(255) AFTER first_name", <4>
      "tableChanges": [  <5>
        {
          "type": "ALTER", <6>
          "id": "\"inventory\".\"customers\"", <7>
          "table": {    <8>
            "defaultCharsetName": "utf8mb4",
            "primaryKeyColumnNames": [  <9>
              "id"
            ],
            "columns": [  <10>
              {
                "name": "id",
                "jdbcType": 4,
                "nativeType": null,
                "typeName": "INT",
                "typeExpression": "INT",
                "charsetName": null,
                "length": null,
                "scale": null,
                "position": 1,
                "optional": false,
                "autoIncremented": true,
                "generated": true
              },
              {
                "name": "first_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 2,
                "optional": false,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "middle_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 3,
                "optional": true,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "last_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 4,
                "optional": false,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "email",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 5,
                "optional": false,
                "autoIncremented": false,
                "generated": false
            }
          ],
          "attributes": [ <11>
            {
              "customAttribute": "attributeValue"
            }
          ]
        }
      }
    ]
  }
}

----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,4,5",options="header"]
|===
|Item |Field name |Description

|1
|`source`
|The `source` field is structured exactly as standard data change events that the connector writes to table-specific topics.
This field is useful to correlate events on different topics.

|2
|`ts_ms`
|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.

In the source object, ts_ms indicates the time that the change was made in the database. By comparing the value for payload.source.ts_ms with the value for payload.ts_ms, you can determine the lag between the source database update and Debezium.

|3
|`databaseName` +
`schemaName`
|Identifies the database and the schema that contains the change.
The value of the `databaseName` field is used as the message key for the record.

|4
|`ddl`
|This field contains the DDL that is responsible for the schema change.
The `ddl` field can contain multiple DDL statements.
Each statement applies to the database in the `databaseName` field.
Multiple DDL statements appear in the order in which they were applied to the database. +
 +
Clients can submit multiple DDL statements that apply to multiple databases.
If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group.
If MySQL applies them individually, the connector creates a separate schema change event for each statement.

|5
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|6
|`type`
a|Describes the kind of change. The value is one of the following:

`CREATE`:: Table created.
`ALTER`:: Table modified.
`DROP`:: Table deleted.

|7
|`id`
|Full identifier of the table that was created, altered, or dropped.
In the case of a table rename, this identifier is a concatenation of `_<old>_,_<new>_` table names.

|8
|`table`
|Represents table metadata after the applied change.

|9
|`primaryKeyColumnNames`
|List of columns that compose the table's primary key.

|10
|`columns`
|Metadata for each column in the changed table.

|11
|`attributes`
|Custom attribute metadata for each table change.

|===

See also: xref:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].

// Type: concept
// Title: How {prodname} MySQL connectors perform database snapshots
// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots
[[mysql-snapshots]]
=== Snapshots

When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the xref:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].

.Workflow for performing an initial snapshot with a global read lock
[cols="1,9",options="header",subs="+attributes"]
|===
|Step |Action

|1
a| Grabs a global read lock that blocks _writes_ by other database clients. +
 +
The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.

|2
a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.

|3
a|Reads the current binlog position.

|4
a|Reads the schema of the databases and tables for which the connector is configured to capture changes.

|5
a|Releases the global read lock. Other database clients can now write to the database.

|6
a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.

|7
a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.

|8
a|Commits the transaction.

|9
a|Records the completed snapshot in the connector offsets.

|===

Connector restarts::
If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.
+
If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see xref:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].

Global read locks not allowed::
Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK TABLES` privileges.
+
.Workflow for performing an initial snapshot with table-level locks
[cols="1,9",options="header",subs="+attributes"]
|===
|Step |Action

|1
|Obtains table-level locks.

|2
a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.

|3
|Reads and filters the names of the databases and tables.

|4
a|Reads the current binlog position.

|5
a|Reads the schema of the databases and tables for which the connector is configured to capture changes.

|6
a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.

|7
a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.

|8
a|Commits the transaction.

|9
|Releases the table-level locks.

|10
a|Records the completed snapshot in the connector offsets.

|===

// Type: concept
// ModuleID: debezium-mysql-ad-hoc-snapshots
[id="mysql-ad-hoc-snapshots"]
==== Ad hoc snapshots
include::{partialsdir}/modules/all-connectors/con-connector-ad-hoc-snapshots.adoc[leveloffset=+3]



// Type: concept
[id="mysql-incremental-snapshots"]
==== Incremental snapshots
include::{partialsdir}/modules/all-connectors/con-connector-incremental-snapshot.adoc[leveloffset=+3]

// Type: procedure
[id="mysql-triggering-an-incremental-snapshot"]
==== Triggering an incremental snapshot

include::{partialsdir}/modules/all-connectors/proc-triggering-an-incremental-snapshot.adoc[leveloffset=+3,tags=!nosql-based-snapshot]

// Type: procedure
[id="mysql-stopping-an-incremental-snapshot"]
==== Stopping an incremental snapshot

include::{partialsdir}/modules/all-connectors/proc-stopping-an-incremental-snapshot.adoc[leveloffset=+3,tags=!nosql-based-snapshot]

ifdef::community[]
[id="mysql-read-only-incremental-snapshots"]
==== Read-only incremental snapshots

The MySQL connector allows for running incremental snapshots with a read-only connection to the database.
To run an incremental snapshot with read-only access, the connector uses the executed global transaction IDs (GTID) set as high and low watermarks.
The state of a chunk's window is updated by comparing the GTIDs of binary log (binlog) events or the server's heartbeats against low and high watermarks.

To switch to a read-only implementation, set the value of the xref:{link-mysql-connector}#mysql-property-read-only[`read.only`] property to `true`.

.Prerequisites

* xref:enable-mysql-gtids[Enable MySQL GTIDs].
* If the connector reads from a multi-threaded replica (that is, a replica for which the value of `replica_parallel_workers` is greater than `0`)
you must set one of the following options:

** `replica_preserve_commit_order=ON`
** `slave_preserve_commit_order=ON`

==== Ad hoc read-only incremental snapshots

When the MySQL connection is read-only, the xref:{link-signalling}[signaling table] mechanism can also run a snapshot by sending a message to the Kafka topic that is specified in
the xref:{link-mysql-connector}#mysql-property-signal-kafka-topic[signal.kafka.topic] property.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value is a JSON object with `type` and `data` fields.

The signal type is `execute-snapshot` and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed. Currently only `incremental` is supported. +
See the next section for more details.

|`data-collections`
|_N/A_
| An array of comma-separated regular expressions that match fully-qualified names of tables to be snapshotted. +
The format of the names is the same as for xref:#{context}-property-signal-data-collection[signal.data.collection] configuration option.

|`additional-condition`
|_N/A_
| An optional string, which specifies a condition based on the column(s) of the {data-collection}(s), to capture a
subset of the contents of the {data-collection}(s).
|===

An example of the execute-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

==== Ad hoc read-only incremental snapshots with additional-condition

* `additional-condition` is used to select a subset of a {data-collection}'s content.

* To give an analogy how `additional-condition` is used:

** For a snapshot, the SQL query executed behind the scenes is something like:
+
SELECT * FROM _<tableName>_ ....

** For a snapshot with a `additional-condition`, the `additional-condition` is appended to the SQL query, something like:
+
SELECT * FROM _<tableName>_ WHERE _<additional-condition>_ ....

* Suppose there is a `products` {data-collection} with columns `id` (primary key), `color` and `brand`.
+
To snapshot just the content of the `products` {data-collection} where `color=blue`
+
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-condition":"color=blue"}}`
----

* `additional-condition` can be used to pass condition based on multiple columns.
Using the same `products` {data-collection}, to snapshot content of the `products` {data-collection} where `color=blue` and `brand=foo`
+
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-condition":"color=blue AND brand=foo"}}`
----

==== Stopping an Ad hoc read-only incremental snapshot

When the MySQL connection is read-only, the xref:{link-signalling}[signaling table] mechanism can also stop a snapshot by sending a message to the Kafka topic that is specified in
the xref:{link-mysql-connector}#mysql-property-signal-kafka-topic[signal.kafka.topic] property.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value is a JSON object with `type` and `data` fields.

The signal type is `stop-snapshot` and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed. Currently only `incremental` is supported. +
See the next section for more details.

|`data-collections`
|_N/A_
| An optional array of comma-separated regular expressions that match fully-qualified names of tables to be snapshotted. +
The format of the names is the same as for xref:#{context}-property-signal-data-collection[signal.data.collection] configuration option.

|===

An example of the stop-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

// Type: continue
[id="mysql-snapshot-events"]
=== Operation type of snapshot events

The MySQL connector emits snapshot events as `READ` operations `("op" : "r")`.
If you prefer that the connector emits snapshot events as `CREATE` (`c`) events, configure the {prodname} `ReadToInsertEvent` single message transform (SMT) to modify the event type.

The following example shows how to configure the SMT:

.Example: Using the `ReadToInsertEvent` SMT to change the type of snapshot events
----
transforms=snapshotasinsert,...
transforms.snapshotasinsert.type=io.debezium.connector.mysql.transforms.ReadToInsertEvent
----
endif::community[]

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records
// Title: Default names of Kafka topics that receive {prodname} MySQL change event records
[[mysql-topic-names]]
=== Topic names

By default, the MySQL connector writes change events for all of the `INSERT`, `UPDATE`, and `DELETE` operations that occur in a table to a single Apache Kafka topic that is specific to that table.

The connector uses the following convention to name change event topics:

_topicPrefix.databaseName.tableName_

Suppose that `fulfillment` is the topic prefix, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`.
The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:

----
fulfillment.inventory.orders
fulfillment.inventory.customers
fulfillment.inventory.products
----

The following list provides definitions for the components of the default name:

_topicPrefix_:: The topic prefix as specified by the xref:mysql-property-topic-prefix[`topic.prefix`] connector configuration property.

_schemaName_:: The name of the schema in which the operation occurred.

_tableName_:: The name of the table in which the operation occurred.

The connector applies similar naming conventions to label its internal database schema history topics, xref:mysql-schema-change-topic[schema change topics], and xref:mysql-transaction-metadata[transaction metadata topics].

If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see xref:{link-topic-routing}#topic-routing[Topic routing].

[[mysql-transaction-metadata]]
=== Transaction metadata

{prodname} can generate events that represent transaction boundaries and that enrich data change event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

{prodname} generates transaction boundary events for the `BEGIN` and `END` delimiters in every transaction.
Transaction boundary events contain the following fields:

`status`:: `BEGIN` or `END`.
`id`:: String representation of the unique transaction identifier.
`ts_ms`:: The time of a transaction boundary event (`BEGIN` or `END` event) at the data source.
If the data source does not provide {prodname} with the event time, then the field instead represents the time at which {prodname} processes the event.
`event_count` (for `END` events):: Total number of events emitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` elements that indicates the number of events that the connector emits for changes that originate from a data collection.

.Example

[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
  "ts_ms": 1486500577125,
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
  "ts_ms": 1486500577691,
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "s1.a",
      "event_count": 1
    },
    {
      "data_collection": "s2.a",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:mysql-property-topic-transaction[`topic.transaction`] option,
the connector emits transaction events to the xref:mysql-property-topic-prefix[`_<topic.prefix>_`]`.transaction` topic.

.Change data event enrichment

When transaction metadata is enabled the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier.
`total_order`:: The absolute position of the event among all events generated by the transaction.
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction.

Following is an example of a message:

[source,json,indent=0,subs="+attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "transaction": {
    "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

For systems which don't have GTID enabled, the transaction identifier is constructed using the combination of binlog filename and binlog position. For example, if the binlog filename and position corresponding to the transaction BEGIN event are mysql-bin.000002 and 1913 respectively then the {prodname} constructed transaction identifier would be `file=mysql-bin.000002,pos=1913`.

// Type: assembly
// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events
// Title: Descriptions of {prodname} MySQL connector data change events
[[mysql-events]]
== Data change events

The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { //<1>
   ...
  },
 "payload": { //<2>
   ...
 },
 "schema": { //<3>
   ...
 },
 "payload": { //<4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +
 +
It is possible to override the table's primary key by setting the xref:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.

|===

By default, the connector streams change event records to topics with names that are the same as the event's originating table. See xref:{link-mysql-connector}#mysql-topic-names[topic names].

[WARNING]
====
The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.
====

ifdef::product[]
More details are in the following topics:

* xref:about-keys-in-debezium-mysql-change-events[]
* xref:about-values-in-debezium-mysql-change-events[]
endif::product[]

// Type: concept
// ModuleID: about-keys-in-debezium-mysql-change-events
// Title: About keys in {prodname} MySQL change events
[[mysql-change-event-keys]]
=== Change event keys

A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.

Consider the following `customers` table, which is followed by an example of a change event key for this table.

[source,sql]
----
CREATE TABLE customers (
  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE KEY
) AUTO_INCREMENT=1001;
----

Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:

[source,json,index=0]
----
{
 "schema": { <1>
    "type": "struct",
    "name": "mysql-server-1.inventory.customers.Key", <2>
    "optional": false, <3>
    "fields": [ <4>
      {
        "field": "id",
        "type": "int32",
        "optional": false
      }
    ]
  },
 "payload": { <5>
    "id": 1001
  }
}
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`mysql-server-1.inventory.customers.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: +

* `mysql-server-1` is the name of the connector that generated this event. +
* `inventory` is the database that contains the table that was changed. +
* `customers` is the table that was updated.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.

|4
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.

|5
|`payload`
|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.

|===

// Type: concept
// ModuleID: about-values-in-debezium-mysql-change-events
// Title: About values in {prodname} MySQL change events
[[mysql-change-event-values]]
=== Change event values

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample table that was used to show an example of a change event key:

[source,sql]
----
CREATE TABLE customers (
  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE KEY
) AUTO_INCREMENT=1001;
----

The value portion of a change event for a change to this table is described for:

* <<mysql-create-events,_create_ events>>
* <<mysql-update-events,_update_ events>>
* <<mysql-primary-key-updates,Primary key updates>>
* <<mysql-delete-events,_delete_ events>>
* <<mysql-tombstone-events,Tombstone events>>
* <<mysql-truncate-events,_truncate_ events>>

// Type: continue
[id="mysql-create-events"]
=== _create_ events

The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { // <1>
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "mysql-server-1.inventory.customers.Value", // <2>
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "mysql-server-1.inventory.customers.Value",
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": true,
            "field": "table"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "server_id"
          },
          {
            "type": "string",
            "optional": true,
            "field": "gtid"
          },
          {
            "type": "string",
            "optional": false,
            "field": "file"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "pos"
          },
          {
            "type": "int32",
            "optional": false,
            "field": "row"
          },
          {
            "type": "int64",
            "optional": true,
            "field": "thread"
          },
          {
            "type": "string",
            "optional": true,
            "field": "query"
          }
        ],
        "optional": false,
        "name": "io.debezium.connector.mysql.Source", // <3>
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      }
    ],
    "optional": false,
    "name": "mysql-server-1.inventory.customers.Envelope" // <4>
  },
  "payload": { // <5>
    "op": "c", // <6>
    "ts_ms": 1465491411815, // <7>
    "before": null, // <8>
    "after": { // <9>
      "id": 1004,
      "first_name": "Anne",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "source": { // <10>
      "version": "{debezium-version}",
      "connector": "mysql",
      "name": "mysql-server-1",
      "ts_ms": 0,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 0,
      "gtid": null,
      "file": "mysql-bin.000003",
      "pos": 154,
      "row": 0,
      "thread": 7,
      "query": "INSERT INTO customers (first_name, last_name, email) VALUES ('Anne', 'Kretchmar', 'annek@noanswer.org')"
    }
  }
}
----

.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +
 +
`mysql-server-1.inventory.customers.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. +
 +
Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database.
This means that when using the xref:{link-avro-serialization}#avro-serialization[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.

|3
|`name`
|`io.debezium.connector.mysql.Source` is the schema for the payload's `source` field. This schema is specific to the MySQL connector. The connector uses it for all events that it generates.

|4
|`name`
|`mysql-server-1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `mysql-server-1` is the connector name, `inventory` is the database, and `customers` is the table.

|5
|`payload`
|The value's actual data. This is the information that the change event is providing. +
 +
It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.
However, by using the xref:{link-avro-serialization}#avro-serialization[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|6
|`op`
a| Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)

|7
|`ts_ms`
a| Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|8
|`before`
| An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content.

|9
|`after`
| An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.

|10
|`source`
a| Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the new row
* ID of the MySQL thread that created the event (non-snapshot only)
* MySQL server ID (if available)
* Timestamp for when the change was made in the database

If the xref:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.

|===

// Type: continue
[id="mysql-update-events"]
=== _update_ events

The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": { // <1>
      "id": 1004,
      "first_name": "Anne",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "after": { // <2>
      "id": 1004,
      "first_name": "Anne Marie",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "source": { // <3>
      "version": "{debezium-version}",
      "name": "mysql-server-1",
      "connector": "mysql",
      "name": "mysql-server-1",
      "ts_ms": 1465581029100,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 223344,
      "gtid": null,
      "file": "mysql-bin.000003",
      "pos": 484,
      "row": 0,
      "thread": 7,
      "query": "UPDATE customers SET first_name='Anne Marie' WHERE id=1004"
    },
    "op": "u", // <4>
    "ts_ms": 1465581029523 // <5>
  }
}
----

.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `first_name` value is `Anne.`

|2
|`after`
| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `first_name` value is now `Anne Marie`.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event is from a different position in the binlog. The source metadata includes:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the updated row
* ID of the MySQL thread that created the event (non-snapshot only)
* MySQL server ID (if available)
* Timestamp for when the change was made in the database

If the xref:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.

|4
|`op`
a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.

|5
|`ts_ms`
a| Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

[NOTE]
====
Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a xref:{link-mysql-connector}#mysql-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section.
====

// Type: continue
[id="mysql-primary-key-updates"]
=== Primary key updates

An `UPDATE` operation that changes a row's primary key field(s) is known
as a primary key change. For a primary key change, in place of an `UPDATE` event record, the connector emits a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change:

* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.

* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.

// Type: continue
[id="mysql-delete-events"]
=== _delete_ events

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": { // <1>
      "id": 1004,
      "first_name": "Anne Marie",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "after": null, // <2>
    "source": { // <3>
      "version": "{debezium-version}",
      "connector": "mysql",
      "name": "mysql-server-1",
      "ts_ms": 1465581902300,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 223344,
      "gtid": null,
      "file": "mysql-bin.000003",
      "pos": 805,
      "row": 0,
      "thread": 7,
      "query": "DELETE FROM customers WHERE id=1004"
    },
    "op": "d", // <4>
    "ts_ms": 1465581902461 // <5>
  }
}
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.

|2
|`after`
| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the updated row
* ID of the MySQL thread that created the event (non-snapshot only)
* MySQL server ID (if available)
* Timestamp for when the change was made in the database

If the xref:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.

|4
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.

|5
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.

MySQL connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

// Type: continue
[id="mysql-tombstone-events"]
=== Tombstone events
When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}’s MySQL connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.

// Type: continue
[id="mysql-truncate-events"]
=== _truncate_ events
A  _truncate_ change event signals that a table has been truncated.
The message key is `null` in this case, the message value looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "source": { // <1>
            "version": "{debezium-version}",
            "name": "mysql-server-1",
            "connector": "mysql",
            "name": "mysql-server-1",
            "ts_ms": 1465581029100,
            "snapshot": false,
            "db": "inventory",
            "table": "customers",
            "server_id": 223344,
            "gtid": null,
            "file": "mysql-bin.000003",
            "pos": 484,
            "row": 0,
            "thread": 7,
            "query": "UPDATE customers SET first_name='Anne Marie' WHERE id=1004"
        },
        "op": "t", // <2>
        "ts_ms": 1465581029523 // <3>
    }
}
----

.Descriptions of _truncate_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`source`
a|Mandatory field that describes the source metadata for the event. In a _truncate_ event value, the `source` field structure is the same as for _create_, _update_, and _delete_ events for the same table, provides this metadata:

* {prodname} version
* Connector type and name
* Binlog name where the event was recorded
* Binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table
* ID of the MySQL thread that truncated the event (non-snapshot only)
* MySQL server ID (if available)
* Timestamp for when the change was made in the database

|2
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `t`, signifying that this table was truncated.

|3
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.  +
+
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

In case a single `TRUNCATE` statement applies to multiple tables,
one _truncate_ change event record for each truncated table will be emitted.

Note that since _truncate_ events represent a change made to an entire table and don't have a message key,
unless you're working with topics with a single partition,
there are no ordering guarantees for the change events pertaining to a table (_create_, _update_, etc.) and _truncate_ events for that table.
For instance a consumer may receive an _update_ event only after a _truncate_ event for that table,
when those events are read from different partitions.

// Type: reference
// ModuleID: how-debezium-mysql-connectors-map-data-types
// Title: How {prodname} MySQL connectors map data types
[[mysql-data-types]]
== Data type mappings

The {prodname} MySQL connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. The MySQL data type of that column dictates how {prodname} represents the value in the event.

Columns that store strings are defined in MySQL with a character set and collation. The MySQL connector uses the column's character set when reading the binary representation of the column values in the binlog events.

The connector can map MySQL data types to both _literal_ and _semantic_ types.

* *Literal type*: how the value is represented using Kafka Connect schema types.
* *Semantic type*: how the Kafka Connect schema captures the meaning of the field (schema name).

If the default data type conversions do not meet your needs, you can {link-prefix}:{link-custom-converters}#custom-converters[create a custom converter] for the connector.

ifdef::product[]
Details are in the following sections:

* xref:mysql-basic-types[]
* xref:mysql-temporal-types[]
* xref:mysql-decimal-types[]
* xref:mysql-boolean-values[]
* xref:mysql-spatial-types[]

endif::product[]

[id="mysql-basic-types"]
=== Basic types

The following table shows how the connector maps basic MySQL data types.

.Descriptions of basic type mappings
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|MySQL type |Literal type |Semantic type

|`BOOLEAN, BOOL`
|`BOOLEAN`
a|_n/a_

|`BIT(1)`
|`BOOLEAN`
a|_n/a_

|`BIT(>1)`
|`BYTES`
a|`io.debezium.data.Bits` +
The `length` schema parameter contains an integer that represents the number of bits. The `byte[]` contains the bits in _little-endian_ form and is sized to contain the specified number of bits. For example, where `n` is bits: +
`numBytes = n/8 + (n%8== 0 ? 0 : 1)`

|`TINYINT`
|`INT16`
a|_n/a_

|`SMALLINT[(M)]`
|`INT16`
a|_n/a_

|`MEDIUMINT[(M)]`
|`INT32`
a|_n/a_

|`INT, INTEGER[(M)]`
|`INT32`
a|_n/a_

|`BIGINT[(M)]`
|`INT64`
a|_n/a_

|`REAL[(M,D)]`
|`FLOAT32`
a|_n/a_

|`FLOAT[(P)]`
|`FLOAT32` or `FLOAT64`
a|The precision is used only to determine storage size.
A precision `P` from 0 to 23 results in a 4-byte single-precision `FLOAT32` column.
A precision `P` from 24 to 53 results in an 8-byte double-precision `FLOAT64` column.

|`FLOAT(M,D)`
|`FLOAT64`
a|As of MySQL 8.0.17, the nonstandard FLOAT(M,D) and DOUBLE(M,D) syntax is deprecated, and should expect support for it be removed in a future version of MySQL, set `FLOAT64` as default.

|`DOUBLE[(M,D)]`
|`FLOAT64`
a|_n/a_

|`CHAR(M)]`
|`STRING`
a|_n/a_

|`VARCHAR(M)]`
|`STRING`
a|_n/a_

|`BINARY(M)]`
|`BYTES` or `STRING`
a|_n/a_ +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`VARBINARY(M)]`
|`BYTES` or `STRING`
a|_n/a_ +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`TINYBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`TINYTEXT`
|`STRING`
a|_n/a_

|`BLOB`
|`BYTES` or `STRING`
a|_n/a_ +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting. +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`TEXT`
|`STRING`
a|_n/a_ +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`MEDIUMBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`MEDIUMTEXT`
|`STRING`
a|_n/a_

|`LONGBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting. +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`LONGTEXT`
|`STRING`
a|_n/a_ +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`JSON`
|`STRING`
a|`io.debezium.data.Json` +
Contains the string representation of a `JSON` document, array, or scalar.

|`ENUM`
|`STRING`
a|`io.debezium.data.Enum` +
The `allowed` schema parameter contains the comma-separated list of allowed values.

|`SET`
|`STRING`
a|`io.debezium.data.EnumSet` +
The `allowed` schema parameter contains the comma-separated list of allowed values.

|`YEAR[(2\|4)]`
|`INT32`
|`io.debezium.time.Year`

|`TIMESTAMP[(M)]`
|`STRING`
a|`io.debezium.time.ZonedTimestamp` +
In link:https://www.iso.org/iso-8601-date-and-time-format.html[ISO 8601] format with microsecond precision. MySQL allows `M` to be in the range of `0-6`.

|===

[id="mysql-temporal-types"]
=== Temporal types

Excluding the `TIMESTAMP` data type, MySQL temporal types depend on the value of the `time.precision.mode` connector configuration property. For `TIMESTAMP` columns whose default value is specified as `CURRENT_TIMESTAMP` or `NOW`, the value `1970-01-01 00:00:00` is used as the default value in the Kafka Connect schema.

MySQL allows zero-values for `DATE`, `DATETIME`, and `TIMESTAMP` columns because zero-values are sometimes preferred over null values. The MySQL connector represents zero-values as null values when the column definition allows null values, or as the epoch day when the column does not allow null values.

.Temporal values without time zones
The `DATETIME` type represents a local date and time such as "2018-01-13 09:48:27". As you can see, there is no time zone information. Such columns are converted into epoch milliseconds or microseconds based on the column’s precision by using UTC. The `TIMESTAMP` type represents a timestamp without time zone information. It is converted by MySQL from the server (or session’s) current time zone into UTC when writing and from UTC into the server (or session's) current time zone when reading back the value. For example:

* `DATETIME` with a value of `2018-06-20 06:37:03` becomes `1529476623000`.
* `TIMESTAMP` with a value of `2018-06-20 06:37:03` becomes `2018-06-20T13:37:03Z`.

Such columns are converted into an equivalent `io.debezium.time.ZonedTimestamp` in UTC based on the server (or session’s) current time zone. The time zone will be queried from the server by default. If this fails, it must be specified explicitly by the database `connectionTimeZone` MySQL configuration option. For example, if the database’s time zone (either globally or configured for the connector by means of the `connectionTimeZone` option) is "America/Los_Angeles", the TIMESTAMP value "2018-06-20 06:37:03" is represented by a `ZonedTimestamp` with the value "2018-06-20T13:37:03Z".

The time zone of the JVM running Kafka Connect and Debezium does not affect these conversions.

More details about properties related to temporal values are in the documentation for xref:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].

time.precision.mode=adaptive_time_microseconds(default)::
The MySQL connector determines the literal type and semantic type based on the column's data type definition so that events represent exactly the values in the database. All time fields are in microseconds. Only positive `TIME` field values in the range of `00:00:00.000000` to `23:59:59.999999` can be captured correctly.
+
.Mappings when `time.precision.mode=adaptive_time_microseconds`
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|MySQL type |Literal type |Semantic type

|`DATE`
|`INT32`
a|`io.debezium.time.Date` +
Represents the number of days since the epoch.

|`TIME[(M)]`
|`INT64`
a|`io.debezium.time.MicroTime` +
Represents the time value in microseconds and does not include time zone information. MySQL allows `M` to be in the range of `0-6`.

|`DATETIME, DATETIME(0), DATETIME(1), DATETIME(2), DATETIME(3)`
|`INT64`
a|`io.debezium.time.Timestamp` +
Represents the number of milliseconds past the epoch and does not include time zone information.

|`DATETIME(4), DATETIME(5), DATETIME(6)`
|`INT64`
a|`io.debezium.time.MicroTimestamp` +
Represents the number of microseconds past the epoch and does not include time zone information.

|===

time.precision.mode=connect::
The MySQL connector uses defined Kafka Connect logical types. This approach is less precise than the default approach and the events could be less precise if the database column has a _fractional second precision_ value of greater than `3`. Values in only the range of `00:00:00.000` to `23:59:59.999` can be handled. Set `time.precision.mode=connect` only if you can ensure that the `TIME` values in your tables never exceed the supported ranges. The `connect` setting is expected to be removed in a future version of {prodname}.
+
.Mappings when `time.precision.mode=connect`
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|MySQL type |Literal type |Semantic type

|`DATE`
|`INT32`
a|`org.apache.kafka.connect.data.Date` +
Represents the number of days since the epoch.

|`TIME[(M)]`
|`INT64`
a|`org.apache.kafka.connect.data.Time` +
Represents the time value in microseconds since midnight and does not include time zone information.

|`DATETIME[(M)]`
|`INT64`
a|`org.apache.kafka.connect.data.Timestamp` +
Represents the number of milliseconds since the epoch, and does not include time zone information.

|===

[id="mysql-decimal-types"]
=== Decimal types

{prodname} connectors handle decimals according to the setting of the xref:{link-mysql-connector}#mysql-property-decimal-handling-mode[`decimal.handling.mode` connector configuration property].

decimal.handling.mode=precise::
+
.Mappings when `decimal.handling.mode=precise`
[cols="30%a,15%a,55%a",options="header",subs="+attributes"]
|===
|MySQL type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|`DECIMAL[(M[,D])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|===

decimal.handling.mode=double::
+
.Mappings when `decimal.handling.mode=double`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|MySQL type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`FLOAT64`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`FLOAT64`
a|_n/a_

|===

decimal.handling.mode=string::
+
.Mappings when `decimal.handling.mode=string`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|MySQL type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`STRING`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`STRING`
a|_n/a_

|===

[id="mysql-boolean-values"]
=== Boolean values

MySQL handles the `BOOLEAN` value internally in a specific way.
The `BOOLEAN` column is internally mapped to the `TINYINT(1)` data type.
When the table is created during streaming then it uses proper `BOOLEAN` mapping as {prodname} receives the original DDL.
During snapshots, {prodname} executes `SHOW CREATE TABLE` to obtain table definitions that return `TINYINT(1)` for both `BOOLEAN` and `TINYINT(1)` columns. {prodname} then has no way to obtain the original type mapping and so maps to `TINYINT(1)`.

To enable you to convert source columns to Boolean data types, {prodname} provides a `TinyIntOneToBooleanConverter` {link-prefix}:{link-custom-converters}#custom-converters[custom converter] that you can use in one of the following ways:

* Map all `TINYINT(1)` or `TINYINT(1) UNSIGNED` columns to `BOOLEAN` types.
* Enumerate a subset of columns by using a comma-separated list of regular expressions. +
To use this type of conversion, you must set the xref:mysql-property-converters[`converters`] configuration property with the `selector` parameter, as shown in the following example:
+
[source]
----
converters=boolean
boolean.type=io.debezium.connector.mysql.converters.TinyIntOneToBooleanConverter
boolean.selector=db1.table1.*, db1.table2.column1
----
* NOTE: MySQL8 not showing the length of `tinyint unsigned` type when snapshot executes `SHOW CREATE TABLE`, which means this converter doesn't work. The new option `length.checker` can solve this issue, the default value is `true`. Disable the `length.checker` and specify the columns that need to be converted to `selector` property instead of converting all columns based on type, as shown in the following example:
+
[source]
----
converters=boolean
boolean.type=io.debezium.connector.mysql.converters.TinyIntOneToBooleanConverter
boolean.length.checker=false
boolean.selector=db1.table1.*, db1.table2.column1
----

[id="mysql-spatial-types"]
=== Spatial types

Currently, the {prodname} MySQL connector supports the following spatial data types.

.Description of spatial type mappings
[cols="35%a,15%a,50%a",options="header",subs="+attributes"]
|===
|MySQL type |Literal type |Semantic type

|`GEOMETRY, +
LINESTRING, +
POLYGON, +
MULTIPOINT, +
MULTILINESTRING, +
MULTIPOLYGON, +
GEOMETRYCOLLECTION`
|`STRUCT`
a|`io.debezium.data.geometry.Geometry` +
Contains a structure with two fields:

* `srid (INT32`: spatial reference system ID that defines the type of geometry object stored in the structure
* `wkb (BYTES)`: binary representation of the geometry object encoded in the Well-Known-Binary (wkb) format. See the link:https://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium] for more details.

|===

// Type: assembly
// ModuleID: setting-up-mysql-to-run-a-debezium-connector
// Title: Setting up MySQL to run a {prodname} connector
[[setting-up-mysql]]
== Setting up MySQL

Some MySQL setup tasks are required before you can install and run a {prodname} connector.

ifdef::product[]
Details are in the following sections:

* xref:creating-a-mysql-user-for-a-debezium-connector[]
* xref:enabling-the-mysql-binlog-for-debezium[]
* xref:enabling-mysql-gtids-for-debezium[]
* xref:configuring-mysql-session-timeouts-for-debezium[]
* xref:enabling-query-log-events-for-debezium-mysql-connectors[]

endif::product[]

// Type: procedure
// ModuleID: creating-a-mysql-user-for-a-debezium-connector
// Title: Creating a MySQL user for a {prodname} connector
[[mysql-creating-user]]
=== Creating a user

A {prodname} MySQL connector requires a MySQL user account. This MySQL user must have appropriate permissions on all databases for which the {prodname} MySQL connector captures changes.

.Prerequisites

* A MySQL server.
* Basic knowledge of SQL commands.

.Procedure

. Create the MySQL user:
+
[source,SQL]
----
mysql> CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';
----

. Grant the required permissions to the user:
+
[source,SQL]
----
mysql> GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';
----
+
The table below describes the permissions.
+
IMPORTANT: If using a hosted option such as Amazon RDS or Amazon Aurora that does not allow a global read lock, table-level locks are used to create the _consistent snapshot_. In this case, you need to also grant `LOCK TABLES` permissions to the user that you create. See xref:{link-mysql-connector}#mysql-snapshots[snapshots] for more details.

. Finalize the user's permissions:
+
[source,SQL]
----
mysql> FLUSH PRIVILEGES;
----

[[permissions-explained-mysql-connector]]
.Descriptions of user permissions
[cols="3,7",options="header",subs="+attributes"]
|===
|Keyword |Description

|`SELECT`
|Enables the connector to select rows from tables in databases. This is used only when performing a snapshot.

|`RELOAD`
|Enables the connector the use of the `FLUSH` statement to clear or reload internal caches, flush tables, or acquire locks. This is used only when performing a snapshot.

|`SHOW DATABASES`
|Enables the connector to see database names by issuing the `SHOW DATABASE` statement. This is used only when performing a snapshot.

|`REPLICATION SLAVE`
|Enables the connector to connect to and read the MySQL server binlog.

|`REPLICATION CLIENT`
a|Enables the connector the use of the following statements:

* `SHOW MASTER STATUS`
* `SHOW SLAVE STATUS`
* `SHOW BINARY LOGS`

The connector always requires this.

|`ON`
|Identifies the database to which the permissions apply.

|`TO 'user'`
|Specifies the user to grant the permissions to.

|`IDENTIFIED BY 'password'`
|Specifies the user's MySQL password.

|===

// Type: procedure
// ModuleID: enabling-the-mysql-binlog-for-debezium
// Title: Enabling the MySQL binlog for {prodname}
[[enable-mysql-binlog]]
=== Enabling the binlog

You must enable binary logging for MySQL replication. The binary logs record transaction updates for replication tools to propagate changes.

.Prerequisites

* A MySQL server.
* Appropriate MySQL user privileges.

.Procedure

. Check whether the `log-bin` option is already on:
+
[source,SQL]
----
// for MySql 5.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM information_schema.global_variables WHERE variable_name='log_bin';
// for MySql 8.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM performance_schema.global_variables WHERE variable_name='log_bin';
----

. If it is `OFF`, configure your MySQL server configuration file with the following properties, which are described in the table below:
+
[source,properties]
----
server-id         = 223344
log_bin           = mysql-bin
binlog_format     = ROW
binlog_row_image  = FULL
expire_logs_days  = 10
----

. Confirm your changes by checking the binlog status once more:
+

[source,SQL]
----
// for MySql 5.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM information_schema.global_variables WHERE variable_name='log_bin';
// for MySql 8.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM performance_schema.global_variables WHERE variable_name='log_bin';
----

[[binlog-configuration-properties-mysql-connector]]
.Descriptions of MySQL binlog configuration properties
[cols="1,4",options="header",subs="+attributes"]
|===
|Property |Description

|`server-id`
|The value for the `server-id` must be unique for each server and replication client in the MySQL cluster. During MySQL connector set up, {prodname} assigns a unique server ID to the connector.

|`log_bin`
|The value of `log_bin` is the base name of the sequence of binlog files.

|`binlog_format`
|The `binlog-format` must be set to `ROW` or `row`.

|`binlog_row_image`
|The `binlog_row_image` must be set to `FULL` or `full`.

|`expire_logs_days`
|This is the number of days for automatic binlog file removal. The default is `0`, which means no automatic removal. Set the value to match the needs of your environment. See xref:{link-mysql-connector}#mysql-purges-binlog-files-used-by-debezium[MySQL purges binlog files].

|===

// Type: procedure
// ModuleID: enabling-mysql-gtids-for-debezium
// Title: Enabling MySQL Global Transaction Identifiers for {prodname}
[[enable-mysql-gtids]]
=== Enabling GTIDs

Global transaction identifiers (GTIDs) uniquely identify transactions that occur on a server within a cluster. Though not required for a {prodname} MySQL connector, using GTIDs simplifies replication and enables you to more easily confirm if primary and replica servers are consistent.

GTIDs are available in MySQL 5.6.5 and later. See the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/replication-options-gtids.html#option_mysqld_gtid-mode[MySQL documentation] for more details.

.Prerequisites

* A MySQL server.
* Basic knowledge of SQL commands.
* Access to the MySQL configuration file.

.Procedure

. Enable `gtid_mode`:
+
[source,SQL]
----
mysql> gtid_mode=ON
----

. Enable `enforce_gtid_consistency`:
+
[source,SQL]
----
mysql> enforce_gtid_consistency=ON
----

. Confirm the changes:
+
[source,SQL]
----
mysql> show global variables like '%GTID%';
----

.Result
[source,SQL]
----
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| enforce_gtid_consistency | ON    |
| gtid_mode                | ON    |
+--------------------------+-------+
----

.Descriptions of GTID options
[cols="3,7",options="header",subs="+attributes"]
|===
|Option |Description

|`gtid_mode`
a|Boolean that specifies whether GTID mode of the MySQL server is enabled or not.

* `ON` = enabled
* `OFF` = disabled

|`enforce_gtid_consistency`
a|Boolean that specifies whether the server enforces GTID consistency by allowing the execution of statements that can be logged in a transactionally safe manner. Required when using GTIDs.

* `ON` = enabled
* `OFF` = disabled

|===


// Type: procedure
// ModuleID: configuring-mysql-session-timeouts-for-debezium
// Title: Configuring MySQL session timesouts for {prodname}
[[mysql-session-timeouts]]
=== Configuring session timeouts

When an initial consistent snapshot is made for large databases, your established connection could timeout while the tables are being read. You can prevent this behavior by configuring `interactive_timeout` and `wait_timeout` in your MySQL configuration file.

.Prerequisites

* A MySQL server.
* Basic knowledge of SQL commands.
* Access to the MySQL configuration file.

.Procedure

. Configure `interactive_timeout`:
+
[source,SQL]
----
mysql> interactive_timeout=<duration-in-seconds>
----

. Configure `wait_timeout`:
+
[source,SQL]
----
mysql> wait_timeout=<duration-in-seconds>
----

.Descriptions of MySQL session timeout options
[cols="3,7",options="header",subs="+attributes"]
|===
|Option |Description

|`interactive_timeout`
a|The number of seconds the server waits for activity on an interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL's documentation] for more details.

|`wait_timeout`
a|The number of seconds the server waits for activity on a non-interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_wait_timeout[MySQL's documentation] for more details.

|===

// Type: procedure
// ModuleID: enabling-query-log-events-for-debezium-mysql-connectors
// Title: Enabling query log events for {prodname} MySQL connectors
[[enable-query-log-events]]
=== Enabling query log events

You might want to see the original `SQL` statement for each binlog event. Enabling the `binlog_rows_query_log_events` option in the MySQL configuration file allows you to do this.

This option is available in MySQL 5.6 and later.

.Prerequisites

* A MySQL server.
* Basic knowledge of SQL commands.
* Access to the MySQL configuration file.

.Procedure

* Enable `binlog_rows_query_log_events`:
+
[source,SQL]
----
mysql> binlog_rows_query_log_events=ON
----
+
`binlog_rows_query_log_events` is set to a value that enables/disables support for including the original `SQL` statement in the binlog entry.
+
** `ON` = enabled
** `OFF` = disabled

// Type: procedure
// ModuleID: validate-binlog-row-value-options-for-debezium-mysql-connectors
// Title: validate binlog row value options for {prodname} MySQL connectors
[[validate-binlog-row-value-options]]
=== Validating binlog row value options

Check `binlog_row_value_options` variable, and make sure that value is **not** set to `PARTIAL_JSON`, since in such case connector might fail to consume *UPDATE* events.

.Prerequisites

* A MySQL server.
* Basic knowledge of SQL commands.
* Access to the MySQL configuration file.

.Procedure

. Check current variable value
+
[source,SQL]
----
mysql> show global variables where variable_name = 'binlog_row_value_options';
----

. Result
+
[source,SQL]
----
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| binlog_row_value_options |       |
+--------------------------+-------+
----

. In case value is `PARTIAL_JSON`, unset this variable by:
+
[source,SQL]
----
mysql> set @@global.binlog_row_value_options="" ;
----

// Type: assembly
// ModuleID: deployment-of-debezium-mysql-connectors
// Title: Deployment of {prodname} MySQL connectors
[[mysql-deploying-a-connector]]
== Deployment

ifdef::community[]
To deploy a {prodname} MySQL connector, you install the {prodname} MySQL connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites
* link:https://zookeeper.apache.org/[Apache Zookeeper], link:http://kafka.apache.org/[Apache Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* MySQL Server is installed and is xref:{link-mysql-connector}#setting-up-mysql[set up to work with the {prodname} connector].

.Procedure

ifeval::['{page-version}' == 'master']
. Download the {prodname} link:{link-mysql-plugin-snapshot}[MySQL connector plug-in].
endif::[]
ifeval::['{page-version}' != 'master']
. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/{debezium-version}/debezium-connector-mysql-{debezium-version}-plugin.tar.gz[MySQL connector plug-in].
endif::[]
. Extract the files into your Kafka Connect environment.
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. xref:{link-mysql-connector}#mysql-example-configuration[Configure the connector] and xref:{link-mysql-connector}#mysql-adding-configuration[add the configuration to your Kafka Connect cluster.]
. Restart your Kafka Connect process to pick up the new JAR files.

If you are working with immutable containers, see link:https://quay.io/organization/debezium[{prodname}'s Container images] for Apache Zookeeper, Apache Kafka, MySQL, and Kafka Connect with the MySQL connector already installed and ready to run.

You can also xref:operations/openshift.adoc[run {prodname} on Kubernetes and OpenShift].
endif::community[]

ifdef::product[]
You can use either of the following methods to deploy a {prodname} MySQL connector:

* xref:openshift-streams-mysql-connector-deployment[Use {StreamsName} to automatically create an image that includes the connector plug-in].
+
This is the preferred method.
* xref:deploying-debezium-mysql-connectors[Build a custom Kafka Connect container image from a Dockerfile].

.Additional resources

* xref:descriptions-of-debezium-mysql-connector-configuration-properties[]

// Type: concept
[id="openshift-streams-mysql-connector-deployment"]
=== MySQL connector deployment using {StreamsName}
include::{partialsdir}/modules/all-connectors/con-connector-streams-deployment.adoc[leveloffset=+1]

//Type: procedure
[id="using-streams-to-deploy-a-debezium-mysql-connector"]
=== Using {StreamsName} to deploy a {prodname} MySQL connector
include::{partialsdir}/modules/all-connectors/proc-using-streams-to-deploy-a-debezium-connector.adoc[leveloffset=+1]

// Type: procedure
// ModuleID: deploying-debezium-mysql-connectors
=== Deploying {prodname} MySQL connectors by building a custom Kafka Connect container image from a Dockerfile

To deploy a {prodname} MySQL connector, you must build a custom Kafka Connect container image that contains the {prodname} connector archive, and then push this container image to a container registry.
You then need to create the following custom resources (CRs):

* A `KafkaConnect` CR that defines your Kafka Connect instance.
  The `image` property in the CR specifies the name of the container image that you create to run your {prodname} connector.
  You apply this CR to the OpenShift instance where link:https://access.redhat.com/products/red-hat-amq#streams[Red Hat {StreamsName}] is deployed.
  {StreamsName} offers operators and images that bring Apache Kafka to OpenShift.

  * A `KafkaConnector` CR that defines your {prodname} MySQL connector.
    Apply this CR to the same OpenShift instance where you apply the `KafkaConnect` CR.

.Prerequisites

* MySQL is running and you completed the steps to {LinkDebeziumUserGuide}#setting-up-mysql-to-run-a-debezium-connector[set up MySQL to work with a {prodname} connector].

* {StreamsName} is deployed on OpenShift and is running Apache Kafka and Kafka Connect.
For more information, see link:{LinkDeployStreamsOpenShift}[{NameDeployStreamsOpenShift}].

* Podman or Docker is installed.

* You have an account and permissions to create and manage containers in the container registry (such as `quay.io` or `docker.io`) to which you plan to add the container that will run your Debezium connector.

.Procedure

. Create the {prodname} MySQL container for Kafka Connect:

.. Create a Dockerfile that uses `{DockerKafkaConnect}` as the base image.
For example, from a terminal window, enter the following command:
+
=====================================================================

[source,shell,subs="+attributes,+quotes"]
----
cat <<EOF >debezium-container-for-{context}.yaml // <1>
FROM {DockerKafkaConnect}
USER root:root
RUN mkdir -p /opt/kafka/plugins/debezium // <2>
RUN cd /opt/kafka/plugins/debezium/ \
&& curl -O {red-hat-maven-repository}debezium/debezium-connector-{connector-file}/{debezium-version}-redhat-__<build_number>__/debezium-connector-{connector-file}-{debezium-version}-redhat-__<build_number>__-plugin.zip \
&& unzip debezium-connector-{connector-file}-{debezium-version}-redhat-__<build_number>__-plugin.zip \
&& rm debezium-connector-{connector-file}-{debezium-version}-redhat-__<build_number>__-plugin.zip
RUN cd /opt/kafka/plugins/debezium/
USER 1001
EOF
----
=====================================================================
+
[cols="1,7",options="header"]
|===
|Item |Description

|1
|You can specify any file name that you want.

|2
|Specifies the path to your Kafka Connect plug-ins directory.
If your Kafka Connect plug-ins directory is in a different location, replace this path with the actual path of your directory.

|===
+
The command creates a Dockerfile with the name `debezium-container-for-mysql.yaml` in the current directory.

.. Build the container image from the `debezium-container-for-mysql.yaml` Docker file that you created in the previous step.
From the directory that contains the file, open a terminal window and enter one of the following commands:
+
[source,shell,options="nowrap"]
----
podman build -t debezium-container-for-mysql:latest .
----
+
[source,shell,options="nowrap"]
----
docker build -t debezium-container-for-mysql:latest .
----
The preceding commands build a container image with the name `debezium-container-for-mysql`.

.. Push your custom image to a container registry, such as `quay.io` or an internal container registry.
The container registry must be available to the OpenShift instance where you want to deploy the image.
Enter one of the following commands:
+
[source,shell,subs="+quotes"]
----
podman push _<myregistry.io>_/debezium-container-for-mysql:latest
----
+
[source,shell,subs="+quotes"]
----
docker push _<myregistry.io>_/debezium-container-for-mysql:latest
----

.. Create a new {prodname} MySQL `KafkaConnect` custom resource (CR).
For example, create a `KafkaConnect` CR with the name `dbz-connect.yaml` that specifies `annotations` and `image` properties as shown in the following example:
+
=====================================================================
[source,yaml,subs="+attributes"]
----
apiVersion: {KafkaConnectApiVersion}
kind: KafkaConnect
metadata:
  name: my-connect-cluster
  annotations:
    strimzi.io/use-connector-resources: "true" // <1>
spec:
  #...
  image: debezium-container-for-mysql  // <2>
----
=====================================================================
+
[cols="1,7",options="header"]
|===
|Item |Description

|1
|`metadata.annotations` indicates to the Cluster Operator that `KafkaConnector` resources are used to configure connectors in this Kafka Connect cluster.

|2
|`spec.image` specifies the name of the image that you created to run your Debezium connector.
This property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator.

|===

.. Apply the `KafkaConnect` CR to the OpenShift Kafka Connect environment by entering the following command:
+
[source,shell,options="nowrap"]
----
oc create -f dbz-connect.yaml
----
+
The command adds a Kafka Connect instance that specifies the name of the image that you created to run your {prodname} connector.

. Create a `KafkaConnector` custom resource that configures your {prodname} MySQL connector instance.
+
You configure a {prodname} MySQL connector in a `.yaml` file that specifies the configuration properties for the connector.
The connector configuration might instruct {prodname} to produce events for a subset of the schemas and tables, or it might set properties so that {prodname} ignores, masks, or truncates values in specified columns that are sensitive, too large, or not needed.
+
The following example configures a {prodname} connector that connects to a MySQL host, `192.168.99.100`, on port `3306`,
and captures changes to the `inventory` database.
`dbserver1` is the server's logical name.
+
.MySQL `inventory-connector.yaml`
[source,yaml,options="nowrap",subs="+attributes"]
----
  apiVersion: {KafkaConnectApiVersion}
  kind: KafkaConnector
  metadata:
    name: inventory-connector  // <1>
    labels:
      strimzi.io/cluster: my-connect-cluster
  spec:
    class: io.debezium.connector.mysql.MySqlConnector
    tasksMax: 1  // <2>
    config:  // <3>
      database.hostname: mysql  // <4>
      database.port: 3306
      database.user: debezium
      database.password: dbz
      database.server.id: 184054  // <5>
      topic.prefix: dbserver1 // <6>
      database.include.list: inventory  // <7>
      schema.history.internal.kafka.bootstrap.servers: my-cluster-kafka-bootstrap:9092  // <8>
      schema.history.internal.kafka.topic: schema-changes.inventory  // <9>
----
+
.Descriptions of connector configuration settings
[cols="1,7",options="header",subs="+attributes"]
|===
|Item |Description

|1
|The name of the connector.

|2
|Only one task should operate at any one time.
Because the MySQL connector reads the MySQL server’s `binlog`,
using a single connector task ensures proper order and event handling.
The Kafka Connect service uses connectors to start one or more tasks that do the work,
and it automatically distributes the running tasks across the cluster of Kafka Connect services.
If any of the services stop or crash,
those tasks will be redistributed to running services.

|3
|The connector’s configuration.

|4
|The database host, which is the name of the container running the MySQL server (`mysql`).

|5
|Unique ID of the connector.

|6
|Topic prefix for the MySQL server or cluster.
This name is used as the prefix for all Kafka topics that receive change event records.

|7
|Changes in only the `inventory` database are captured.

|8
|The list of Kafka brokers that this connector will use to write and recover DDL statements to the database schema history topic.
Upon restart, the connector recovers the schemas of the database that existed at the point in time in the binlog when the connector should begin reading.

|9
|The name of the database schema history topic. This topic is for internal use only and should not be used by consumers.
|===

. Create your connector instance with Kafka Connect.
For example, if you saved your `KafkaConnector` resource in the `inventory-connector.yaml` file, you would run the following command:
+
[source,shell,options="nowrap"]
----
oc apply -f inventory-connector.yaml
----
+
The preceding command registers `inventory-connector` and the connector starts to run against the `inventory` database as defined in the `KafkaConnector` CR.

endif::product[]

ifdef::community[]
[[mysql-example-configuration]]
=== MySQL connector configuration example

Following is an example of the configuration for a connector instance that captures data from a MySQL server on port 3306 at 192.168.99.100, which we logically name `fullfillment`.
Typically, you configure the {prodname} MySQL connector in a JSON file by setting the configuration properties that are available for the connector.

You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, that are larger than a specified size, or that you do not need.

[source,json]
----
{
    "name": "inventory-connector", // <1>
    "config": {
        "connector.class": "io.debezium.connector.mysql.MySqlConnector", // <2>
        "database.hostname": "192.168.99.100", // <3>
        "database.port": "3306", // <4>
        "database.user": "debezium-user", // <5>
        "database.password": "debezium-user-pw", // <6>
        "database.server.id": "184054", <7>
        "topic.prefix": "fullfillment", // <8>
        "database.include.list": "inventory", // <9>
        "schema.history.internal.kafka.bootstrap.servers": "kafka:9092", // <10>
        "schema.history.internal.kafka.topic": "schemahistory.fullfillment", // <11>
        "include.schema.changes": "true" // <12>
    }
}
----
<1> Connector's name when registered with the Kafka Connect service.
<2> Connector's class name.
<3> MySQL server address.
<4> MySQL server port number.
<5> MySQL user with the appropriate privileges.
<6> MySQL user's password.
<7> Unique ID of the connector.
<8> Topic prefix for the MySQL server or cluster.
<9> List of databases hosted by the specified server.
<10> List of Kafka brokers that the connector uses to write and recover DDL statements to the database schema history topic.
<11> Name of the database schema history topic. This topic is for internal use only and should not be used by consumers.
<12> Flag that specifies if the connector should generate events for DDL changes and emit them to the `fulfillment` schema change topic for use by consumers.

endif::community[]

For the complete list of the configuration properties that you can set for the {prodname} MySQL connector,
see xref:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].

ifdef::community[]
You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and starts one connector task that performs the following actions:

* Connects to the MySQL database.
* Reads change-data tables for tables in capture mode.
* Streams change event records to Kafka topics.

[[mysql-adding-configuration]]
=== Adding connector configuration

To start running a MySQL connector, configure a connector configuration, and add the configuration to your Kafka Connect cluster.

.Prerequisites

* xref:{link-mysql-connector}#setting-up-mysql[MySQL is set up to work with a {prodname} connector].
* The {prodname} MySQL connector is installed.

.Procedure

. Create a configuration for the MySQL connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.
endif::community[]

.Results
After the connector starts, it xref:{link-mysql-connector}#mysql-snapshots[performs a consistent snapshot] of the MySQL databases that the connector is configured for.
The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics.

ifdef::product[]
// Type: procedure
[id="verifying-that-the-debezium-mysql-connector-is-running"]
=== Verifying that the {prodname} MySQL connector is running

include::{partialsdir}/modules/all-connectors/proc-verifying-the-connector-deployment.adoc[leveloffset=+1]
endif::product[]

// Type: reference
// Title: Descriptions of {prodname} MySQL connector configuration properties
// ModuleID: descriptions-of-debezium-mysql-connector-configuration-properties
[[mysql-connector-properties]]
=== Connector properties

The {prodname} MySQL connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.
Information about the properties is organized as follows:

* xref:mysql-required-connector-configuration-properties[Required connector configuration properties]
* xref:mysql-advanced-connector-configuration-properties[Advanced connector configuration properties]
* xref:debezium-{context}-connector-database-history-configuration-properties[Database schema history connector configuration properties] that control how {prodname} processes events that it reads from the database schema history topic.
** xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[Pass-through database schema history properties]
* xref:debezium-{context}-connector-pass-through-database-driver-configuration-properties[Pass-through database driver properties] that control the behavior of the database driver.

[id="mysql-required-connector-configuration-properties"]
The following configuration properties are _required_ unless a default value is available.

==== Required {prodname} MySQL connector configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description

|[[mysql-property-name]]<<mysql-property-name, `+name+`>>
|No default
|Unique name for the connector. Attempting to register again with the same name fails. This property is required by all Kafka Connect connectors.

|[[mysql-property-connector-class]]<<mysql-property-connector-class, `+connector.class+`>>
|No default
|The name of the Java class for the connector. Always specify  `io.debezium.connector.mysql.MySqlConnector` for the MySQL connector.

|[[mysql-property-tasks-max]]<<mysql-property-tasks-max, `+tasks.max+`>>
|`1`
|The maximum number of tasks that should be created for this connector. The MySQL connector always uses a single task and therefore does not use this value, so the default is always acceptable.

|[[mysql-property-database-hostname]]<<mysql-property-database-hostname, `+database.hostname+`>>
|No default
|IP address or host name of the MySQL database server.

|[[mysql-property-database-port]]<<mysql-property-database-port, `+database.port+`>>
|`3306`
|Integer port number of the MySQL database server.

|[[mysql-property-database-user]]<<mysql-property-database-user, `+database.user+`>>
|No default
|Name of the MySQL user to use when connecting to the MySQL database server.

|[[mysql-property-database-password]]<<mysql-property-database-password, `+database.password+`>>
|No default
|Password to use when connecting to the MySQL database server.

|[[mysql-property-topic-prefix]]<<mysql-property-topic-prefix, `+topic.prefix+`>>
|No default
|Topic prefix that provides a namespace for the particular MySQL database server/cluster in which {prodname} is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector.
Only alphanumeric characters, hyphens, dots and underscores must be used in the database server logical name. +
 +
[WARNING]
====
Do not change the value of this property.
If you change the name value, after a restart, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
The connector is also unable to recover its database schema history topic.
====

|[[mysql-property-database-server-id]]<<mysql-property-database-server-id, `+database.server.id+`>>
|No default
|A numeric ID of this database client, which must be unique across all currently-running database processes in the MySQL cluster. This connector joins the MySQL database cluster as another server (with this unique ID) so it can read the binlog.

|[[mysql-property-database-include-list]]<<mysql-property-database-include-list, `+database.include.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match the names of the databases for which to capture changes.
The connector does not capture changes in any database whose name is not in `database.include.list`.
By default, the connector captures changes in all databases. +

To match the name of a database, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name. +
If you include this property in the configuration, do not also set the `database.exclude.list` property.

|[[mysql-property-database-exclude-list]]<<mysql-property-database-exclude-list, `+database.exclude.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match the names of databases for which you do not want to capture changes.
The connector captures changes in any database whose name is not in the `database.exclude.list`. +

To match the name of a database, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name. +
If you include this property in the configuration, do not also set the `database.include.list` property.

|[[mysql-property-table-include-list]]<<mysql-property-table-include-list, `+table.include.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables whose changes you want to capture.
The connector does not capture changes in any table that is not included in `table.include.list`.
Each identifier is of the form _databaseName_._tableName_.
By default, the connector captures changes in every non-system table in each database whose changes are being captured. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.exclude.list` property.

|[[mysql-property-table-exclude-list]]<<mysql-property-table-exclude-list, `+table.exclude.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want to capture.
The connector captures changes in any table that is not included in `table.exclude.list`.
Each identifier is of the form _databaseName_._tableName_. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.include.list` property.

|[[mysql-property-column-exclude-list]]<<mysql-property-column-exclude-list, `+column.exclude.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event record values.
Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name.
If you include this property in the configuration, do not also set the `column.include.list` property.

|[[mysql-property-column-include-list]]<<mysql-property-column-include-list, `+column.include.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values.
Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name. +
If you include this property in the configuration, do not set the `column.exclude.list` property.

|[[mysql-property-column-truncate-to-length-chars]]<<mysql-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want to truncate the data in a set of columns when it exceeds the number of characters specified by the _length_ in the property name.
Set `length` to a positive integer value, for example, `column.truncate.to.20.chars`.

The fully-qualified name of a column observes the following format: _databaseName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[mysql-property-column-mask-with-length-chars]]<<mysql-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want the connector to mask the values for a set of columns, for example, if they contain sensitive data.
Set `_length_` to a positive integer to replace data in the specified columns with the number of asterisk (`*`) characters specified by the _length_ in the property name.
Set _length_ to `0` (zero) to replace data in the specified columns with an empty string.

The fully-qualified name of a column observes the following format: _databaseName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[mysql-property-column-mask-hash]]<<mysql-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>;
[[mysql-property-column-mask-hash-v2]]<<mysql-property-column-mask-hash-v2, `column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
a|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form `_<databaseName>_._<tableName>_._<columnName>_`. +
To match the name of a column {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
In the resulting change event record, the values for the specified columns are replaced with pseudonyms. +

A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
 +
In the following example, `CzQMA0cB5K` is a randomly selected salt. +

----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----

If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
 +
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked. +
 +
Hashing strategy version 2 should be used to ensure fidelity if the value is being hashed in different places or systems.

|[[mysql-property-column-propagate-source-type]]<<mysql-property-column-propagate-source-type, `+column.propagate.source.type+`>>
|_n/a_
a|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns for which you want the connector to emit extra parameters that represent column metadata.
When this property is set, the connector adds the following fields to the schema of event records:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_. +
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

|[[mysql-property-datatype-propagate-source-type]]<<mysql-property-datatype-propagate-source-type, `+datatype.propagate.source.type+`>>
|_n/a_
a|An optional, comma-separated list of regular expressions that specify the fully-qualified names of data types that are defined for columns in a database.
When this property is set, for columns with matching data types, the connector emits event records that include the following extra fields in their schema:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._typeName_, or _databaseName_._schemaName_._tableName_._typeName_. +
To match the name of a data type, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the data type; the expression does not match substrings that might be present in a type name.

For the list of MySQL-specific data type names, see the xref:mysql-data-types[MySQL data type mappings].

|[[mysql-property-time-precision-mode]]<<mysql-property-time-precision-mode, `+time.precision.mode+`>>
|`adaptive_time_microseconds`
|Time, date, and timestamps can be represented with different kinds of precision, including: +
 +
`adaptive_time_microseconds` (the default) captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type, with the exception of TIME type fields, which are always captured as microseconds. +
 +
ifdef::community[]
`adaptive` (deprecated) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +
endif::community[]
 +
`connect` always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which use millisecond precision regardless of the database columns' precision.

|[[mysql-property-decimal-handling-mode]]<<mysql-property-decimal-handling-mode,`+decimal.handling.mode+`>>
|`precise`
|Specifies how the connector should handle values for `DECIMAL` and `NUMERIC` columns: +
 +
`precise` (the default) represents them precisely using `java.math.BigDecimal` values represented in change events in a binary form. +
 +
`double` represents them using `double` values, which may result in a loss of precision but is easier to use. +
 +
`string` encodes values as formatted strings, which is easy to consume but  semantic information about the real type is lost.

|[[mysql-property-bigint-unsigned-handling-mode]]<<mysql-property-bigint-unsigned-handling-mode, `+bigint.unsigned.handling.mode+`>>
|`long`
|Specifies how BIGINT UNSIGNED columns should be represented in change events. Possible settings are: +
 +
 `long` represents values by using Java's `long`, which might not offer the precision but which is easy to use in consumers. `long` is usually the preferred setting. +
 +
`precise` uses `java.math.BigDecimal` to represent values, which are encoded in the change events by using a binary representation and Kafka Connect's `org.apache.kafka.connect.data.Decimal` type. Use this setting when working with values larger than 2^63, because these values cannot be conveyed by using `long`.

|[[mysql-property-include-schema-changes]]<<mysql-property-include-schema-changes, `+include.schema.changes+`>>
|`true`
|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded by using a key that contains the database name and whose value includes the DDL statement(s). This is independent of how the connector internally records database schema history.

|[[mysql-property-include-schema-comments]]<<mysql-property-include-schema-comments, `+include.schema.comments+`>>
|`false`
|Boolean value that specifies whether the connector should parse and publish table and column comments on metadata objects. Enabling this option will bring the implications on memory usage. The number and size of logical schema objects is what largely impacts how much memory is consumed by the Debezium connectors, and adding potentially large string data to each of them can potentially be quite expensive.

|[[mysql-property-include-query]]<<mysql-property-include-query, `+include.query+`>>
|`false`
|Boolean value that specifies whether the connector should include the original SQL query that generated the change event. +
 +
If you set this option to `true` then you must also configure MySQL with the `binlog_rows_query_log_events` option set to `ON`. When `include.query` is `true`, the query is not present for events that the snapshot process generates. +
 +
Setting `include.query` to `true` might expose tables or fields that are explicitly excluded or masked by including the original SQL statement in the change event. For this reason, the default setting is `false`.

|[[mysql-property-event-deserialization-failure-handling-mode]]<<mysql-property-event-deserialization-failure-handling-mode, `+event.deserialization.failure.handling.mode+`>>
|`fail`
|Specifies how the connector should react to exceptions during deserialization of binlog events. +
 +
`fail` propagates the exception, which indicates the problematic event and its binlog offset, and causes the connector to stop. +
 +
`warn` logs the problematic event and its binlog offset and then skips the event. +
 +
`ignore` passes over the problematic event and does not log anything.

|[[mysql-property-inconsistent-schema-handling-mode]]<<mysql-property-inconsistent-schema-handling-mode, `+inconsistent.schema.handling.mode+`>>
|`fail`
|Specifies how the connector should react to binlog events that relate to tables that are not present in internal schema representation. That is, the internal representation is not consistent with the database. +
 +
`fail` throws an exception that indicates the problematic event and its binlog offset, and causes the connector to stop. +
 +
`warn` logs the problematic event and its binlog offset and skips the event. +
 +
`skip` passes over the problematic event and does not log anything.

|[[mysql-property-max-batch-size]]<<mysql-property-max-batch-size, `+max.batch.size+`>>
|`2048`
|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.

|[[mysql-property-max-queue-size]]<<mysql-property-max-queue-size, `+max.queue.size+`>>
|`8192`
|Positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set the value of `max.queue.size` to be larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].

|[[mysql-property-max-queue-size-in-bytes]]<<mysql-property-max-queue-size-in-bytes, `+max.queue.size.in.bytes+`>>
|`0`
|A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:mysql-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.

|[[mysql-property-poll-interval-ms]]<<mysql-property-poll-interval-ms, `+poll.interval.ms+`>>
|`500`
|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 1000 milliseconds, or 1 second.

|[[mysql-property-connect-timeout-ms]]<<mysql-property-connect-timeout-ms, `+connect.timeout.ms+`>>
|`30000`
|A positive integer value that specifies the maximum time in milliseconds this connector should wait after trying to connect to the MySQL database server before timing out. Defaults to 30 seconds.

|[[mysql-property-gtid-source-includes]]<<mysql-property-gtid-source-includes, `+gtid.source.includes+`>>
|No default
|A comma-separated list of regular expressions that match source UUIDs in the GTID set used that the connector uses to find the binlog position on the MySQL server.
When this property is set, the connector uses only the GTID ranges that have source UUIDs that match one of the specified `include` patterns.

To match the value of a GTID, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire UUID string; it does not match substrings that might be present in the UUID. +
If you include this property in the configuration, do not also set the `gtid.source.excludes` property.

|[[mysql-property-gtid-source-excludes]]<<mysql-property-gtid-source-excludes, `+gtid.source.excludes+`>>
|No default
|A comma-separated list of regular expressions that match source UUIDs in the GTID set that the connector uses to find the binlog position on the MySQL server.
When this property is set, the connector uses only the GTID ranges that have source UUIDs that do not match any of the specified `exclude` patterns.

To match the value of a GTID, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire UUID string; it does not match substrings that might be present in the UUID. +
If you include this property in the configuration, do not also set the `gtid.source.includes` property.

|[[mysql-property-tombstones-on-delete]]<<mysql-property-tombstones-on-delete, `+tombstones.on.delete+`>>
|`true`
|Controls whether a _delete_ event is followed by a tombstone event. +
 +
`true` - a delete operation is represented by a _delete_ event and a subsequent tombstone event.  +
 +
`false` - only a _delete_ event is emitted. +
 +
After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row in case {link-kafka-docs}/#compaction[log compaction] is enabled for the topic.

|[[mysql-property-message-key-columns]]<<mysql-property-message-key-columns, `+message.key.columns+`>>
|_n/a_
|A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables.

By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns. +
 +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
`_<fully-qualified_tableName>_:__<keyColumn>__,_<keyColumn>_` +
 +
To base a table key on multiple column names, insert commas between the column names.

Each fully-qualified table name is a regular expression in the following format: +
 +
`_<databaseName>_._<tableName>_` +
 +
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list. +
 +
The following example sets the message key for the tables `inventory.customers` and `purchase.orders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
For the table `inventory.customer`, the columns `pk1` and `pk2` are specified as the message key.
For the `purchaseorders` tables in any database, the columns `pk3` and `pk4` server as the message key.

There is no limit to the number of columns that you use to create custom message keys.
However, it's best to use the minimum number that are required to specify a unique key.
|[[mysql-property-binary-handling-mode]]<<mysql-property-binary-handling-mode,`+binary.handling.mode+`>>
|bytes
|Specifies how binary columns, for example, `blob`, `binary`, `varbinary`, should be represented in change events. Possible settings:  +
 +
`bytes` represents binary data as a byte array. +
 +
`base64` represents binary data as a base64-encoded String. +
 +
`base64-url-safe` represents binary data as a base64-url-safe-encoded String. +
 +
`hex` represents binary data as a hex-encoded (base16) String.

|[[mysql-property-schema-name-adjustment-mode]]<<mysql-property-schema-name-adjustment-mode,`+schema.name.adjustment.mode+`>>
|none
|Specifies how schema names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +

|===

[id="mysql-advanced-connector-configuration-properties"]
==== Advanced MySQL connector configuration properties

The following table describes xref:{link-mysql-connector}#mysql-advanced-connector-configuration-properties[advanced MySQL connector properties]. The default values for these properties rarely need to be changed. Therefore, you do not need to specify them in the connector configuration.

.Descriptions of MySQL connector advanced configuration properties
[cols="30%a,20%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description

|[[mysql-property-connect-keep-alive]]<<mysql-property-connect-keep-alive, `+connect.keep.alive+`>>
|`true`
|A Boolean value that specifies whether a separate thread should be used to ensure that the connection to the MySQL server/cluster is kept alive.

|[[mysql-property-converters]]<<mysql-property-converters, `converters`>>
|No default
|Enumerates a comma-separated list of the symbolic names of the {link-prefix}:{link-custom-converters}#custom-converters[custom converter] instances that the connector can use. +
For example, `boolean`. +
This property is required to enable the connector to use a custom converter.

For each converter that you configure for a connector, you must also add a `.type` property, which specifies the fully-qualifed name of the class that implements the converter interface.
The `.type` property uses the following format: +

`_<converterSymbolicName>_.type` +

For example, +

 boolean.type: io.debezium.connector.mysql.converters.TinyIntOneToBooleanConverter

If you want to further control the behavior of a configured converter, you can add one or more configuration parameters to pass values to the converter.
To associate these additional configuration parameter with a converter, prefix the paraemeter name with the symbolic name of the converter. +
 +
For example, to define a `selector` parameter that specifies the subset of columns that the `boolean` converter processes, add the following property: +

 boolean.selector=db1.table1.*, db1.table2.column1

|[[mysql-property-table-ignore-builtin]]<<mysql-property-table-ignore-builtin, `+table.ignore.builtin+`>>
|`true`
|A Boolean value that specifies whether built-in system tables should be ignored. This applies regardless of the table include and exclude lists. By default, system tables are excluded from having their changes captured, and no events are generated when changes are made to any system tables.

|[[mysql-property-database-ssl-mode]]<<mysql-property-database-ssl-mode, `+database.ssl.mode+`>>
|`disabled`
|Specifies whether to use an encrypted connection. Possible settings are: +
 +
`disabled` specifies the use of an unencrypted connection. +
 +
`preferred` establishes an encrypted connection if the server supports secure connections. If the server does not support secure connections, falls back to an unencrypted connection. +
 +
`required` establishes an encrypted connection or fails if one cannot be made for any reason. +
 +
`verify_ca` behaves like `required` but additionally it verifies the server TLS certificate against the configured Certificate Authority (CA) certificates and fails if the server TLS certificate does not match any valid CA certificates. +
 +
`verify_identity` behaves like `verify_ca` but additionally verifies that the server certificate matches the host of the remote connection.
ifdef::community[]
|[[mysql-property-binlog-buffer-size]]<<mysql-property-binlog-buffer-size, `+binlog.buffer.size+`>>
|0
|The size of a look-ahead buffer used by the binlog reader. The default setting of `0` disables buffering. +
 +
Under specific conditions, it is possible that the MySQL binlog contains uncommitted data finished by a `ROLLBACK` statement.
Typical examples are using savepoints or mixing temporary and regular table changes in a single transaction. +
 +
When a beginning of a transaction is detected then {prodname} tries to roll forward the binlog position and find either `COMMIT` or `ROLLBACK` so it can determine whether to stream the changes from the transaction.
The size of the binlog buffer defines the maximum number of changes in the transaction that {prodname} can buffer while searching for transaction boundaries.
If the size of the transaction is larger than the buffer then {prodname} must rewind and re-read the events that have not fit into the buffer while streaming. +
 +
NOTE: This feature is incubating. Feedback is encouraged. It is expected that this feature is not completely polished.
endif::community[]

|[[mysql-property-snapshot-mode]]<<mysql-property-snapshot-mode, `+snapshot.mode+`>>
|`initial`
|Specifies the criteria for running a snapshot when the connector starts. Possible settings are: +
 +
`initial` - the connector runs a snapshot only when no offsets have been recorded for the logical server name. +
 +
`initial_only` - the connector runs a snapshot only when no offsets have been recorded for the logical server name and then stops; i.e. it will not read change events from the binlog. +
 +
`when_needed` - the connector runs a snapshot upon startup whenever it deems it necessary. That is, when no offsets are available, or when a previously recorded offset specifies a binlog location or GTID that is not available in the server. +
 +
`never` - the connector never uses snapshots. Upon first startup with a logical server name, the connector reads from the beginning of the binlog. Configure this behavior with care. It is valid only when the binlog is guaranteed to contain the entire history of the database. +
 +
`schema_only` - the connector runs a snapshot of the schemas and not the data. This setting is useful when you do not need the topics to contain a consistent snapshot of the data but need them to have only the changes since the connector was started. +
 +
`schema_only_recovery` - this is a recovery setting for a connector that has already been capturing changes. When you restart the connector, this setting enables recovery of a corrupted or lost database schema history topic. You might set it periodically to "clean up" a database schema history topic that has been growing unexpectedly. Database schema history topics require infinite retention.

|[[mysql-property-snapshot-locking-mode]]<<mysql-property-snapshot-locking-mode, `+snapshot.locking.mode+`>>
|`minimal`
a|Controls whether and how long the connector holds the global MySQL read lock, which prevents any updates to the database, while the connector is performing a snapshot. Possible settings are: +
 +
`minimal` - the connector holds the global read lock for only the initial portion of the snapshot during which the connector reads the database schemas and other metadata. The remaining work in a snapshot involves selecting all rows from each table. The connector can do this in a consistent fashion by using a REPEATABLE READ transaction. This is the case even when the global read lock is no longer held and other MySQL clients are updating the database. +
 +
`minimal_percona` - the connector holds link:https://www.percona.com/doc/percona-server/5.7/management/backup_locks.html[the global backup lock] for only the initial portion of the snapshot during which the connector reads the database schemas and other metadata. The remaining work in a snapshot involves selecting all rows from each table. The connector can do this in a consistent fashion by using a REPEATABLE READ transaction. This is the case even when the global backup lock is no longer held and other MySQL clients are updating the database. This mode does not flush tables to disk, is not blocked by long-running reads, and is available only in Percona Server. +
 +
`extended` - blocks all writes for the duration of the snapshot. Use this setting if there are clients that are submitting operations that MySQL excludes from REPEATABLE READ semantics. +
 +
`none` - prevents the connector from acquiring any table locks during the snapshot. While this setting is allowed with all snapshot modes, it is safe to use if and _only_ if no schema changes are happening while the snapshot is running. For tables defined with MyISAM engine, the tables would still be locked despite this property being set as MyISAM acquires a table lock. This behavior is unlike InnoDB engine, which acquires row level locks.

|[[mysql-property-snapshot-include-collection-list]]<<mysql-property-snapshot-include-collection-list, `+snapshot.include.collection.list+`>>
| All tables specified in `table.include.list`
|An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<databaseName>.<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:mysql-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's xref:mysql-property-snapshot-mode[`snapshot.mode`] property is set to a value other than `never`. +
This property does not affect the behavior of incremental snapshots. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.

|[[mysql-property-snapshot-select-statement-overrides]]<<mysql-property-snapshot-select-statement-overrides, `+snapshot.select.statement.overrides+`>>
|No default
|Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.

The property contains a comma-separated list of fully-qualified table names in the form `_<databaseName>.<tableName>_`. For example, +
 +
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
 +
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
 +
`snapshot.select.statement.overrides._<databaseName>_._<tableName>_`.
For example,
`snapshot.select.statement.overrides.customers.orders`. +
 +
Example:

From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:

----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----

In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.
|[[mysql-property-min-row-count-to-stream-results]]<<mysql-property-min-row-count-to-stream-results, `+min.row.count.to.stream.results+`>>
|`1000`
|During a snapshot, the connector queries each table for which the connector is configured to capture changes. The connector uses each query result to produce a read event that contains data for all rows in that table. This property determines whether the MySQL connector puts results for a table into memory, which is fast but requires large amounts of memory, or streams the results, which can be slower but work for very large tables. The setting of this property specifies the minimum number of rows a table must contain before the connector streams results. +
 +
To skip all table size checks and always stream all results during a snapshot, set this property to `0`.

|[[mysql-property-heartbeat-interval-ms]]<<mysql-property-heartbeat-interval-ms, `+heartbeat.interval.ms+`>>
|`0`
|Controls how frequently the connector sends heartbeat messages to a Kafka topic. The default behavior is that the connector does not send heartbeat messages. +
 +
Heartbeat messages are useful for monitoring whether the connector is receiving change events from the database. Heartbeat messages might help decrease the number of change events that need to be re-sent when a connector restarts. To send heartbeat messages, set this property to a positive integer, which indicates the number of milliseconds between heartbeat messages.

|[[mysql-property-heartbeat-action-query]]<<mysql-property-heartbeat-action-query, `+heartbeat.action.query+`>>
|No default
|Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. +
 +
For example, this can be used to periodically capture the state of the executed GTID set in the source database. +
 +
`INSERT INTO gtid_history_table (select * from mysql.gtid_executed)`

|[[mysql-property-database-initial-statements]]<<mysql-property-database-initial-statements, `+database.initial.statements+`>>
|No default
|A semicolon separated list of SQL statements to be executed when a JDBC connection, not the connection that is reading the transaction log, to the database is established.
To specify a semicolon as a character in a SQL statement and not as a delimiter, use two semicolons, (`;;`). +
 +
The connector might establish JDBC connections at its own discretion, so this property is ony for configuring session parameters. It is not for executing DML statements.

|[[mysql-property-snapshot-delay-ms]]<<mysql-property-snapshot-delay-ms, `+snapshot.delay.ms+`>>
|No default
|An interval in milliseconds that the connector should wait before performing a snapshot when the connector starts. If you are starting multiple connectors in a cluster, this property is useful for avoiding snapshot interruptions, which might cause re-balancing of connectors.

|[[mysql-property-snapshot-fetch-size]]<<mysql-property-snapshot-fetch-size, `+snapshot.fetch.size+`>>
|No default
|During a snapshot, the connector reads table content in batches of rows. This property specifies the maximum number of rows in a batch.

|[[mysql-property-snapshot-lock-timeout-ms]]<<mysql-property-snapshot-lock-timeout-ms, `+snapshot.lock.timeout.ms+`>>
|`10000`
|Positive integer that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If the connector cannot acquire table locks in this time interval, the snapshot fails. See xref:{link-mysql-connector}#mysql-snapshots[how MySQL connectors perform database snapshots].

|[[mysql-property-enable-time-adjuster]]<<mysql-property-enable-time-adjuster, `+enable.time.adjuster+`>>
|`true`
|Boolean value that indicates whether the connector converts a 2-digit year specification to 4 digits. Set to `false` when conversion is fully delegated to the database. +
 +
MySQL allows users to insert year values with either 2-digits or 4-digits. For 2-digit values, the value gets mapped to a year in the range 1970 - 2069. The default behavior is that the connector does the conversion.

ifdef::community[]
|[[mysql-property-source-struct-version]]<<mysql-property-source-struct-version, `+source.struct.version+`>>
|`v2`
|Schema version for the `source` block in {prodname} events.  {prodname} 0.10 introduced a few breaking changes to the structure of the `source` block in order to unify the exposed structure across all the connectors. +
 +
By setting this option to `v1`, the structure used in earlier versions can be produced. However, this setting is not recommended and is planned for removal in a future {prodname} version.
endif::community[]

|[[mysql-property-sanitize-field-names]]<<mysql-property-sanitize-field-names, `+sanitize.field.names+`>>
|`true` if connector configuration sets the `key.converter` or `value.converter` property to the Avro converter. +
`false` if not.
|Indicates whether field names are sanitized to adhere to xref:{link-avro-serialization}#avro-naming[Avro naming requirements].

|[[mysql-property-skipped-operations]]<<mysql-property-skipped-operations, `+skipped.operations+`>>
|`t`
|A comma-separated list of operation types that will be skipped during streaming.
The operations include: `c` for inserts/create, `u` for updates, `d` for deletes, `t` for truncates, and `none` to not skip any operations.
By default, truncate operations are skipped.

|[[mysql-property-signal-data-collection]]<<mysql-property-signal-data-collection,`+signal.data.collection+`>>
|No default value
|Fully-qualified name of the data collection that is used to send xref:{link-signalling}#debezium-signaling-enabling-signaling[signals] to the connector. +
Use the following format to specify the collection name: +
`_<databaseName>_._<tableName>_`

|[[mysql-property-incremental-snapshot-allow-schema-changes]]<<mysql-property-incremental-snapshot-allow-schema-changes, `+incremental.snapshot.allow.schema.changes+`>>
|`false`
| Allow schema changes during an incremental snapshot. When enabled the connector will detect schema change during an incremental snapshot and re-select a current chunk to avoid locking DDLs. +
 +
Note that changes to a primary key are not supported and can cause incorrect results if performed during an incremental snapshot. Another limitation is that if a schema change affects only columns' default values, then the change won't be detected until the DDL is processed from the binlog stream. This doesn't affect the snapshot events' values, but the schema of snapshot events may have outdated defaults.

|[[mysql-property-incremental-snapshot-chunk-size]]<<mysql-property-incremental-snapshot-chunk-size, `+incremental.snapshot.chunk.size+`>>
|`1024`
|The maximum number of rows that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.

ifdef::community[]
|[[mysql-property-read-only]]<<mysql-property-read-only, `+read.only+`>>
|`false`
|Switch to alternative incremental snapshot watermarks implementation to avoid writes to signal data collection
endif::community[]

|[[mysql-property-provide-transaction-metadata]]<<mysql-property-provide-transaction-metadata, `provide.transaction.metadata`>>
|`false`
|Determines whether the connector generates events with transaction boundaries and enriches change event envelopes with transaction metadata. Specify `true` if you want the connector to do this. See xref:{link-mysql-connector}#mysql-transaction-metadata[Transaction metadata] for details.

|[[mysql-property-topic-naming-strategy]]<<mysql-property-topic-naming-strategy, `topic.naming.strategy`>>
|`io.debezium.schema.DefaultTopicNamingStrategy`
|The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc., defaults to `DefaultTopicNamingStrategy`.

|[[mysql-property-topic-delimiter]]<<mysql-property-topic-delimiter, `topic.delimiter`>>
|`.`
|Specify the delimiter for topic name, defaults to `.`.

|[[mysql-property-topic-cache-size]]<<mysql-property-topic-cache-size, `topic.cache.size`>>
|`10000`
|The size used for holding the topic names in bounded concurrent hash map. This cache will help to determine the topic name corresponding to a given data collection.

|[[mysql-property-topic-heartbeat-prefix]]<<mysql-property-topic-heartbeat-prefix, `+topic.heartbeat.prefix+`>>
|`__debezium-heartbeat`
|Controls the name of the topic to which the connector sends heartbeat messages. The topic name has this pattern: +
 +
_topic.heartbeat.prefix_._topic.prefix_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `__debezium-heartbeat.fulfillment`.

|[[mysql-property-topic-transaction]]<<mysql-property-topic-transaction, `topic.transaction`>>
|`transaction`
|Controls the name of the topic to which the connector sends transaction metadata messages. The topic name has this pattern: +
 +
_topic.prefix_._topic.transaction_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `fulfillment.transaction`.

|===

[id="debezium-mysql-connector-database-history-configuration-properties"]
==== {prodname} connector database schema history configuration properties

include::{partialsdir}/modules/all-connectors/ref-connector-configuration-database-history-properties.adoc[leveloffset=+1]

[id="debezium-{context}-connector-kafka-signals-configuration-properties"]
==== {prodname} connector Kafka signals configuration properties

When the MySQL connector is configured as read-only, the alternative for the signaling table is the signals Kafka topic.

{prodname} provides a set of `signal.*` properties that control how the connector interacts with the Kafka signals topic.

The following table describes the `signal` properties.

.Kafka signals configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-signal-kafka-topic]]<<{context}-property-signal-kafka-topic, `+signal.kafka.topic+`>>
|No default
|The name of the Kafka topic that the connector monitors for ad hoc signals.

|[[{context}-property-signal-kafka-bootstrap-servers]]<<{context}-property-signal-kafka-bootstrap-servers, `+signal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. Each pair should point to the same Kafka cluster used by the Kafka Connect process.

|[[{context}-property-signal-kafka-poll-timeout-ms]]<<{context}-property-signal-kafka-poll-timeout-ms, `+signal.kafka.poll.timeout.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds the connector should wait when polling signals. The default is 100ms.

|===

[id="debezium-{context}-connector-pass-through-signals-kafka-consumer-configuration-properties"]
==== {prodname} connector pass-through signals Kafka consumer client configuration properties

The {prodname} connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix `signals.consumer.*`.
For example, the connector passes properties such as `signal.consumer.security.protocol=SSL` to the Kafka consumer.

As is the case with the xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[pass-through properties for database schema history clients], {prodname} strips the prefixes from the properties before it passes them to the Kafka signals consumer.

[id="debezium-{context}-connector-pass-through-database-driver-configuration-properties"]
==== {prodname} connector pass-through database driver configuration properties

include::{partialsdir}/modules/all-connectors/ref-connector-pass-through-database-driver-configuration-properties.adoc[leveloffset=+1]

// Type: assembly
// ModuleID: monitoring-debezium-mysql-connector-performance
// Title: Monitoring {prodname} MySQL connector performance
[[mysql-monitoring]]
== Monitoring

The {prodname} MySQL connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* xref:{link-mysql-connector}#mysql-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:{link-mysql-connector}#mysql-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is reading the binlog.
* xref:{link-mysql-connector}#mysql-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history.

{link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.

// Type: reference
// ModuleID: monitoring-debezium-during-snapshots-of-mysql-databases
// Title: Monitoring {prodname} during snapshots of MySQL databases
[[mysql-snapshot-metrics]]
=== Snapshot metrics

include::{partialsdir}/modules/all-connectors/frag-common-mbean-name.adoc[leveloffset=+1,tags=common-snapshot]

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-snapshot-metrics.adoc[leveloffset=+1]

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-incremental-snapshot-metrics.adoc[leveloffset=+1]

The {prodname} MySQL connector also provides the `HoldingGlobalLock` custom snapshot metric. This metric is set to a Boolean value that indicates whether the connector currently holds a global or table write lock.

// Type: reference
// ModuleID: monitoring-debezium-mysql-connector-record-streaming
// Title: Monitoring {prodname} MySQL connector record streaming
[[mysql-streaming-metrics]]
=== Streaming metrics

Transaction-related attributes are available only if binlog event buffering is enabled. See xref:{link-mysql-connector}#mysql-property-binlog-buffer-size[`binlog.buffer.size`] in the advanced connector configuration properties for more details.

include::{partialsdir}/modules/all-connectors/frag-common-mbean-name.adoc[leveloffset=+1,tags=common-streaming]

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-streaming-metrics.adoc[leveloffset=+1]

The {prodname} MySQL connector also provides the following additional streaming metrics:

.Descriptions of additional streaming metrics
[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|[[binlog-filename]]<<binlog-filename,`+BinlogFilename+`>>
|`string`
|The name of the binlog file that the connector has most recently read.

|[[binlog-position]]<<binlog-position,`+BinlogPosition+`>>
|`long`
|The most recent position (in bytes) within the binlog that the connector has read.

|[[is-gtid-mode-enabled]]<<is-gtid-mode-enabled,`+IsGtidModeEnabled+`>>
|`boolean`
|Flag that denotes whether the connector is currently tracking GTIDs from MySQL server.

|[[gtid-set]]<<gtid-set,`+GtidSet+`>>
|`string`
|The string representation of the most recent GTID set processed by the connector when reading the binlog.

|[[number-of-skipped-events]]<<number-of-skipped-events,`+NumberOfSkippedEvents+`>>
|`long`
|The number of events that have been skipped by the MySQL connector. Typically events are skipped due to a malformed or unparseable event from MySQL's binlog.

|[[number-of-disconnects]]<<number-of-disconnects,`+NumberOfDisconnects+`>>
|`long`
|The number of disconnects by the MySQL connector.

|[[number-of-rolled-back-transactions]]<<number-of-rolled-back-transactions,`+NumberOfRolledBackTransactions+`>>
|`long`
|The number of processed transactions that were rolled back and not streamed.

|[[number-of-not-well-formed-transactions]]<<number-of-not-well-formed-transactions,`+NumberOfNotWellFormedTransactions+`>>
|`long`
|The number of transactions that have not conformed to the expected protocol of `BEGIN` + `COMMIT`/`ROLLBACK`. This value should be `0` under normal conditions.

|[[number-of-large-transactions]]<<number-of-large-transactions,`+NumberOfLargeTransactions+`>>
|`long`
|The number of transactions that have not fit into the look-ahead buffer. For optimal performance, this value should be significantly smaller than `NumberOfCommittedTransactions` and `NumberOfRolledBackTransactions`.

|===

// Type: reference
// ModuleID: monitoring-debezium-mysql-connector-schema-history
// Title: Monitoring {prodname} MySQL connector schema history
[[mysql-schema-history-metrics]]
=== Schema history metrics

include::{partialsdir}/modules/all-connectors/ref-connector-monitoring-schema-history-metrics.adoc[leveloffset=+1]

// Type: concept
// ModuleID: how-debezium-mysql-connectors-handle-faults-and-problems
// Title: How {prodname} MySQL connectors handle faults and problems
[[mysql-when-things-go-wrong]]
== Behavior when things go wrong

{prodname} is a distributed system that captures all changes in multiple upstream databases; it never misses or loses an event. When the system is operating normally or being managed carefully then {prodname} provides _exactly once_ delivery of every change event record.

If a fault does happen then the system does not lose any events. However, while it is recovering from the fault, it might repeat some change events. In these abnormal situations, {prodname}, like Kafka, provides _at least once_ delivery of change events.

ifdef::community[]
The rest of this section describes how {prodname} handles various kinds of faults and problems.
endif::community[]

ifdef::product[]
Details are in the following sections:

* xref:debezium-mysql-connector-configuration-and-startup-errors[]
* xref:mysql-becomes-unavailable-while-debezium-is-running[]
* xref:debezium-mysql-kafka-connect-process-stops-gracefully[]
* xref:debezium-mysql-kafka-connect-process-crashes[]
* xref:debezium-mysql-kafka-process-becomes-unavailable[]
* xref:mysql-purges-binlog-files-used-by-debezium[]

endif::product[]

[id="debezium-mysql-connector-configuration-and-startup-errors"]
=== Configuration and startup errors

In the following situations, the connector fails when trying to start, reports an error or exception in the log, and stops running:

* The connector's configuration is invalid.
* The connector cannot successfully connect to the MySQL server by using the specified connection parameters.
* The connector is attempting to restart at a position in the binlog for which MySQL no longer has the history available.

In these cases, the error message has details about the problem and possibly a suggested workaround. After you correct the configuration or address the MySQL problem, restart the connector.

[id="mysql-becomes-unavailable-while-debezium-is-running"]
=== MySQL becomes unavailable

If your MySQL server becomes unavailable, the {prodname} MySQL connector fails with an error and the connector stops. When the server is available again, restart the connector.

However, if GTIDs are enabled for a highly available MySQL cluster, you can restart the connector immediately. It will connect to a different MySQL server in the cluster, find the location in the server's binlog that represents the last transaction, and begin reading the new server's binlog from that specific location.

If GTIDs are not enabled, the connector records the binlog position of only the MySQL server to which it was connected. To restart from the correct binlog position, you must reconnect to that specific server.

[id="debezium-mysql-kafka-connect-process-stops-gracefully"]
=== Kafka Connect stops gracefully

When Kafka Connect stops gracefully, there is a short delay while the {prodname} MySQL connector tasks are stopped and restarted on new Kafka Connect processes.

[id="debezium-mysql-kafka-connect-process-crashes"]
=== Kafka Connect process crashes

If Kafka Connect crashes, the process stops and any {prodname} MySQL connector tasks terminate without their most recently-processed offsets being recorded. In distributed mode, Kafka Connect restarts the connector tasks on other processes. However, the MySQL connector resumes from the last offset recorded by the earlier processes. This means that the replacement tasks might generate some of the same events processed prior to the crash, creating duplicate events.

Each change event message includes source-specific information that you can use to identify duplicate events, for example:

* Event origin
* MySQL server's event time
* The binlog file name and position
* GTIDs (if used)

[id="debezium-mysql-kafka-process-becomes-unavailable"]
=== Kafka becomes unavailable

The Kafka Connect framework records {prodname} change events in Kafka by using the Kafka producer API. If the Kafka brokers become unavailable, the {prodname} MySQL connector pauses until the connection is reestablished and the connector resumes where it left off.

[id="mysql-purges-binlog-files-used-by-debezium"]
=== MySQL purges binlog files

If the {prodname} MySQL connector stops for too long, the MySQL server purges older binlog files and the connector's last position may be lost. When the connector is restarted, the MySQL server no longer has the starting point and the connector performs another initial snapshot. If the snapshot is disabled, the connector fails with an error.

See xref:{link-mysql-connector}#mysql-snapshots[snapshots] for details about how MySQL connectors perform initial snapshots.
